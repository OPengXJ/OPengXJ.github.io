<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>🤗️怎样写单元测试与如何判断slice中的一个元素</title>
    <link href="/2022/08/13/%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95/"/>
    <url>/2022/08/13/%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>Go中没有可以直接判断一个元素是否在slice中的函数，所以用于判断的方法有遍历，还有改进点的构建Map，用Sort包，那到底是Map好还是Sort包好呢，我们做个单元测试就知道了。</p><span id="more"></span><h1 id="🤗️怎样写单元测试与如何判断slice中的一个元素"><a href="#🤗️怎样写单元测试与如何判断slice中的一个元素" class="headerlink" title="🤗️怎样写单元测试与如何判断slice中的一个元素"></a>🤗️怎样写单元测试与如何判断slice中的一个元素</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5555r4z1xj21900u0n76.jpg"></p><h2 id="单元测试与性能测试"><a href="#单元测试与性能测试" class="headerlink" title="单元测试与性能测试"></a>单元测试与性能测试</h2><blockquote><p>这里我们主要用了Go的testing包。</p></blockquote><p><strong>白盒测试：</strong>测试代码和要测试的代码放在同一包中，测试代码可以读取到该包中的不可导出变量，所以我们在编写需要访问到不可导出变量、函数、常量的测试代码时就要用这种方法，同时这也是较为推荐的方法。</p><p><strong>黑盒测试：</strong>可以不放在同一个包中，但只能测试可导出的标示符。</p><blockquote><p>测试文件的规范要求：测试文件命名规范、函数名规范、变量名规范</p></blockquote><p>测试文件名规范：Go的测试文件名必须以_test.go结尾，因为Go就是利用这个去判断哪些是测试文件，哪些是正式文件的，我们在执行<code>go test</code>命令时，这些文件会给执行，而在构建程序时则会忽略这些文件。</p><p>函数名规范：测试函数必须使用Test&#x2F;Benchmark&#x2F;Example开头，例如TestXxx、BenchmarkXxx、ExampleXxx，Xxx通常是要测试的函数名。</p><p>变量名规范：Go没有对变量名有硬性的要求，但为了清晰的表达函数的实际输出和预期输出，可以将这两类输出命名为expected&#x2F;actual或者got&#x2F;want。</p><h3 id="🤔单元测试："><a href="#🤔单元测试：" class="headerlink" title="🤔单元测试："></a>🤔单元测试：</h3><p>单元测试的测试用例函数以Test开头，函数参数必须是<code>*tesing.T</code>，可以用该类型来记录错误或测试状态。</p><blockquote><p>至此我们可以得出一个总结，要写一个单元测试必要的规范，1.文件名以_test.go结尾，2.函数名以Test开头，3.函数参数为<code>testing.T</code></p></blockquote><p>我们可以调用 <code>testing.T</code> 的 <code>Error</code> 、<code>Errorf</code> 、<code>FailNow</code> 、<code>Fatal</code> 、<code>FatalIf</code> 方法，来说明测试不通过；调用 <code>Log</code> 、<code>Logf</code> 方法来记录测试信息。函数列表和相关描述如下表所示：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>t.Log, t.Logf</td><td>正常信息</td></tr><tr><td>t.Error, t.Errorf</td><td>测试失败信息</td></tr><tr><td>t.Fatal, t.Fatalf</td><td>致命错误，测试程序退出的信息</td></tr><tr><td>t.Fail</td><td>当前测试标记为失败</td></tr><tr><td>t.Failed</td><td>查看失败标记</td></tr><tr><td>t.FailNow</td><td>标记失败，并终止当前测试函数的执行。需要注意的是，我们只能在运行测试函数的Goroutine中调用t.FailNow方法，而不能在我们测试代码创建出的Goroutine中调用它</td></tr></tbody></table><p><strong>一个栗子🌰：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//math.go</span><br><br><span class="hljs-keyword">package</span> Test<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;math&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Abs</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>b := <span class="hljs-type">float64</span>(a)<br><span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(math.Abs(b))<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> Test<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAbs</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>got := Abs(<span class="hljs-number">-1</span>)<br><span class="hljs-keyword">if</span> got != <span class="hljs-number">1</span> &#123;<br>t.Error(<span class="hljs-string">&quot;fault&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>t.Log(<span class="hljs-string">&quot;right&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">终端执行命令</span><br><br>go test &quot;math.go&quot; &quot;math_test.go&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果想执行文件夹中的所有测试用例那就直接go <span class="hljs-built_in">test</span>即可</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">也可以用go <span class="hljs-built_in">test</span>的参数来完成执行指定的函数</span><br></code></pre></td></tr></table></figure><p>go test支持一下三个参数：</p><ul><li><p>-v，显示所有测试函数的运行细节：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">pengxj@PEngxJdeMacBook-Pro test % go test -v &quot;math.go&quot; &quot;math_test.go&quot; <br>=== RUN   TestAbs<br>    math_test.go:10: right<br>--- PASS: TestAbs (0.00s)<br>PASS<br>ok      command-line-arguments  0.612s<br></code></pre></td></tr></table></figure></li><li><p>-run &lt; regexp&gt;，指定要执行的测试函数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">pengxj@PEngxJdeMacBook-Pro test % go test -run &quot;TestAbs&quot;             <br>PASS<br>ok      test    0.608s<br></code></pre></td></tr></table></figure></li><li><p>-count N，指定执行测试函数的次数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">pengxj@PEngxJdeMacBook-Pro test % go test -v -run &quot;TestAbs&quot; -count=2<br>=== RUN   TestAbs<br>    math_test.go:10: right<br>--- PASS: TestAbs (0.00s)<br>=== RUN   TestAbs<br>    math_test.go:10: right<br>--- PASS: TestAbs (0.00s)<br>PASS<br>ok      test    0.087s<br></code></pre></td></tr></table></figure></li></ul><p><strong>多个测试用例：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAbs_2</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>tests:=[]<span class="hljs-keyword">struct</span>&#123;<br>x <span class="hljs-type">int</span><br>want <span class="hljs-type">int</span><br>&#125;&#123;<br>&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">-2</span>,<span class="hljs-number">2</span>&#125;,<br>&#123;<span class="hljs-number">-3</span>,<span class="hljs-number">3</span>&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> _,v:=<span class="hljs-keyword">range</span> tests&#123;<br>got:=Abs(v.x)<br><span class="hljs-keyword">if</span> got!=v.want&#123;<br>t.Error(<span class="hljs-string">&quot;fault&quot;</span>)<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>t.Log(<span class="hljs-string">&quot;right&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中，我们定义了一个结构体，并且给定了入参和希望得到的值，最后用循环测试每个用例</p><h3 id="自动生成单元测试🐮："><a href="#自动生成单元测试🐮：" class="headerlink" title="自动生成单元测试🐮："></a>自动生成单元测试🐮：</h3><p>通过上面的样例我们可以得出个大概的结论：我们编写的单元测试就是，自己设定参数和预期结果值，接着调用函数来看能不能达到预期，逻辑并不复杂，复杂的反而是上面提到的那几个规范。</p><p>所以大牛已经做出工具来了，优秀的生成测试代码的工具：<code>gotests</code>。下面我们讲下他的使用方法：</p><p><strong>第一步：下载gotests包：</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> -<span class="hljs-keyword">u</span> github.<span class="hljs-keyword">com</span>/cweill/gotests/...<br></code></pre></td></tr></table></figure><p><strong>第二步：执行gotests命令：</strong></p><p>gotests命令执行格式为：<code>gotests [options] [PATH] [FILE] ...</code>。gotests可以为<code>PATH</code>下的所有Go源码文件中的函数生成测试代码，也可以只为某个<code>FILE</code>中的函数生成测试代码。</p><p>常用参数：<code>-all:</code>为当前目录下的所有函数生成测试代码。<code>-w：</code>将生成的测试代码生成到指定文件中，而不是命令行窗口。<code>-only:</code>指定要单独生成单元测试的函数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">gotests -only &quot;Abs&quot; -w .<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># -only用于指定选定的要生成单元测试的函数</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># “.” 表示生成在该目录下</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 如果我们没有创建相应的 _test.go文件那他就会自动生成，如果有就会往里继续添加，当然前提是我们没在那个文件中已经写了Test文件，不然就不会生成了。</span></span><br></code></pre></td></tr></table></figure><p><strong>第三步，添加测试用例：</strong></p><p>生成完测试用例，你只需要添加需要测试的输入和预期的输出就可以了。</p><p>上面的命令执行后会出现下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> Test<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAbs</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">type</span> args <span class="hljs-keyword">struct</span> &#123;<br>a <span class="hljs-type">int</span><br>&#125;<br>tests := []<span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>args args<br>want <span class="hljs-type">int</span><br>&#125;&#123;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Add test cases.</span><br>&#125;<br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;<br>t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">if</span> got := Abs(tt.args.a); got != tt.want &#123;<br>t.Errorf(<span class="hljs-string">&quot;Abs() = %v, want %v&quot;</span>, got, tt.want)<br>&#125;<br>&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们要完成的就是上面的TODO部分，也就是添加参数和预期结果。<code>name</code> 表示这组样例的备注，<code>args</code>表示函数的入参， <code>want</code>表示想要得到的结果。例如下面这样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAbs</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">type</span> args <span class="hljs-keyword">struct</span> &#123;<br>a <span class="hljs-type">int</span><br>&#125;<br>tests := []<span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>args args<br>want <span class="hljs-type">int</span><br>&#125;&#123;<br>&#123;<br>name: <span class="hljs-string">&quot;test one&quot;</span>,<br>args: args&#123;<br>a: <span class="hljs-number">1</span>,<br>&#125;,<br>want: <span class="hljs-number">1</span>,<br>&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;<br>t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">if</span> got := Abs(tt.args.a); got != tt.want &#123;<br>t.Errorf(<span class="hljs-string">&quot;Abs() = %v, want %v&quot;</span>, got, tt.want)<br>&#125;<br>&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="性能测试："><a href="#性能测试：" class="headerlink" title="性能测试："></a>性能测试：</h2><p>性能测试的函数Benchmark开头，函数参数必须是<code>*tesing.B</code>,函数内我们使用<code>b.N</code>来作为循环次数，N会在运行时动态调整，下面将是我们用Map和Sort包来判断元素的方法，和我们为其编写的性能测试函数。总结一句话，性能测试和上面的单元测试差不多，都是在_test.go文件中，只是函数名以Benchmark开头和用了<code>*testing.B</code>参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 两种判断Slice中元素是否存在的方法：</span><br><br><span class="hljs-keyword">package</span> Test<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;sort&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makemap</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-keyword">struct</span>&#123;&#125; &#123;<br>tempMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> arr &#123;<br>tempMap[v] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br><span class="hljs-keyword">return</span> tempMap<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Findbymap</span><span class="hljs-params">(tempMap <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-keyword">struct</span>&#123;&#125;, n <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> _, ok := tempMap[n]; ok &#123;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Findbysort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> &#123;<br>sort.Ints(arr)<br><span class="hljs-keyword">if</span> pos := sort.SearchInts(arr, n); pos != <span class="hljs-built_in">len</span>(arr) &#123;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//性能测试代码</span><br><br><span class="hljs-keyword">package</span> Test<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> arr = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>, <span class="hljs-number">66</span>, <span class="hljs-number">77</span>, <span class="hljs-number">88</span>, <span class="hljs-number">23</span>, <span class="hljs-number">34</span>, <span class="hljs-number">45</span>, <span class="hljs-number">56</span>, <span class="hljs-number">67</span>, <span class="hljs-number">78</span>, <span class="hljs-number">89</span>&#125;<br><span class="hljs-keyword">var</span> n = <span class="hljs-number">3</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkBymap</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>tempMap := makemap(arr)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>Findbymap(tempMap, n)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkBysort</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>Findbysort(arr, n)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">文件指定支持正则表达式</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">指定目录下的所有Benchmark函数如下：</span><br>go test -bench=&quot;.*&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">当然也可以指定特定函数</span><br>go test -bench=&quot;BenchmarkBymap&quot;<br><br></code></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">pengxj@PEngxJdeMacBook-Pro test % go test -bench=&quot;.*&quot;<br>goos: darwin<br>goarch: arm64<br>pkg: test<br>BenchmarkBymap-8        243986680                4.892 ns/op<br>BenchmarkBysort-8       11873071                99.28 ns/op<br>PASS<br>ok      test    3.068s<br></code></pre></td></tr></table></figure><p>结果得知，在要多次查询的情况下，构建一个map的效率是非常高的。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>代码测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单元测试与性能测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>⛽常见排序算法与实现📣</title>
    <link href="/2022/08/09/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/08/09/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>学习完数据结构与算法的课已经有很长时间了，排序算法忘的七七八八，好好复习一下吧</p><p>面对这道高频面试题，一定得好好理解下。包括了导航流程和TCP连接</p><span id="more"></span><h1 id="⛽常见排序算法与实现📣"><a href="#⛽常见排序算法与实现📣" class="headerlink" title="⛽常见排序算法与实现📣"></a>⛽常见排序算法与实现📣</h1><h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><p>排序算法可以分为两大类：<strong>比较类排序</strong>和<strong>非比较类排序</strong></p><p><strong>比较类排序：</strong>通过比较来决定元素间的相对次序，由于其时间复杂度无法突破O(nlog<del>2</del>n)，因此也称为非线性时间比较类排序。</p><p><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 </p><p>当前工业界和面试时考察的比较多的都是比较类排序，所以这次我们重点来学习下比较类排序中常见的两类排序：<strong>初级排序</strong>和<strong>高级排序</strong></p><p><img src="https://pic.rmb.bdstatic.com/bjh/839422a30a824720938d3e4a35f2f5d1.png" alt="常见排序的时间复杂度"></p><p><strong>初级排序：</strong>平均时间复杂度为O(n^2^)的排序，这些的重要性相对不高，多以了解为主。</p><p><strong>高级排序</strong>：平均时间复杂度为O(nlog<del>2</del>n)的排序，在公司面试和使用这方面主要就是这几个，优先级是最高的，我们一定要理解他们的原理并且自己能够实现这类排序算法。</p><h2 id="初级排序："><a href="#初级排序：" class="headerlink" title="初级排序："></a>初级排序：</h2><blockquote><p>我们主要熟悉下选择排序、插入排序、冒泡排序</p></blockquote><h3 id="选择排序："><a href="#选择排序：" class="headerlink" title="选择排序："></a>选择排序：</h3><blockquote><p>平均时间复杂度：O(n^2^)</p><p>最优时间复杂度：O(n^2^)  因为每次都要完整地遍历一次无序数组</p><p>最差时间复杂度：O(n^2^) 一样的，每次都是要完整地遍历一次无序数组</p><p>空间复杂度：O(1)  不用开辟新数组</p></blockquote><p>一句话理解：在乱序数组中遍历，找到最小元素，放到有序数组的最后面，如此反复最后就能得到有序数组。步骤就是每次都遍历一遍无序数组，找到最小元素，然后与无序数组的第一个元素交换（原理上是放到有序数组的下一个元素，其实也就是无序数组的第一个元素）</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h543464jifg20mj06w7l2.gif" alt="选择排序"></p><p><strong>代码实现（Go）：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arr)<span class="hljs-number">-1</span>; i++ &#123; <span class="hljs-comment">//每次遍历无序数组的第一个元素的位置</span><br>min := arr[i]<br>pos := i<br>        <span class="hljs-comment">//找到最小元素</span><br><span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(arr); j++ &#123;<br><span class="hljs-keyword">if</span> arr[j] &lt; min &#123;<br>min = arr[j]<br>pos = j<br>&#125;<br>&#125;<br>        <span class="hljs-comment">//与无序数组的第一个元素交换</span><br> arr[i],arr[pos]=arr[pos],arr[i]<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插入排序："><a href="#插入排序：" class="headerlink" title="插入排序："></a>插入排序：</h3><blockquote><p>平均时间复杂度：O(n^2^)</p><p>最优时间复杂度：O(n)  数组为本身有序的情况</p><p>最差时间复杂度：O(n^2^) 逆序的情况，每次都要一次与前面有序数组完整的比较</p><p>空间复杂度：O(1)  不用开辟新数组</p></blockquote><p>一句话理解：将乱序数组中的元素插入到有序数组中。步骤是每次选取无序数组的第一个元素从有序数组的最后一个元素开始一一判断，找到位置后，腾出插入位置后插入。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5436dwi6zg20mj0e113f.gif" alt="插入排序"></p><p><strong>代码实现（Go）：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span>&#123;<br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(arr);i++&#123;  <span class="hljs-comment">// 这里每次的i为乱序数组的第一个元素的下标</span><br><span class="hljs-keyword">var</span>(<br>j <span class="hljs-type">int</span><br>temp=arr[i]  <span class="hljs-comment">//后面要移动元素腾出插入的空间，所以要先保存下来</span><br>)<br><span class="hljs-comment">//查找插入位置</span><br><span class="hljs-keyword">for</span> j=i<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--&#123;   <span class="hljs-comment">// 这里的j是每次的有序数组的最后一个元素的下标</span><br><span class="hljs-keyword">if</span> arr[i]&lt;arr[j]&#123; <br><span class="hljs-keyword">continue</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">break</span>  <span class="hljs-comment">//j+1就是要插入的位置了</span><br>&#125;<br>&#125;<br><span class="hljs-comment">//移动位置，腾出插入空间</span><br><span class="hljs-keyword">for</span> ;i&gt;j+<span class="hljs-number">1</span>;i--&#123;<br>arr[i]=arr[i<span class="hljs-number">-1</span>]<br>&#125;<br>arr[j+<span class="hljs-number">1</span>]=temp<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="冒泡排序："><a href="#冒泡排序：" class="headerlink" title="冒泡排序："></a>冒泡排序：</h3><blockquote><p>平均时间复杂度：O(n^2^)</p><p>最优时间复杂度：O(n^2^)  数组为本身有序的情况</p><p>最差时间复杂度：数组为逆序的状态</p><p>空间复杂度：O(1)  不用开辟新数组</p></blockquote><p>一句话理解：每进行一次整个数组（除去浮出水面的）两两交换，就一定会有至少一个当前剩余数组中的最大元素会浮出水面。步骤就是在无序中，不断重复的进行一趟两两比较交换，每次会浮出一个至多个元素，随着浮出元素的增多，每次比较的次数也相应减少。</p><p><strong>代码实现（Go）：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span>&#123;<br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(arr);i++&#123;<br><span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;<span class="hljs-built_in">len</span>(arr)-i;j++&#123;<br><span class="hljs-keyword">if</span> arr[j]&lt;arr[j<span class="hljs-number">-1</span>]&#123;<br>arr[j<span class="hljs-number">-1</span>],arr[j]=arr[j],arr[j<span class="hljs-number">-1</span>]<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高级排序："><a href="#高级排序：" class="headerlink" title="高级排序："></a>高级排序：</h2><h3 id="快速排序："><a href="#快速排序：" class="headerlink" title="快速排序："></a>快速排序：</h3><blockquote><p>平均时间复杂度：O(nlog<del>2</del>n)</p><p>最优时间复杂度：O(nlog<del>2</del>n)  选取的pivot可以，每次都能把数组分成等份的两份</p><p>最差时间复杂度：O(n^2^)选取的pivot不行，分出的数组的元素数量严重不均等</p><p>空间复杂度：O(1)  不用开辟新数组</p></blockquote><p>一句话理解，运用了分治的思想，每次我们都选取一个pivot，将原数组分成左半边数组和右半边数组，左子数组都小于pivot，右子数组都大于pivot，再递归处理这两个左右子数组。步骤就是，我们这里是为了方便选用了数组的最后一个元素为pivot，真实应用场景下可能会根据数据的大致情况选择相应的pivot来提高效率，counter的值理解为经过分类后小于pivot的左子数组的最后一个元素位置加1，所以我们遍历过程中遇到比pivot小的元素就都和counter交换，扩充左子数组，遍历完成后，counter位置始终代表左子数组的下一个位置，所以最后pivot直接与counter交换位置，即能得到分好类的左右子数组。再递归处理左右子数组。</p><p>再记一下自己疑惑的点（不知道为啥疑惑😓）</p><p><strong>剩下两个的情况是怎么结束的？</strong></p><ol><li><p>倒序的情况，按照惯例，pivot设为第二个元素，遍历完比它小的左子数组的下一位即为第一个元素的位置（没有比它小的元素，counter没变），交换后就正序了，进入下面的情况。</p></li><li><p>正序的情况，按照惯例，pivot设为第二个元素，遍历后只有一个元素比它小，比它小的左子数组的下一位即为第二个元素的位置，这时我们再递归处理这两个子数组，我们先看右子数组，我们的左边界会设为counter+1，有边界还是high没有变，而此时counter+1已经大于high了，所以就结束了，我们再看左子数组，此时就是剩余一个元素的情况了。</p></li><li><p>剩余一个元素的情况：判断后low等于high，结束</p></li></ol><p><strong>复杂度为什么O(nlog<del>2</del>n)：</strong>首先是前面的n，前面的n代表是每一层在做<code>partition</code>的时候都要处理“n”次，log<del>2</del>n代表调用栈有多高，最坏情况，调用栈的高度就为n，所以复杂度为O(n^2^)。</p><p><strong>代码实现（Go）：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>,low <span class="hljs-type">int</span>,high <span class="hljs-type">int</span>)</span></span>&#123;<br><span class="hljs-keyword">if</span> low&gt;=high&#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(arr[low:high+<span class="hljs-number">1</span>])<br>pivot:=partition(arr,low,high)<br>quicksort(arr,low,pivot<span class="hljs-number">-1</span>)<br>quicksort(arr,pivot+<span class="hljs-number">1</span>,high)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partition</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>,begin,end <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>&#123;<br>pivot,counter:=arr[end],begin<br><span class="hljs-keyword">for</span> i:=begin;i&lt;end;i++&#123;<br><span class="hljs-keyword">if</span> arr[i]&lt;pivot&#123;<br>fmt.Println(arr[i],arr[counter])<br>arr[i],arr[counter]=arr[counter],arr[i]<br>counter++<br>&#125;<br>&#125;<br>arr[counter],arr[end]=arr[end],arr[counter]<br><span class="hljs-keyword">return</span> counter<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="归并排序："><a href="#归并排序：" class="headerlink" title="归并排序："></a>归并排序：</h3><blockquote><p>平均时间复杂度：O(nlog<del>2</del>n)</p><p>最优时间复杂度：O(nlog<del>2</del>n)  归并排序每次都要分到最小，再合并，所以变化不大</p><p>最差时间复杂度：同上</p><p>空间复杂度：O(n)  需要开辟新数组</p></blockquote><p>一句话理解，先切割成n个子序列，最小为1，然后再合并子序列（归并），在合并的过程中会使这两个子序列合并成整体有序的子序列，不断将整体有序的子序列合并，并且合并过程夹有排序，最终就能得到有序的序列。步骤就是，可以理解为一个后序遍历，先把数组一直切分，“在根结点”合并，把左右子树中整体有序的子序列合并就能最终得到整体有序的序列</p><p><strong>复杂度为什么O(nlog<del>2</del>n)：</strong>先说后面的log<del>2</del>n，归并的调用栈就固定为log<del>2</del>n了，不会像快排那样有变化，而前面的n代表着就是在每一层合并的时候都要处理“n”次。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h543b37d25g20mj0e1qcv.gif" alt="归并排序"></p><p><strong>代码实现（Go）：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, low, high <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> low &gt;= high &#123;  大于的情况是越界了，等于的情况是不用再分了<br><span class="hljs-keyword">return</span><br>&#125;<br>mid := (low + high) &gt;&gt; <span class="hljs-number">1</span><br>fmt.Println(mid)<br>MergeSort(arr, low, mid)<br>MergeSort(arr, mid+<span class="hljs-number">1</span>, high)<br>Merge(arr, low, high, mid)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Merge</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, low, high, mid <span class="hljs-type">int</span>)</span></span> &#123;<br>left, right := low, mid+<span class="hljs-number">1</span><br>TempArr := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, high-low+<span class="hljs-number">1</span>)<br>k := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> left &lt;= mid &amp;&amp; right &lt;= high &#123;<br><span class="hljs-keyword">if</span> arr[left] &lt; arr[right] &#123;<br>TempArr[k] = arr[left]<br>k++<br>left++<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>TempArr[k] = arr[right]<br>k++<br>right++<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> left &lt;= mid &#123;<br>TempArr[k] = arr[left]<br>k++<br>left++<br>&#125;<br><span class="hljs-keyword">for</span> right &lt;= high &#123;<br>TempArr[k] = arr[right]<br>k++<br>right++<br>&#125;<br><span class="hljs-built_in">copy</span>(arr[low:high+<span class="hljs-number">1</span>], TempArr)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆排序："><a href="#堆排序：" class="headerlink" title="堆排序："></a>堆排序：</h3><blockquote><p>平均时间复杂度：O(nlog<del>2</del>n)</p><p>最优时间复杂度：O(nlog<del>2</del>n)  堆排序时间主要在维护堆上，和数组情况无关</p><p>最差时间复杂度：同上</p><p>空间复杂度：O(n)  需要开辟新数组</p></blockquote><p>一句话理解：用序列先维护一个堆(nlog<del>2</del>n)，再用堆弹出堆顶元素到新的数组中，完成排序。堆的维护我们常用语言自带的方法来实现，以Go为例就是实现接口的方法，它的底层实现里面默认弹出时使用的方法是堆顶与最后一个元素交换，弹出最后一个元素，再进行堆的维护，所以我们自己要实现的pop方法就是要弹出最后一个元素，Push方法也一样，默认放在最后一个元素，再进行堆的维护</p><p><strong>复杂度为什么O(nlog<del>2</del>n)：</strong>在维护堆时，堆的特性每次的插入和删除都需要log<del>2</del>n，而要插入n个元素，所以为O(nlog<del>2</del>n)</p><p><strong>代码实现（Go）：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myHeap []<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(heap *myHeap)</span></span>Len()<span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span>(<span class="hljs-built_in">len</span>(*heap))&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(heap *myHeap)</span></span>Less(i,j <span class="hljs-type">int</span>)<span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> (*heap)[i]&lt;(*heap)[j] &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(heap *myHeap)</span></span>Swap(i,j <span class="hljs-type">int</span>) &#123;(*heap)[i],(*heap)[j]=(*heap)[j],(*heap)[i]&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(heap *myHeap)</span></span>Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;*heap=<span class="hljs-built_in">append</span>(*heap,x.(<span class="hljs-type">int</span>))&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(heap *myHeap)</span></span>Pop()<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br><span class="hljs-keyword">var</span> x=(*heap)[<span class="hljs-built_in">len</span>(*heap)<span class="hljs-number">-1</span>] <br>*heap=(*heap)[<span class="hljs-number">0</span>:<span class="hljs-built_in">len</span>(*heap)<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>myheap:=&amp;myHeap&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>&#125;<br>a:=<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(*myheap))<br>heap.Init(myheap)<br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(a);i++&#123;<br>a[i]=heap.Pop(myheap).(<span class="hljs-type">int</span>)<br>&#125;<br>fmt.Println(a)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速排序与归并排序的比较："><a href="#快速排序与归并排序的比较：" class="headerlink" title="快速排序与归并排序的比较："></a>快速排序与归并排序的比较：</h3><p>快速排序和归并排序的平均时间复杂度都是O(nlog<del>2</del>n)，而快速排序的最坏情况是O(n^2^)，但快排还是优于归并，快排优于归并的地方在哪？</p><ol><li><p>快速排序中效率的主要来源之一是引用位置，在引用位置中，计算机硬件经过优化，因此访问彼此相邻的内存位置往往比访问分散在整个内存中的内存位置更快。quicksort中的分区步骤通常具有很好的局部性，因为它访问前面和后面附近的连续数组元素。因此，快速排序往往比其他排序算法（如heapsort）执行得更好，尽管它通常执行大致相同数量的比较和交换，因为在heapsort的情况下，访问更加分散。</p><p>也就是说，一个原因是计算机硬件经过优化，访问彼此相邻的内存位置往往比访问分散在整个内存中的内存位置更快，所以快速排序我们在划分数组的时候，元素都是相邻的，而归并排序在合并的时候是元素较为分散，所以在这一点上快排优于归并</p></li><li><p>另一个普遍都知道的原因就是快排我们可以直接在原数组上操作，而归并排序我们在合并的时候需要重新开辟数组（空间复杂度为O(n)），还要进行多次的赋值的操作，所以在这一点上让快排优于归并。</p></li></ol><p><strong>和堆排序的相比：</strong>在维护堆的时候，堆排里面有大量近乎无效的比较，因为被拿到堆顶的那个元素几乎肯定是很小的，而靠近堆顶的元素又几乎肯定是很大的，将一个很小的数和一个很大的数比较，结果几乎肯定是“小于”的，这就意味着问题的可能性只被排除掉了很小一部分。</p><p>所以堆排虽然和快排一样复杂度都是O(nlog<del>2</del>n)但堆排复杂度的常系数更大</p>]]></content>
    
    
    <categories>
      
      <category>站在巨人的肩膀上</category>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>🤯从输入URL到页面展示，这中间发生了什么？🤬</title>
    <link href="/2022/08/07/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%EF%BC%8C%E8%BF%99%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <url>/2022/08/07/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%EF%BC%8C%E8%BF%99%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<p>面对这道高频面试题，一定得好好理解下。包括了导航流程和TCP连接</p><span id="more"></span><h1 id="从输入URL到页面展示，这中间发生了什么？"><a href="#从输入URL到页面展示，这中间发生了什么？" class="headerlink" title="从输入URL到页面展示，这中间发生了什么？"></a>从输入URL到页面展示，这中间发生了什么？</h1><p><img src="https://static001.geekbang.org/resource/image/71/e3/714208d4e10499868688361130d1d2e3.jpg"></p><h2 id="三个进程："><a href="#三个进程：" class="headerlink" title="三个进程："></a>三个进程：</h2><p><strong>浏览器进程：</strong>主要负责用户的交互、子进程的控制和文件存储的服务</p><p><strong>网络进程</strong>：主要负责为浏览器进程和渲染进程提供下载功能</p><p><strong>渲染进程：</strong>对接受的javascript，css，html、图片等资源解析成可以显示和交互的界面</p><h2 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h2><ol><li>用户输入URL回车后，浏览器进程先判断输入的内容是否为搜索内容，是的话就会根据浏览器的默认搜索引擎，组成新的带有搜索内容的URL。如果输入的内容符合URL规则，那就会选用相应的协议，一般现在的网站都是HTTPS，组成新的URL。</li><li>浏览器进程会通过进程间通信（IPC），向网络进程发送URL请求，由网络进程真正进行URL请求。</li><li>获得URL后，网络进程不是直接就开始请求的步骤，而是先查找本地缓存是否缓存了该资源。如果有找到缓存资源则结束请求，直接把资源返回给浏览器进程。没有再进行接下来的步骤。</li><li>URL请求第一步是找目标服务器的地址和端口号，也就是域名解析，首先会在本地的域名解析缓存中查找是否有该域名的缓存记录，有则会直接使用该地址和端口号，本地缓存没有再会向DNS服务器发送请求，获得服务器地址和端口号。如果获取到的只有IP地址，则会使用默认的端口号，HTTP默认是80而HTTPS默认的是HTTPS。如果是HTTPS协议，这里还有一个步骤：建立TLS连接。</li><li>接下来就是使用IP地址与服务器进行TCP连接</li></ol><h3 id="TCP连接："><a href="#TCP连接：" class="headerlink" title="TCP连接："></a>TCP连接：</h3><p><img src="https://pic.rmb.bdstatic.com/bjh/d5169b6fc8b3fad501c31afb19f037ff.jpeg" alt="TCP结构"></p><h4 id="😊三次握手："><a href="#😊三次握手：" class="headerlink" title="😊三次握手："></a>😊三次握手：</h4><p><strong>第一次握手：</strong> 此次过程为TCP客户端发送一个TCP报文段，里面将首部的同步位SYN设为1，表明该报文段为连接请求报文段，并为序号字段（seq）设置一个值x，（这个序号会给消耗掉，即接下来的报文段要用x+1，因为TCP规定SYN设置为1后不可携带数据，但会消耗掉一个序号）作为TCP客户端所选择的初始序号，并进入同步已发送阶段。</p><p><strong>第二次握手：</strong>TCP服务器端接受到客户端发来请求连接报文段后，如果同意连接，会往客户端再发送一个TCP报文段，里面将首部的同步位SYN和确认为ACK都设为1，表明该报文段为连接请求确认报文段，并为序号字段（seq）设置一个值y，作为TCP服务器进程所选择的初始序号，确认号字段设为x+1，这是对TCP客户端所选择的初始序号的确认。同时进入同步己接受阶段</p><p><strong>第三次握手：</strong>TCP客户端接受到请求连接确认报文段后，会往服务器端再发送一次TCP报文段，里面将确认位ACK设为1，表明这是一个普通的TCP确认报文段，并将序号设置为x+1（TCP规定普通的确认报文段可以携带数据，如果这次报文段中有携带数据那这个序号将会给消耗掉，如果没有携带，那么下一次发送TCP请求时则还可以继续用这个x+1），确认号设置为y+1,这是对服务器的初始序号的确认。发送完成后，客户端进入连接已建立状态，服务器接收到确认报文段后也进入连接已建立状态。</p><p><strong>为什么要三次，两次不行吗？</strong></p><p>这是因为TCP为了保证连接的可靠性，始终认为网络层是不可靠的，如果是两次握手那TCP服务器端在发送完TCP请求连接确认报文段后就会进入连接已建立状态，这里就存在一种可能，在服务器端接收到请求连接报文段前，因为网络问题，客户端一直没接受到请求连接确认报文段已经发送了好几个请求连接报文段，而等到TCP服务器端接受到TCP请求连接报文段，TCP客户端接受到请求连接报文段，并完成了数据传输，四次挥手断开连接后，之前那些没能到达服务器端的TCP请求连接报文段又姗姗来迟到达了服务器端，这是我们如果我们采用的两次握手，服务器端就会进入连接已建立状态，而因为客户端已经认为这次连接已经完成了，那这个状态就会一直尬等着，没人传数据也没人告诉他断开，这样就导致占用了服务器端许多的资源。</p><h4 id="🤗四次挥手："><a href="#🤗四次挥手：" class="headerlink" title="🤗四次挥手："></a>🤗四次挥手：</h4><p>客户端和服务器端都可以发起断开连接，这里以客户端为例</p><p><strong>第一次挥手：</strong>此时客户端会发送一个TCP报文段，里面将终止位FIN和确认位ACK设置为1，表明该报文段为请求释放报文段，并将序号设置为u（u等于最后一次客户端发送到服务器端的数据的最后一个字节的序号加1，并且TCP规定即使该请求释放报文段不携带数据也会消耗一个序号），确认号设置为v(v等于客户端之前接受到的数据的最后一个字节的序号+1)，同时进入终止等待1状态</p><p><strong>第二次挥手：</strong>服务器端接受到连接释放字段后，再发送一个TCP报文段，里面将ACK设为1，表明该报文段为普通确认报文段，并将序号设置为v（与上面的v相等）确认号设置为u+1，并进入关闭等待状态。这时服务器端会通知应用层TCP客户端要断开与服务器端的连接，此时客户端到服务器端的这个方向的连接就释放了（由全双工变为半双工，客户端可以继续接受数据，但不可以发送数据了，这里别错误理解为不能发送任何东西了，只是不能依赖建立的通道可靠的发送数据，但是还是可以发送TCP报文段的），客户端接受到普通确认报文段后进入终止等待2状态。</p><p><strong>第三次挥手：</strong>等到应用层进程发送完数据后，它就会通知TCP服务器段进程关闭TCP连接，TCP服务端会再向客户端发送一个TCP报文段，里面将终止位FIN和确认位设置为1，表明该报文段为连接释放报文段，并将序号设置为w(w等于后来服务器端往客户端发送的剩余的数据的最后一个字节的序号+1)，确认号设置为u+1(对一次挥手的报文段的再次确认)，同时进入最后确认状态。</p><p><strong>第四次挥手：</strong>客户端收到连接释放字段后，再向服务器端发送一个TCP报文段，里面将确认位ACK设为1,表明该报文段为普通确认报文段，并将序号设置为u+1，确认号设为w+1，服务器端接受到该确认报文段后进入关闭状态，而客户端进入时间等待状态，只有等2MSL（Maximum Segment Lifetime，最长报文寿命）后进入关闭状态。</p><p><strong>为什么要等待：</strong>还是一样，TCP始终认为网络层是不可靠的，第四次挥手发送的TCP报文段可能因为某种原因未能到达服务器端，而服务器端没接受到客户端的确认报文字段就会发起超时重传连接释放字段，而这时客户端已经关闭了，服务器端不可能再接受到确认报文字段，会一直进行超时重传，一直处于最后确认状态，而无法进入关闭状态。而且经过了这个2MSL时间，就可以使本次连接的所有字段都消失，保证下一次连接不会收到旧的字段。</p><ol start="6"><li>TCP连接建立后，浏览器就会构建请求行和请求头等信息，并把和该域名相关的Cookie等数据附加到请求头中，然后向服务器发送构建好的请求信息。</li><li>服务器接受到消息后，就根据请求信息生成响应信息（包括响应行，响应头和响应体等信息），并发送回客户端。</li><li>网络进程接受到响应信息后就开始解析响应头信息，首先是判断状态码是否3xx，是否为重定向，如果是的话就读取响应头的Location字段中的地址信息，然后再发起HTTP或HTTPS请求，一切由从头开始了。</li><li>处理了跳转信息后，接下来就是处理响应数据类型，URL请求有时可能请求的是一个下载类型，也可能是一个正常的HTML界面，这时浏览器就会根据响应头中的Content-Type来处理请求，如果Content-Type为下载类型那就将它交给浏览器的下载管理器，而该URL的导航到此就结束了。但如果是HTML，那就会继续下面的导航流程。接下来就是通知浏览器进程开始<strong>准备渲染</strong>。</li><li>浏览器进程收到通知后，Chrome的方案是如果当前浏览器下已经有同一站点（同一域名，同一协议）的渲染进程，那就会复用其渲染进程，否则则是创建一个新的渲染进程，渲染进程准备好之后还不能进入文档解析阶段，因为此时的文档数据还在网络进程中，并没有提交给渲染进程。</li><li>提交文档阶段，提交响应信息中的响应体部分，<strong>提交文档</strong>的命令由浏览器进程发出，渲染进程接收到通知后，会和网络进程建立传输数据的“管道”，等到文档全部提交后，渲染进程会给浏览器进程发送<strong>确认提交</strong>的信息。</li><li>浏览器接受到<strong>确认提交</strong>的消息后，就会<strong>更新浏览器界面状态</strong>，包括了安全状态，地址栏的URL、前进后退的历史状态，并更新web界面。</li><li>之后就是渲染进程了，一旦渲染进程结束，就会往浏览器进程发送信息，收到信息后，浏览器就会停止标签图标上加载动画</li></ol>]]></content>
    
    
    <categories>
      
      <category>站在巨人的肩膀上</category>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>😃搞定Docker--进阶使用</title>
    <link href="/2022/07/30/%E6%90%9E%E5%AE%9ADocker--%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/30/%E6%90%9E%E5%AE%9ADocker--%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="😃搞定Docker–进阶使用"><a href="#😃搞定Docker–进阶使用" class="headerlink" title="😃搞定Docker–进阶使用"></a>😃搞定Docker–进阶使用</h1><p>在快速入门学习完后，我们开始来学习些真实工作场景下，需要了解学习的技术。</p><span id="more"></span><p>在快速入门那一节我们使用的镜像都是从公共的docker仓库拉取的，而对于一些真实使用的场景，我们常常需要将整个项目的环境都配置到一个镜像中，给使用者一个开箱即用的体验。这里就需要镜像构建的技术。通常有以下两种方式：</p><ul><li><code>docker commit</code>：从已有容器创建一个新的镜像。</li><li><code>docker build</code>：配合 Dockerfile 文件创建镜像。</li></ul><h2 id="Commit命令创建镜像："><a href="#Commit命令创建镜像：" class="headerlink" title="Commit命令创建镜像："></a>Commit命令创建镜像：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker commit [OPTIONS] 容器名 [创建后的镜像名[:TAG]]<br></code></pre></td></tr></table></figure><p> <strong>参数说明：</strong></p><ul><li><strong>-a</strong>：镜像作者</li><li><strong>-m</strong>：提交时的说明</li><li><strong>-p</strong>：在容器commit时，将容器暂停</li><li>TAG虽然是可选，但强烈建议还是加上比较好</li></ul><h3 id="一个栗子💭"><a href="#一个栗子💭" class="headerlink" title="一个栗子💭"></a>一个栗子💭</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.先拉取一个镜像<br>docker pull centos:7<br>2.创建一个容器<br>docker run -di --name centos centos:7<br>3.进入容器<br>docker <span class="hljs-built_in">exec</span> -it centos bash<br>4.配置Go环境，和mysql到里面（docker <span class="hljs-built_in">cp</span> 拷贝、解压）<br>5.创建镜像<br>docker commit -a <span class="hljs-string">&quot;PEngxJ&quot;</span> -m <span class="hljs-string">&quot;Go and mysql&quot;</span> centos mycentos:7<br>6.根据自己的镜像创建容器<br>docker run -di --name mycentos mycentos:7 <br><br></code></pre></td></tr></table></figure><h2 id="Dockerfile方式："><a href="#Dockerfile方式：" class="headerlink" title="Dockerfile方式："></a>Dockerfile方式：</h2><blockquote><p>总体来说就是把上面一个个的步骤写到一个Dockerfile文件中，然后运行这个文件，它就会自动帮我们完成所有步骤，然后创建相应的容器。</p></blockquote><p>在使用该方式前，我们得先学一学Dockerfile的常用命令</p><h3 id="FROM："><a href="#FROM：" class="headerlink" title="FROM："></a>FROM：</h3><p><strong>指定该镜像是基于哪个镜像构建的</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">eg:<br>FROM centos:7<br></code></pre></td></tr></table></figure><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN:"></a>RUN:</h3><p><strong>执行后面跟着的命令行命令</strong>,有以下两种格式：</p><p>shell格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> &lt;命令行命令&gt;</span><br><span class="hljs-comment">#&lt;命令行命令&gt;和在终端上的命令一样</span><br>eg:<br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;RUN&#x27;</span> &gt; /usr/local/run.text</span><br></code></pre></td></tr></table></figure><p>exec格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">&quot;可执行文件&quot;</span>,<span class="hljs-string">&quot;参数1&quot;</span>,<span class="hljs-string">&quot;参数2&quot;</span>]</span><br>eg：<br><span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">&quot;./main.go&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>]</span><br><span class="hljs-comment">#相当于 RUN ./main.go hello world</span><br></code></pre></td></tr></table></figure><p>**注意:**Dockerfile的指令每执行一次都会在docker上新建一层（之前镜像分层的概念），所以过多无意义的层必会导致生成的镜像的膨胀。所以常采用以下方式：</p><p>不用：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos<br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y install wget</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> wget -O redis.tar.gz <span class="hljs-string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span></span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> tar -xvf redis.tar.gz</span><br></code></pre></td></tr></table></figure><p>而用：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos<br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y install wget \</span><br><span class="language-bash">    &amp;&amp; wget -O redis.tar.gz <span class="hljs-string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span><br><span class="language-bash">    &amp;&amp; tar -xvf redis.tar.gz</span><br></code></pre></td></tr></table></figure><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY:"></a>COPY:</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> [--<span class="hljs-built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;...  &lt;目标路径&gt;</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> [--<span class="hljs-built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [<span class="hljs-string">&quot;&lt;源路径1&gt;&quot;</span>,...  <span class="hljs-string">&quot;&lt;目标路径&gt;&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>[–chown&#x3D;&lt;user&gt;:&lt;group&gt;]：可选参数，用户改变复制到容器内文件的拥有者和属组</p><p>**&lt;源路径&gt;**：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> hom* /mydir/</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> hom?.txt /mydir/</span><br></code></pre></td></tr></table></figure><p>**&lt;目标路径&gt;**：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。</p><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD:"></a>ADD:</h3><p>ADD 指令和 COPY 的使用格类似（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下：</p><p>区别：ADD命令，如果复制的内容是压缩包的话，则它会自动解压，当然这样也带来一个不好的地方就是它不能用来复制压缩包</p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD:"></a>CMD:</h3><p>和RUN一样用与执行命令，不过他们各自的执行时间不同。RUN在<code>docker build</code>的时候执行，而CMD是在<code>docker run</code>时执行的。</p><p>介于这点它常用于为启动的容器指定默认的启动程序，如果想让容器一直运行着那就必须得让这个程序在<strong>前台运行</strong>，不然根据docker的规则当命令运行结束后docker就退出了。</p><p><strong>注意：</strong></p><ol><li>CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</li></ol><p>eg：<code>docker run --name nginx -P nginx echo &#39;hello&#39;</code>如果是这样的话，那就会使Dockerfile中CMD的失效。</p><ol start="2"><li>如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。</li></ol><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="language-bash"> &lt;shell 命令&gt; </span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;可执行文件或命令&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...] </span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...]  <span class="hljs-comment"># 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</span></span><br></code></pre></td></tr></table></figure><p>推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。</p><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT:"></a>ENTRYPOINT:</h3><p>和上面CMD类型，在<code>docker run</code>时执行命令，但不同的是它不会被<code>docker run</code>跟着的参数中的命令所覆盖，而是把这些“命令”做为参数给ENTRYPOINT设置的命令使用。</p><p>当然, 如果运行 docker run 时使用了 –entrypoint 选项，将覆盖 ENTRYPOINT 指令指定的程序。</p><p><strong>优点</strong>：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。（ENTRYPOINT设置定参后，后面我们可以在docker run时自己指定变参，可以看后面例子）</p><p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;executeable&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...]</span><br></code></pre></td></tr></table></figure><p>示例：</p><p>假设已通过 Dockerfile 构建了 nginx:test 镜像：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> nginx<br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;nginx&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>] <span class="hljs-comment"># 定参</span></span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/etc/nginx/nginx.conf&quot;</span>] <span class="hljs-comment"># 变参 </span></span><br></code></pre></td></tr></table></figure><p>1、不传参运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run  nginx:<span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><p>容器内会默认运行以下命令，启动主进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx -c /etc/nginx/nginx.conf<br></code></pre></td></tr></table></figure><p>2、传参运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run nginx:<span class="hljs-built_in">test</span> <span class="hljs-string">&quot;/etc/nginx/new.conf&quot;</span></span><br></code></pre></td></tr></table></figure><p>容器内执行以下命令，启动主进程(&#x2F;etc&#x2F;nginx&#x2F;new.conf:假设容器内已有此文件)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx -c /etc/nginx/new.conf<br></code></pre></td></tr></table></figure><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV:"></a>ENV:</h3><p>设置环境变量</p><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> &lt;key&gt; &lt;value&gt;<br><span class="hljs-keyword">ENV</span> &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...<br></code></pre></td></tr></table></figure><h3 id="LABLE"><a href="#LABLE" class="headerlink" title="LABLE:"></a>LABLE:</h3><p>LABEL 指令用来给镜像添加一些元数据（metadata），以键值对的形式，语法格式如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">LABEL</span><span class="language-bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span><br></code></pre></td></tr></table></figure><p>eg:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">LABEL</span><span class="language-bash"> image.authors=<span class="hljs-string">&quot;runoob&quot;</span></span><br></code></pre></td></tr></table></figure><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE:"></a>EXPOSE:</h3><p>仅仅是声明端口并不会打开</p><p>作用：</p><ul><li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。（在docker run时 -p）</li><li>在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</li></ul><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">EXPOSE</span> &lt;端口<span class="hljs-number">1</span>&gt; [&lt;端口<span class="hljs-number">2</span>&gt;...]<br></code></pre></td></tr></table></figure><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR:"></a>WORKDIR:</h3><p>指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。如果不存在，docker会自动创建。</p><p>作用：</p><p>WORKDIR指令为Dockerfile中在其下面的任何RUN、CMD、ENTRYPOINT、COPY和ADD指令设置工作目录。</p><p><strong>怎么理解工作目录：</strong></p><p>在上面的RUN我们说过，每次的RUN都会在docker上新建一层，所以就会导致后面的命令不知道前面的命令的情况。举个例子：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">cd</span> /app</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello&quot;</span> &gt; world.txt</span><br></code></pre></td></tr></table></figure><p>这里我们构键完后会发现在目录&#x2F;app下找不到world.txt，而会在一个其它的地方找到这个东西，这就是上面所说的，因为下一个<code>RUN</code>根本不会在<code>/app</code>目录下。</p><p>这里我们就要用到<strong>WORKDIR</strong>了：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello&quot;</span> &gt; world.txt</span><br></code></pre></td></tr></table></figure><p>如果你的 <code>WORKDIR</code> 指令使用的相对路径，那么所切换的路径与之前的 <code>WORKDIR</code> 有关：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /a</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> b</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> c</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">pwd</span></span><br></code></pre></td></tr></table></figure><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME:"></a>VOLUME:</h3><p>定义&#x3D;&#x3D;匿名&#x3D;&#x3D;数据卷</p><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">VOLUME</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;容器路径1&gt;&quot;</span>, <span class="hljs-string">&quot;&lt;容器路径2&gt;&quot;</span>...]</span><br><span class="hljs-keyword">VOLUME</span><span class="language-bash"> &lt;容器路径&gt;</span><br></code></pre></td></tr></table></figure><p>不过我们一般通过在<code>docker run</code>时添加<code>-v</code>参数来指定挂载目录</p><h3 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build:"></a>docker build:</h3><p>常用的参数：</p><ul><li><code>-t</code>：镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</li><li><code>-f</code>：指定要使用的Dockerfile路径；</li></ul><h3 id="一个栗子🤖："><a href="#一个栗子🤖：" class="headerlink" title="一个栗子🤖："></a>一个栗子🤖：</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos:<span class="hljs-number">7</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> go1.18.4.linux-amd64.tar.gz /usr/local/go</span><br>&amp;&amp; Goweb /usr/home/<br><span class="hljs-keyword">ENV</span> PATH=$PATH:/usr/local/go/bin <br><span class="hljs-keyword">LABEL</span><span class="language-bash"> author=<span class="hljs-string">&quot;PEngxJ&quot;</span></span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /usr/home/</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> go run /usr/home/Goweb/main.go</span><br></code></pre></td></tr></table></figure><h2 id="镜像迁移："><a href="#镜像迁移：" class="headerlink" title="镜像迁移："></a>镜像迁移：</h2><h3 id="备份与恢复的方式："><a href="#备份与恢复的方式：" class="headerlink" title="备份与恢复的方式："></a>备份与恢复的方式：</h3><p><strong>备份：</strong></p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker save <span class="hljs-selector-attr">[OPTIONS]</span> IMAGE <span class="hljs-selector-attr">[IMAGE...]</span><br></code></pre></td></tr></table></figure><ul><li>-o :输出到的文件</li></ul><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker save -o myubuntu.tar ubuntu:v3<br></code></pre></td></tr></table></figure><p><strong>恢复：</strong></p><p>语法:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">docker <span class="hljs-keyword">load</span> [<span class="hljs-keyword">OPTIONS</span>]<br></code></pre></td></tr></table></figure><ul><li>-i : 指定导入的文件，代替 STDIN。</li><li>-q : 精简输出信息。</li></ul><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker load -i myubuntu.tar<br></code></pre></td></tr></table></figure><h3 id="上传至私人与共有的方式："><a href="#上传至私人与共有的方式：" class="headerlink" title="上传至私人与共有的方式："></a>上传至私人与共有的方式：</h3><p>得先注册一个在dockerhub上的号。然后使用<code>docker login</code>登录，<code>docker logout</code>退出。</p><h4 id="公共仓库："><a href="#公共仓库：" class="headerlink" title="公共仓库："></a>公共仓库：</h4><p><strong>上传：</strong></p><ol><li><p>docker tag : 标记本地镜像。</p><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker tag IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> tag hello-world:latest peng7066/test-hello-world:<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li><li><p>docker push：上传镜像。</p><p>语法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker push NAME[:TAG]<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> push peng7066/test-hello-world:<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li></ol><p><strong>拉取：</strong></p><ol><li>docker pull：拉取镜像</li></ol><h4 id="私有仓库："><a href="#私有仓库：" class="headerlink" title="私有仓库："></a>私有仓库：</h4><p><strong>配置私有仓库认证：</strong></p><ol><li><p>生成自签名证书：</p><ol><li><p>创建证书目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p /usr/local/registry/certs<br></code></pre></td></tr></table></figure></li><li><p>生成自签名证书命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl req -newkey rsa:2048 -nodes -sha256 -keyout /usr/local/registry/domain.key -x509 -days 365 -out /usr/local/registry/certs/domain.crt<br></code></pre></td></tr></table></figure><ul><li><code>openssl req</code>：创建证书签名请求等功能；</li><li><code>-newkey</code>：创建CSR证书签名文件和RSA私钥文件；</li><li><code>rsa:2048</code>：指定创建的RSA私钥长度为2048；</li><li><code>-nodes</code>：对私钥不进行加密；</li><li><code>-sha256</code>：使用SHA256算法</li><li><code>-keyout</code>：创建的私钥文件名称及位置</li><li><code>-x509</code>：自签发证书格式</li><li><code>-days</code>：证书有效期</li><li><code>-out</code>：指定CSR输出文件名称及位置</li></ul><p>通过openssl 先生成自签名证书，运行命令后需要填写一些证书信息，里面最关键的部分是：<code>Common Name (eg,your name or your server&#39;s hostname) []:81.70.10.115</code>，这里注意填写的要是自己服务器的地址。</p></li></ol></li><li><p>生成鉴权密码文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建存储鉴权密码文件的目录</span><br>mkdir -p /usr/local/registry/auth<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果没有htpasswd 功能需要安装 htpasswd</span><br>yum install -y httpd<br><span class="hljs-meta prompt_">#</span><span class="language-bash">创建用户和密码</span><br>htpasswd -Bbn root 1234 &gt; /usr/local/registry/auth/htpasswd<br></code></pre></td></tr></table></figure><blockquote><p>htpasswd 是 apache http 的基本认证文件，使用htpasswd 命令可以生成用户及密码文件</p></blockquote></li><li><p>拉取镜像后修改配置文件</p><p>修改配置文件<code>daemon.json</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/docker/daemon.json<br></code></pre></td></tr></table></figure><p>添加以下字段，指明我们的私有镜像仓库的地址</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-string">&quot;insecure-registries&quot;</span>: [<span class="hljs-string">&quot;81.70.10.115:5000&quot;</span>]<br></code></pre></td></tr></table></figure></li><li><p>创建私有仓库容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -di --name registry -p 5000:5000 \<br>-v /mydata/docker_registry:/var/lib/registry \<br>-v /usr/local/registry/certs:/certs \<br>-v /usr/local/registry/auth:/auth \<br>-e &quot;REGISTRY_AUTH=htpasswd&quot; \<br>-e &quot;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&quot; \<br>-e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \<br>-e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt \<br>-e REGISTRY_HTTP_TLE_KEY=/certs/domain.key \<br>registry<br></code></pre></td></tr></table></figure></li><li><p>登录</p><p>这时要指定仓库的地址</p><p><code>docker login 81.70.10.115:5000</code></p><p>然后就可以正常地<code>docker push</code>了</p><p>退出时也要指定仓库的地址</p><p><code>docker logout 81.70.10.115:5000</code></p></li></ol><h2 id="使用自定义网络："><a href="#使用自定义网络：" class="headerlink" title="使用自定义网络："></a>使用自定义网络：</h2><blockquote><p>默认的docker网络模式有三种：bridge，host，none</p><p>自定义的网络就是bridge的改进版，我们可以通过容器的名称直接来通讯，而不是每次启动都会改变的ip地址</p></blockquote><h3 id="创建网络："><a href="#创建网络：" class="headerlink" title="创建网络："></a>创建网络：</h3><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker network create [OPTIONS] 网络名称<br></code></pre></td></tr></table></figure><p>重要参数：</p><ul><li><code>-d</code>：定义网络的驱动程序，默认为bridge</li></ul><h3 id="使用自定义网络：-1"><a href="#使用自定义网络：-1" class="headerlink" title="使用自定义网络："></a>使用自定义网络：</h3><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --net 网络名称 镜像名称<br></code></pre></td></tr></table></figure><h3 id="其它"><a href="#其它" class="headerlink" title="其它:"></a>其它:</h3><p><strong>断开：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">docker network disconnect <br></code></pre></td></tr></table></figure><blockquote><p>还有个集群的部分，未完待续。。。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>打怪升级</category>
      
      <category>搞定docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>🎮redis入门--简单命令</title>
    <link href="/2022/07/28/redis%E5%85%A5%E9%97%A8--%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/07/28/redis%E5%85%A5%E9%97%A8--%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>之前学过一段时间的redis，但碍于囫囵吞枣，而且没做总结，后来又没怎么用，所以忘的七七八八了，这次要整体好好的学一学redis，首先从简单命令开始。</p><span id="more"></span><h1 id="⛽redis入门–简单命令🙂"><a href="#⛽redis入门–简单命令🙂" class="headerlink" title="⛽redis入门–简单命令🙂"></a>⛽redis入门–简单命令🙂</h1><h2 id="五种数据类型："><a href="#五种数据类型：" class="headerlink" title="五种数据类型："></a>五种数据类型：</h2><h3 id="键命令："><a href="#键命令：" class="headerlink" title="键命令："></a>键命令：</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/keys-del.html">DEL key</a></td><td>删除键</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-dump.html">DUMP key</a></td><td>序列化键对应的值</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-exists.html">EXISTS key</a></td><td>判断键是否存在</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-expire.html">EXPIRE key</a> seconds</td><td>设置键的过期时间</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-expireat.html">EXPIREAT key timestamp</a></td><td>设置键在具体的一个时间过期，参数是时间戳的形式</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-pexpire.html">PEXPIRE key milliseconds</a></td><td>设置键的过期时间，参数以毫秒为单位</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-pexpireat.html">PEXPIREAT key milliseconds-timestamp</a></td><td>设置键在具体的一个时间过期，参数是毫秒时间戳的形式</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-keys.html">KEYS pattern</a></td><td>匹配符合的KEY</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-move.html">MOVE key db</a></td><td>将键移到其它的数据库</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-persist.html">PERSIST key</a></td><td>将KEY的过期时间去掉，永久保存</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-pttl.html">PTTL key</a></td><td>返回Key的有效时间，以毫秒为单位</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-ttl.html">TTL key</a></td><td>同上，以秒为单位</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-randomkey.html">RANDOMKEY</a></td><td>随机返回一个Key</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-rename.html">RENAME key newkey</a></td><td>重命名，如果newkey已经存在，则会覆盖</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-renamenx.html">RENAMENX key newkey</a></td><td>重命名，不过只有newkey不存在时才会成功</td></tr><tr><td>[SCAN cursor <a href="https://www.runoob.com/redis/keys-scan.html">MATCH pattern] [COUNT count]</a></td><td>遍历键，每次返回一个</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-type.html">TYPE key</a></td><td>返回Key的类型</td></tr></tbody></table><h3 id="String-字符串-："><a href="#String-字符串-：" class="headerlink" title="String(字符串)："></a>String(字符串)：</h3><ul><li>string是redis中最基本的数据类型，一个key对应一个value。</li><li>string 类型是二进制安全的。意思是它可以存储任何数据，比如jpg图片和序列化后的对象。</li><li>最多可以存储512MB</li></ul><h4 id="增："><a href="#增：" class="headerlink" title="增："></a>增：</h4><table><thead><tr><th>增</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/strings-set.html">SET key value</a></td><td>设置指定KEY的值，KEY不存在则是添加，存在则是修改覆盖</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-mset.html">MSET key value key value </a></td><td>同时设置多个值</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-setbit.html">SETBIT key offset value</a></td><td>设置key上一个位的值（0或1）</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-setex.html">SETEX key seconds value</a></td><td>设置一个值，并设置过期时间</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-psetex.html">PSETEX key milliseconds value</a></td><td>设置一个值，并设置过期时间，时间的单位毫秒</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-setnx.html">SETNX key value</a></td><td>当KEY还未被使用时，在这个key上设一个值</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-msetnx.html">MSETNX key value key value </a></td><td>同时设置多个值，只有每个KEY都未被使用时成功执行</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-incr.html">INCR key</a></td><td>为数值加1</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-incrby.html">INCRBY key increment</a></td><td>为数值加上increment</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-incrbyfloat.html">INCRBYFLOAT key increment</a></td><td>将 key 所储存的值加上给定的浮点增量值（increment）</td></tr></tbody></table><h4 id="删："><a href="#删：" class="headerlink" title="删："></a>删：</h4><table><thead><tr><th>删</th><th>-</th></tr></thead><tbody><tr><td>DEL KEY</td><td>删查一个键</td></tr><tr><td>借鉴上面的过期</td><td></td></tr></tbody></table><h4 id="查："><a href="#查：" class="headerlink" title="查："></a>查：</h4><table><thead><tr><th>查</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/strings-get.html">GET key</a></td><td>获取key对应的值</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-mget.html">MGET key1 key2</a></td><td>获取多个key对应的值</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-getrange.html">GETRANGE key start end</a></td><td>获取key值对应区间的子字符串</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-getbit.html">GETBIT key offset</a></td><td>获取key上一个位的值</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-strlen.html">STRLEN key</a></td><td>获取key对应的值的长度</td></tr></tbody></table><h4 id="改："><a href="#改：" class="headerlink" title="改："></a>改：</h4><table><thead><tr><th>改</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/strings-setrange.html">SETRANGE key offset value</a></td><td>用value值从offset开始覆盖写</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-incr.html">INCR key</a></td><td>为数值加1</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-incrby.html">INCRBY key increment</a></td><td>为数值加上increment</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-incrbyfloat.html">INCRBYFLOAT key increment</a></td><td>将 key 所储存的值加上给定的浮点增量值（increment）</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-decr.html">DECR key</a></td><td>为数值减1</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-decrby.html">DECRBY key decrement</a></td><td>为数值减decremen</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-append.html">APPEND key value</a></td><td>如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。</td></tr></tbody></table><h3 id="Hash-哈希-："><a href="#Hash-哈希-：" class="headerlink" title="Hash(哈希)："></a>Hash(哈希)：</h3><h4 id="增：-1"><a href="#增：-1" class="headerlink" title="增："></a>增：</h4><table><thead><tr><th>增</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/hashes-hset.html">HSET key field value</a></td><td>设置key上一个键值对</td></tr><tr><td><a href="https://www.runoob.com/redis/hashes-hmset.html">HMSET key field1 value1 field2 value2 </a></td><td>设置key上的多个键值对</td></tr><tr><td><a href="https://www.runoob.com/redis/hashes-hsetnx.html">HSETNX key field value</a></td><td>当key上的field字段还未设置时，添加该键值对</td></tr></tbody></table><h4 id="删：-1"><a href="#删：-1" class="headerlink" title="删："></a>删：</h4><table><thead><tr><th>删</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/hashes-hdel.html">HDEL key field1 field2</a></td><td>删除一个或多个key中的字段</td></tr></tbody></table><h4 id="查：-1"><a href="#查：-1" class="headerlink" title="查："></a>查：</h4><table><thead><tr><th>查</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/hashes-hget.html">HGET key field</a></td><td>获取key中的字段field的值</td></tr><tr><td><a href="https://www.runoob.com/redis/hashes-hmget.html">HMGET key field1 field2</a></td><td>获取key中多个字段field的值</td></tr><tr><td><a href="https://www.runoob.com/redis/hashes-hgetall.html">HGETALL key</a></td><td>获取在哈希表中指定 key 的所有字段和值</td></tr><tr><td><a href="https://www.runoob.com/redis/hashes-hkeys.html">HKEYS key</a></td><td>获取所有哈希表中的字段</td></tr><tr><td><a href="https://www.runoob.com/redis/hashes-hvals.html">HVALS key</a></td><td>获取哈希表中所有值</td></tr><tr><td><a href="https://www.runoob.com/redis/hashes-hlen.html">HLEN key</a></td><td>获取哈希表中字段的数量</td></tr><tr><td>[HSCAN key cursor <a href="https://www.runoob.com/redis/hashes-hscan.html">MATCH pattern] [COUNT count]</a></td><td>迭代哈希表中的键值对。pattern是对应field的</td></tr></tbody></table><h4 id="改：-1"><a href="#改：-1" class="headerlink" title="改："></a>改：</h4><table><thead><tr><th>改</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/hashes-hincrby.html">HINCRBY key field increment</a></td><td>为哈希表 key 中的指定字段的整数值加上增量 increment</td></tr><tr><td><a href="https://www.runoob.com/redis/hashes-hincrbyfloat.html">HINCRBYFLOAT key field increment</a></td><td>为哈希表 key 中的指定字段的浮点数值加上增量 increment</td></tr></tbody></table><h3 id="List-列表-："><a href="#List-列表-：" class="headerlink" title="List(列表)："></a>List(列表)：</h3><h4 id="增：-2"><a href="#增：-2" class="headerlink" title="增："></a>增：</h4><table><thead><tr><th>增</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/lists-lpush.html">LPUSH key value1 value2</a></td><td>往队头插入多个值</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-lpushx.html">LPUSHX key value</a></td><td>将一个值插入到已存在的列表头部</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-rpush.html">RPUSH key value1 value2</a></td><td>在列表尾部添加一个或多个值</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-rpushx.html">RPUSHX key value</a></td><td>为已存在的列表添加值</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-linsert.html">LINSERT key BEFORE|AFTER pivot value</a></td><td>在列表中与pivot相等的元素前或者后插入元素</td></tr></tbody></table><h4 id="删：-2"><a href="#删：-2" class="headerlink" title="删："></a>删：</h4><table><thead><tr><th>删</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/lists-lpop.html">LPOP key</a></td><td>移出并获取列表的第一个元素</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-rpop.html">RPOP key</a></td><td>移除列表的最后一个元素，返回值为移除的元素</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-blpop.html">BLPOP key1 key2 timeout</a></td><td>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-brpop.html">BRPOP key1 key2  timeout</a></td><td>同上，不过是移除最后一个元素</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-rpoplpush.html">RPOPLPUSH source destination</a></td><td>移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-brpoplpush.html">BRPOPLPUSH source destination timeout</a></td><td>从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-lrem.html">LREM key count value</a></td><td>移除列表中与value相等的，count绝对值个元素，count大于0表示从对头开始的count个元素，count小于0表示从队尾开始的count个元素，count&#x3D;0则是删除全部相等的</td></tr></tbody></table><h4 id="查：-2"><a href="#查：-2" class="headerlink" title="查："></a>查：</h4><table><thead><tr><th>查</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/lists-lindex.html">LINDEX key index</a></td><td>通过索引获取列表中的元素</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-llen.html">LLEN key</a></td><td>获取列表长度</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-lrange.html">LRANGE key start stop</a></td><td>获取列表指定范围内的元素</td></tr></tbody></table><h4 id="改：-2"><a href="#改：-2" class="headerlink" title="改："></a>改：</h4><table><thead><tr><th>改</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/lists-lset.html">LSET key index value</a></td><td>通过索引设置列表元素的值</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-ltrim.html">LTRIM key start stop</a></td><td>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</td></tr></tbody></table><h3 id="Set-集合-："><a href="#Set-集合-：" class="headerlink" title="Set(集合)："></a>Set(集合)：</h3><h4 id="增：-3"><a href="#增：-3" class="headerlink" title="增："></a>增：</h4><table><thead><tr><th>增</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/sets-sadd.html">SADD key member1 member2</a></td><td>向集合添加一个或多个成员</td></tr></tbody></table><h4 id="删：-3"><a href="#删：-3" class="headerlink" title="删："></a>删：</h4><table><thead><tr><th>删</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/sets-srem.html">SREM key member1 member2</a></td><td>移除集合中一个或多个成员</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-spop.html">SPOP key</a></td><td>移除并返回集合中的一个随机元素</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-smove.html">SMOVE source destination member</a></td><td>将 member 元素从 source 集合移动到 destination 集合</td></tr></tbody></table><h4 id="查：-3"><a href="#查：-3" class="headerlink" title="查："></a>查：</h4><table><thead><tr><th>查</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/sets-scard.html">SCARD key</a></td><td>获取集合的成员数</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-sdiff.html">SDIFF key1 key2</a></td><td>返回第一个集合与其他集合之间的差异</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-sdiffstore.html">SDIFFSTORE destination key1 key2</a></td><td>返回给定所有集合的差集并存储在 destination 中</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-sinter.html">SINTER key1 key2</a></td><td>返回给定所有集合的交集</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-sinterstore.html">SINTERSTORE destination key1 key2</a></td><td>返回给定所有集合的交集并存储在 destination 中</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-sunion.html">SUNION key1 key2</a></td><td>返回所有给定集合的并集</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-sunionstore.html">SUNIONSTORE destination key1 key2</a></td><td>所有给定集合的并集存储在 destination 集合中</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-sismember.html">SISMEMBER key member</a></td><td>判断 member 元素是否是集合 key 的成员</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-smembers.html">SMEMBERS key</a></td><td>返回集合中的所有成员</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-srandmember.html">SRANDMEMBER key count</a></td><td>返回集合中一个或多个随机数</td></tr><tr><td>[SSCAN key cursor <a href="https://www.runoob.com/redis/sets-sscan.html">MATCH pattern] [COUNT count]</a></td><td>迭代集合中的元素</td></tr></tbody></table><h3 id="zset-sorted-set-有序集合-："><a href="#zset-sorted-set-有序集合-：" class="headerlink" title="zset(sorted set:有序集合)："></a>zset(sorted set:有序集合)：</h3><h4 id="增：-4"><a href="#增：-4" class="headerlink" title="增："></a>增：</h4><table><thead><tr><th>增</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zadd.html">ZADD key score1 member1 score2 member2</a></td><td>向有序集合添加一个或多个成员，或者更新已存在成员的分数</td></tr></tbody></table><h4 id="删：-4"><a href="#删：-4" class="headerlink" title="删："></a>删：</h4><table><thead><tr><th>删</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zrem.html">ZREM key member member </a></td><td>移除有序集合中的一个或多个成员</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zremrangebylex.html">ZREMRANGEBYLEX key min max</a></td><td>移除有序集合中给定的字典区间的所有成员</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zremrangebyrank.html">ZREMRANGEBYRANK key start stop</a></td><td>移除有序集合中给定的排名区间的所有成员</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zremrangebyscore.html">ZREMRANGEBYSCORE key min max</a></td><td>移除有序集合中给定的分数区间的所有成员</td></tr></tbody></table><h4 id="查：-4"><a href="#查：-4" class="headerlink" title="查："></a>查：</h4><table><thead><tr><th>查</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zcard.html">ZCARD key</a></td><td>获取有序集合的成员数</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zcount.html">ZCOUNT key min max</a></td><td>计算在有序集合中指定区间分数的成员数</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zlexcount.html">ZLEXCOUNT key min max</a></td><td>在有序集合中计算指定字典区间内成员数量</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zrange.html">ZRANGE key start stop WITHSCORES</a></td><td>通过索引区间返回有序集合指定区间内的成员</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zrevrange.html">ZREVRANGE key start stop WITHSCORES</a></td><td>返回有序集中指定区间内的成员，通过索引，分数从高到低</td></tr><tr><td>[ZRANGEBYSCORE key min max <a href="https://www.runoob.com/redis/sorted-sets-zrangebyscore.html">WITHSCORES] [LIMIT offset count]</a></td><td>通过分数返回有序集合指定区间内的成员</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zrevrangebyscore.html">ZREVRANGEBYSCORE key max min WITHSCORES</a></td><td>返回有序集中指定分数区间内的成员，分数从高到低排序</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zrangebylex.html">ZRANGEBYLEX key min max LIMIT offset count</a></td><td>通过字典区间返回有序集合的成员</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zinterstore.html">ZINTERSTORE destination numkeys key key </a></td><td>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 destination 中</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zunionstore.html">ZUNIONSTORE destination numkeys key key</a></td><td>计算给定的一个或多个有序集的并集，并存储在新的 key 中</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zrank.html">ZRANK key member</a></td><td>返回有序集合中指定成员的索引</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zrevrank.html">ZREVRANK key member</a></td><td>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zscore.html">ZSCORE key member</a></td><td>返回有序集中，成员的分数值</td></tr><tr><td>[ZSCAN key cursor <a href="https://www.runoob.com/redis/sorted-sets-zscan.html">MATCH pattern] [COUNT count]</a></td><td>迭代有序集合中的元素（包括元素成员和元素分值）</td></tr></tbody></table><h4 id="改：-3"><a href="#改：-3" class="headerlink" title="改："></a>改：</h4><table><thead><tr><th>改</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zincrby.html">ZINCRBY key increment member</a></td><td>有序集合中对指定成员的分数加上增量 increment</td></tr></tbody></table><h2 id="基数统计："><a href="#基数统计：" class="headerlink" title="基数统计："></a>基数统计：</h2><blockquote><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p><p>什么是基数?</p><p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p></blockquote><table><thead><tr><th>-</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/hyperloglog-pfadd.html">PFADD key element element</a></td><td>添加指定元素到 HyperLogLog 中</td></tr><tr><td><a href="https://www.runoob.com/redis/hyperloglog-pfcount.html">PFCOUNT key key</a></td><td>返回给定 HyperLogLog 的基数值，如果多个 HyperLogLog 则返回基数估值之和。</td></tr><tr><td><a href="https://www.runoob.com/redis/hyperloglog-pfmerge.html">PFMERGE destkey sourcekey sourcekey </a></td><td>将多个 HyperLogLog 合并为一个 HyperLogLog</td></tr></tbody></table><h2 id="发布订阅："><a href="#发布订阅：" class="headerlink" title="发布订阅："></a>发布订阅：</h2><blockquote><p>Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p></blockquote><table><thead><tr><th>-</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/pub-sub-subscribe.html">SUBSCRIBE channel channel </a></td><td>订阅给定的一个或多个频道的信息。</td></tr><tr><td><a href="https://www.runoob.com/redis/pub-sub-psubscribe.html">PSUBSCRIBE pattern pattern</a></td><td>订阅一个或多个符合给定模式的频道</td></tr><tr><td>[PUNSUBSCRIBE <a href="https://www.runoob.com/redis/pub-sub-punsubscribe.html">pattern [pattern …]]</a></td><td>退订所有给定模式的频道</td></tr><tr><td><a href="https://www.runoob.com/redis/pub-sub-publish.html">PUBLISH channel message</a></td><td>将信息发送到指定的频道</td></tr><tr><td>[UNSUBSCRIBE <a href="https://www.runoob.com/redis/pub-sub-unsubscribe.html">channel [channel …]]</a></td><td>指退订给定的频道</td></tr><tr><td><a href="https://www.runoob.com/redis/pub-sub-pubsub.html">PUBSUB channels pattern</a></td><td>Pattern 有则返回跟pattern相关的，没有则返回全部</td></tr></tbody></table><h2 id="事务："><a href="#事务：" class="headerlink" title="事务："></a>事务：</h2><blockquote><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p><p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p></blockquote><table><thead><tr><th>-</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/transactions-multi.html">MULTI</a></td><td>标记一个事务块的开始。</td></tr><tr><td><a href="https://www.runoob.com/redis/transactions-exec.html">EXEC</a></td><td>执行所有事务块内的命令。</td></tr><tr><td><a href="https://www.runoob.com/redis/transactions-discard.html">DISCARD</a></td><td>取消事务，放弃执行事务块内的所有命令。</td></tr><tr><td><a href="https://www.runoob.com/redis/transactions-watch.html">WATCH key key</a></td><td>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</td></tr><tr><td><a href="https://www.runoob.com/redis/transactions-unwatch.html">UNWATCH</a></td><td>取消 WATCH 命令对所有 key 的监视。</td></tr></tbody></table><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><blockquote><p>Redis Stream 是 Redis 5.0 版本新增加的数据结构。</p><p>Redis Stream 主要用于消息队列（MQ，Message Queue），Redis 本身是有一个 Redis 发布订阅 (pub&#x2F;sub) 来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。</p><p>简单来说发布订阅 (pub&#x2F;sub) 可以分发消息，但无法记录历史消息。</p><p>而 Redis Stream 提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</p></blockquote><table><thead><tr><th>-</th><th>-</th></tr></thead><tbody><tr><td>XADD key ID field value [field value …]</td><td><strong>key</strong> ：队列名称，如果不存在就创建 <strong>ID</strong> ：消息 id，我们使用 * 表示由 redis 生成，可以自定义，但是要自己保证递增性。 <strong>field value</strong> ： 记录。</td></tr><tr><td>XTRIM key MAXLEN</td><td><strong>key</strong> ：队列名称 <strong>MAXLEN</strong> ：长度</td></tr><tr><td>XDEL key ID [ID …]</td><td><strong>key</strong>：队列名称 <strong>ID</strong> ：消息 ID</td></tr><tr><td>XLEN key</td><td>使用 XLEN 获取流包含的元素数量，即消息长度</td></tr><tr><td>XRANGE key start end [COUNT count]</td><td><strong>key</strong> ：队列名 <strong>start</strong> ：开始值， <strong>-</strong> 表示最小值 <strong>end</strong> ：结束值， <strong>+</strong> 表示最大值 <strong>count</strong> ：数量</td></tr><tr><td>XREVRANGE key end start [COUNT count]</td><td><strong>key</strong> ：队列名 <strong>end</strong> ：结束值， <strong>+</strong> 表示最大值 <strong>start</strong> ：开始值， <strong>-</strong> 表示最小值 <strong>count</strong> ：数量</td></tr><tr><td>XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key …] id [id …]</td><td><strong>count</strong> ：数量 <strong>milliseconds</strong> ：可选，阻塞毫秒数，没有设置就是非阻塞模式 <strong>key</strong> ：队列名 <strong>id</strong> ：消息 ID</td></tr><tr><td>XGROUP [CRETE KEY groupname id-or-$]</td><td><strong>key</strong> ：队列名称，如果不存在就创建 <strong>groupname</strong> ：组名。 <strong>$</strong> ： 表示从尾部开始消费，只接受新消息，当前 Stream 消息会全部忽略。</td></tr><tr><td>XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key …] ID [ID …]</td><td><strong>group</strong> ：消费组名 <strong>consumer</strong> ：消费者名。 <strong>count</strong> ： 读取数量。 <strong>milliseconds</strong> ： 阻塞毫秒数。 <strong>key</strong> ： 队列名。 <strong>ID</strong> ： 消息 ID。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>打怪升级</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>⚒认证与授权--cookie|session|token|JWT</title>
    <link href="/2022/07/27/%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/"/>
    <url>/2022/07/27/%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<p>用户认证与授权是一个系统最基本的功能，下面我们一起了解下常见的解决方案的特性与他们相互间的差别，最后是JWT在Go上的使用案例。</p><span id="more"></span><h1 id="😀认证与授权："><a href="#😀认证与授权：" class="headerlink" title="😀认证与授权："></a>😀认证与授权：</h1><blockquote><p>常见的解决方案有cookie、session、token</p><p>在知乎上看到有人用了一个很秒的例子来描述这三个东西👍：在学校或公司，入学入职的那一天，会录入你的身份、账户信息，然后给你发个卡，今后在园区内，你的门禁、打卡、消费都只需要这张卡。</p></blockquote><h2 id="😁Cookie："><a href="#😁Cookie：" class="headerlink" title="😁Cookie："></a>😁Cookie：</h2><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>保存在客户端</li><li>不可跨域，每个Cookie会被绑定在单一域名下，无法在别的域名下使用</li></ul><h3 id="属性（1-⑥）："><a href="#属性（1-⑥）：" class="headerlink" title="属性（1+⑥）："></a>属性（1+⑥）：</h3><ul><li><p><strong>键值对</strong>：在Cookie中设置自定义的值，eg：<code>id=&quot;123456&quot;</code></p></li><li><p><strong>Cookie的域：</strong>在响应首部的Set-Cookie添加domain属性，来控制哪些站点能看到这个Cookie。eg：<code>Set-Cookie: name=&quot;Peng&quot;;domain=&quot;m.zhuanzhuan.58.com&quot;</code>，如果用户访问的是m.zhuanzhuan.58.com，或者m.zhuanzhuan.58.com&#x2F;user 则都可以，而如果是<a href="http://www.aaa.com(非zhuanzhuan.58.com)就不会看到这个cookie./">www.aaa.com(非zhuanzhuan.58.com)就不会看到这个Cookie。</a></p></li><li><p><strong>Cookie的路径Path：</strong>通过添加Path属性可以在特定的路径（这个属性设置的Url和带有这个前缀的Url路径都是有效的）下获得Cookie。</p></li><li><p><strong>Secure：</strong>设置了属性Secure，<code>Set-Cookie: name=&quot;Peng&quot;;domain=&quot;m.zhuanzhuan.58.com&quot;;Secure</code>，则这个Cookie只有在https协议加密的情况下才会发送给客户端</p></li><li><p>**HTTP only:**设置该属性后，则无法通过JS脚本来获得Cookie。</p></li><li><p><strong>Expires：</strong>设置Cookie的过期时间，GMT格式，到达该时间后Cookie会自动失效。</p></li><li><p><strong>max-age：</strong>在HTTP1.1中定义的，优先级高于Expires，表示Cookie的有效期，单位为秒，当值为正数时表示再过去n秒后该Cookie失效，当值为负数时，表示该Cookie为临时Cookie，在浏览器退出后该Cookie则失效，如果值为0则表示取消该Cookie。默认为-1。</p></li></ul><h3 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h3><p><img src="https://pic.rmb.bdstatic.com/bjh/9005b6a0f0e19e96d433046bbf434448.png"></p><ol><li>用户输入用户名，密码（或其它认证方式）到服务器。</li><li>服务器认证成功后，就会利用Set-cookie的头部字段，将Cookie返回给客户端。</li><li>客户端下一次发起请求时，请求首部则会带上这个Cookie</li><li>服务器通过客户端发来的Cookie，便能知道发出该请求的用户，并决定是否通过</li></ol><h2 id="Session-😜"><a href="#Session-😜" class="headerlink" title="Session:😜"></a>Session:😜</h2><blockquote><p>对应于Session就是，其实你的卡上只存了一个id（可能是你的学号），刷的时候物业系统就会去查你的信息、账户，再决定“这个门你能不能进”“这个鸡腿去哪个账户扣钱”</p></blockquote><h3 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h3><ul><li>有重要信息（用户信息，Session状态等）的Session保存在服务器中，而会生成一个SessionId给客户端保存。</li><li>一般基于Cookie实现。</li></ul><h3 id="过程：-1"><a href="#过程：-1" class="headerlink" title="过程："></a>过程：</h3><p><img src="https://pic3.zhimg.com/80/v2-18bd4826103a35c3ef4d99742ad1bd12_1440w.jpg"></p><ol><li>用户输入用户名，密码（或其它认证方式）到服务器。</li><li>服务器认证成功后，在服务器端生成一个Session，保存在文件或者内存或缓存中，然后返回给客户端一个SessionId，SessionId会被客户端保存在Cookie上。</li><li>客户端下一次发起请求时，会自动带上Cookie，Cookie中会携带SessionId。</li><li>服务器接受到Cookie后，检查SessionId的有效性后，决定是否通过。</li></ol><h2 id="😋Token："><a href="#😋Token：" class="headerlink" title="😋Token："></a>😋Token：</h2><blockquote><p>对应于Token就是，在比较早之前，在没有校园卡技术以前，我们都靠学生证。门卫小哥直接对照我和学生证上的脸，确认学生证有效期、年纪等信息，就可以放行了。</p></blockquote><h3 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h3><ul><li>服务器不用再存储信息，减少服务器的压力。</li><li>Token保存在客户端，服务器只需检验Token的有效性</li></ul><h3 id="过程：-2"><a href="#过程：-2" class="headerlink" title="过程："></a>过程：</h3><p><img src="https://pic2.zhimg.com/80/v2-45c53c27a611d78c489a25f3496c7625_1440w.jpg"></p><ol><li>用户输入用户名，密码（或其它认证方式）到服务器。</li><li>服务器认证成功后，在服务器端生成一个Token，这里展示的是通过Cookie传回token,token里面包括了基本的用户信息。</li><li>客户端保存Token后，下次请求时会带上Token</li><li>服务器检验Token的有效性后，决定是否通过。</li></ol><p><strong>考虑到编码，防篡改等问题我们直接讲Token的一个实践JWT（Json Web Token）</strong></p><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT:"></a>JWT:</h2><p><img src="https://pic.rmb.bdstatic.com/bjh/f5b29a28f7c421c77022122c1d291c6c.png" alt="image-20220722172608892"></p><center>一个完整的JWT的结构</center><h3 id="特点：-3"><a href="#特点：-3" class="headerlink" title="特点："></a>特点：</h3><ul><li>继承上面Token的优势，进一步地改善了编码，防篡改的问题。</li></ul><h3 id="三大组成："><a href="#三大组成：" class="headerlink" title="三大组成："></a>三大组成：</h3><p><strong>Header：</strong></p><p>Header主要保存了这个JWT的元数据，主要就是两个部分:<code>alg</code>和<code>typ</code>，<code>alg</code>属性表示签名的算法(algorithm),默认是HMAC SHA256 简写为HS256，<code>typ</code>表示Token的类型，JWT则为JWT。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;alg&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;HS256&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;typ&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;JWT&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>Payload：</strong></p><p>Payload则是存放数据的地方，JWT规定了7个官方字段，供选用。</p><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul><p>我们也可以自己加入一些私有字段。</p><p><strong>这里要注意的是：</strong>虽说我们后面有签名的环节，但那只是为了防止篡改，上面两个部分我们采用的base64UrlEncode编码方法是可以通过防编码出来的，所以重要数据不能放在Payload中。</p><p><strong>Signature:</strong></p><p>在上面Token的部分你可能就有察觉到，我们这次是将用户的信息放在Token里面保存到Cookie中的，这里就存在我们的Token信息被读取，被人用来伪装的可能性，所以就加了签名这一步骤，服务器自己保存了一把密钥，这样就算别人窃取了信息，也无法进行签名，进行伪装。</p><p><strong>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户</strong>。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">HMACSHA256</span>(<br>  base64UrlEncode(header) + &quot;.&quot; +<br>  <span class="hljs-built_in">base64UrlEncode</span>(payload),<br>  secret)<br></code></pre></td></tr></table></figure><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（<code>.</code>）分隔，就可以返回给用户。</p><h3 id="过程：-3"><a href="#过程：-3" class="headerlink" title="过程："></a>过程：</h3><ol><li>用户输入用户名，密码（或其它认证方式）到服务器。</li><li>服务器认证成功后，生成一个JWT，返回给客户端，客户端将会保存JWT。</li><li>客户端下一次发起请求时会带上JWT</li><li>服务器用自己的私钥解析客户端发送过来的JWT，决定是否通过</li></ol><h2 id="JWT在Go中的使用案例："><a href="#JWT在Go中的使用案例：" class="headerlink" title="JWT在Go中的使用案例："></a>JWT在Go中的使用案例：</h2><p>首先go get 一下✨</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> get github.com/dgrijalva/jwt-<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><h3 id="获取JWT："><a href="#获取JWT：" class="headerlink" title="获取JWT："></a>获取JWT：</h3><p>根据前面的讲解，我们已经了解到JWT的数据结构，它就是由两个编码过的json文件加一个签名组成。那我们要做的就是拼装这三个部分。</p><p><strong>Header：</strong></p><p>这个部分包含两个字段，这两个字段都不用我们填，会由你选择的签名算法自动填写好。</p><p><strong>Payload：</strong>（获得Token对象）</p><p>首先我们看下<code>jwt.StandardClaims</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">type</span> StandardClaims <span class="hljs-keyword">struct</span> &#123;<br>Audience  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;aud,omitempty&quot;`</span><br>ExpiresAt <span class="hljs-type">int64</span>  <span class="hljs-string">`json:&quot;exp,omitempty&quot;`</span><br>Id        <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;jti,omitempty&quot;`</span><br>IssuedAt  <span class="hljs-type">int64</span>  <span class="hljs-string">`json:&quot;iat,omitempty&quot;`</span><br>Issuer    <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;iss,omitempty&quot;`</span><br>NotBefore <span class="hljs-type">int64</span>  <span class="hljs-string">`json:&quot;nbf,omitempty&quot;`</span><br>Subject   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;sub,omitempty&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这就是我们上面所说的官方提供的几个可选的字段，在Go中我们使用常用的方法–结构体组合来实现添加我们想要的字段，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Claims <span class="hljs-keyword">struct</span> &#123;<br>UserId <span class="hljs-type">int64</span><br>jwt.StandardClaims<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们把这些字段填充完整，就可以得到Token了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">claims := &amp;Claims&#123;<br>    UserId: user.UserInfoId,<br>    StandardClaims: jwt.StandardClaims&#123;<br>        ExpiresAt: expirationTime.<span class="hljs-built_in">Unix</span>(),<br>        IssuedAt:  time.<span class="hljs-built_in">Now</span>().<span class="hljs-built_in">Unix</span>(),<br>        Issuer:    <span class="hljs-string">&quot;douyin_pro_131&quot;</span>,<br>        Subject:   <span class="hljs-string">&quot;L_B__&quot;</span>,<br>    &#125;&#125;<br>token := jwt.<span class="hljs-built_in">NewWithClaims</span>(jwt.SigningMethodHS256, claims)<br><br></code></pre></td></tr></table></figure><p><strong>Signature:</strong></p><p>上面获得Token对象后，调用<code>jwt.SignedString()</code>，并传入自己服务器保存的密钥（一个 <code>byte[]</code>），就会自动完成Signature部分的编写和对上面三个部分分别进行base64url编码，再整合成一个最终的字符串返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">jwtKey:=[]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;我的密钥&quot;</span>)<br>tokenString,err:=token.SignedString(jwtKey)<br></code></pre></td></tr></table></figure><h3 id="验证JWT："><a href="#验证JWT：" class="headerlink" title="验证JWT："></a>验证JWT：</h3><p>以常用的Web框架Gin为例，我们会把这个部分放到中间件那里使用。</p><p>解析Token：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParseToken</span><span class="hljs-params">(tokenString <span class="hljs-type">string</span>)</span></span> (*MyClaims, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 验证token是否是我们自己签发的</span><br>token, err := jwt.ParseWithClaims(tokenString, &amp;MyClaims&#123;&#125;, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(token *jwt.Token)</span></span> (i <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> jwtKey, <span class="hljs-literal">nil</span><br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> claims, ok := token.Claims.(*MyClaims); ok &amp;&amp; token.Valid &#123; <span class="hljs-comment">// 校验token</span><br><span class="hljs-keyword">return</span> claims, <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;invalid token&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>用于中间件中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">JWTAuthMiddleware</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">// 客户端携带Token有三种方式 1.放在请求头 2.放在请求体 3.放在URI</span><br><span class="hljs-comment">// 这里假设Token放在Header的Authorization中，并使用Bearer开头</span><br><span class="hljs-comment">// 这里的具体实现方式要依据你的实际业务情况决定</span><br>authHeader := c.Query(<span class="hljs-string">&quot;token&quot;</span>)<br>fmt.Println(authHeader)<br><span class="hljs-keyword">if</span> authHeader == <span class="hljs-string">&quot;&quot;</span> &#123;<br>authHeader = c.PostForm(<span class="hljs-string">&quot;token&quot;</span>)<br>fmt.Println(authHeader)<br>&#125;<br><br><span class="hljs-keyword">if</span> authHeader == <span class="hljs-string">&quot; &quot;</span> &#123;<br>c.JSON(http.StatusOK, service.UserResponse&#123;<br>Response: service.Response&#123;StatusCode: <span class="hljs-number">1</span>&#125;,<br>&#125;)<br>c.Abort()<br><span class="hljs-keyword">return</span><br>&#125;<br><br>mc, err := app.ParseToken(authHeader)  <span class="hljs-comment">//就是调用上面的ParseToken</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>c.JSON(http.StatusOK, service.UserResponse&#123;<br>Response: service.Response&#123;StatusCode: <span class="hljs-number">1</span>&#125;,<br>&#125;)<br>c.Abort()<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(mc.UserId)<br><span class="hljs-comment">// 将当前请求的username信息保存到请求的上下文c上</span><br>c.Set(<span class="hljs-string">&quot;user_id&quot;</span>, mc.UserId)<br>c.Next() <span class="hljs-comment">// 后续的处理函数可以用过c.Get(&quot;user_id&quot;)来获取当前请求的用户信息</span><br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="JWT的一些问题："><a href="#JWT的一些问题：" class="headerlink" title="JWT的一些问题："></a>JWT的一些问题：</h3><ol><li><p>JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p></li><li><p>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p></li><li><p>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>常用中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>认证与授权</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搞定Docker--快速入门</title>
    <link href="/2022/07/19/Docker%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/19/Docker%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="🎉Docker🎉"><a href="#🎉Docker🎉" class="headerlink" title="🎉Docker🎉"></a>🎉Docker🎉</h1><p>之前老是听别人讲docker部署的各种优点，但之前单单就感觉确实挺好的，没去深入学习，这段时间有空所以打算把这把利器给捡起来！</p><span id="more"></span><blockquote><p>容器：操作系统级别的虚拟化技术。</p></blockquote><p>简史：前面是dotCloud，用了linux的容器化技术，中途发现活不下去了，就变成开源的了，活了之后就改名为docker了，后面为了进一步优化，投入了Go的怀抱，用了Go构建的引擎。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros">复习一点新虚拟机配网络的知识：<br><br>vim /etc/sysconfig/network-scripts/ifcfg-ens32 (32,也可能是33)<br><br>修改的参数：<br><span class="hljs-attribute">BOOTPROTO</span>=dhcp  (使用动态IP还是静态IP，dhcp改为static 动态改为静态)<br><span class="hljs-attribute">ONBOOT</span>=<span class="hljs-literal">no</span> (<span class="hljs-literal">no</span>改为<span class="hljs-literal">yes</span> 开机自启)<br><span class="hljs-attribute">IPADDR</span>=192.168.91.100 (IP地址，从VMware的虚拟网络设置里看)<br><span class="hljs-attribute">NETMASK</span>=255.255.255.0 (子网掩码)<br><span class="hljs-attribute">GATEWAY</span>=192.168.91.2 (网关，默认就是 IP地址 .2 )<br><span class="hljs-attribute">DNS1</span>=192.168.91.2 (自己的网关)<br><span class="hljs-attribute">DNS2</span>=144.144.144.44 (中国移动，联通 通用的 144.144.144.144)<br><span class="hljs-attribute">DNS3</span>=8.8.8.8(全球通用的,Google的)<br><br></code></pre></td></tr></table></figure><h2 id="🎖安装："><a href="#🎖安装：" class="headerlink" title="🎖安装："></a>🎖安装：</h2><ol><li><p><code>sudo yum install -y yum-utils </code>: 安装yum-utils这个包，我们才可以用它里面的工具:<code>yum-config-manager</code>来指定下载源</p></li><li><p><code>sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code>：设置为阿里的下载源</p></li><li><p><code> sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</code>  docker-ce ：docker引擎社区版、docker-ce-cli：docker引擎命令行界面 containerd.io：守护进程</p></li><li><p><code>docker -v</code>：查看版本，看是否成功。</p></li><li><p><code>docker run hello-world</code>:测试能否正常使用</p></li><li><p>配置镜像加速：1.<code>vim /etc/docker/daemon.json</code> </p><ol start="2"><li><p>添加到里面</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>启用配置、重启docker</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nsis">sudo <span class="hljs-params">system</span>ctl daemon-reload<br>sudo <span class="hljs-params">system</span>ctl restart docker<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="😱Docker-架构及工作原理："><a href="#😱Docker-架构及工作原理：" class="headerlink" title="😱Docker 架构及工作原理："></a>😱Docker 架构及工作原理：</h2><p>三个东西:</p><ul><li>Client：<strong>宿主机</strong>的命令行界面</li><li>Docker_Host：Docker引擎<ul><li>Docker daemon：<strong>守护进程</strong>，就像一个中枢一样，Client的命令发到这里，并由它来进行相应的操作，比如从远程仓库（Registry）拉取镜像，将拉取的镜像生成容器</li><li>images：镜像（模板，类似语言中的一个类）</li><li>Containers：容器 （真正工作的玩意，类似用上面的类创建的一个对象）</li></ul></li><li>Registry：远程仓库</li></ul><h3 id="Client客户端："><a href="#Client客户端：" class="headerlink" title="Client客户端："></a>Client客户端：</h3><h3 id="镜像分层："><a href="#镜像分层：" class="headerlink" title="镜像分层："></a>镜像分层：</h3><p><img src="http://i2.51cto.com/images/blog/201711/27/462718f3cd35608c20481b33b09db020.jpg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="Docker镜像的内部结构(四)"></p><p>在使用docker后，我们会拉取很多很多的镜像到本地，为了防止拉取的镜像互相间存在冗余的数据（比如Nginx和Redis都需要安装C++环境，如果拉取镜像的时候都拉取了一个，这部分相同的C++环境就是冗余的数据了，更深入些，每个镜像依赖的最基础的Linux环境也会成为冗余数据的一部分)，所以Docker采用了镜像分层的技术，也就是将最基础的Linux环境做为Base镜像，后面最终我们所使用的镜像（Nginx、Redis等等）都是在这个Base镜像的基础上，堆上一层层其它的镜像构成的，如果不同的镜像有利用到相同的部分，则不会重复拉取，而是直接复用。</p><h3 id="Volume-数据卷："><a href="#Volume-数据卷：" class="headerlink" title="Volume 数据卷："></a>Volume 数据卷：</h3><p>使容器与宿主机建立映射关系，把容器里的数据映射到宿主机上，在创建容器的时候可以指定数据卷，如果不指定，则数据还是只保存在容器中。</p><h3 id="Registry"><a href="#Registry" class="headerlink" title="Registry:"></a>Registry:</h3><p><a href="hub.docker.com">官方镜像仓库</a> 需要联网，而且上传后别人也能看到</p><p>所以docker 提供了 registry 镜像，可供我们在局域网内搭建仓库，也可以设置身份认证等等</p><h2 id="💘Docker-常用命令："><a href="#💘Docker-常用命令：" class="headerlink" title="💘Docker 常用命令："></a>💘Docker 常用命令：</h2><h3 id="镜像相关命令："><a href="#镜像相关命令：" class="headerlink" title="镜像相关命令："></a>镜像相关命令：</h3><h4 id="1-查看镜像："><a href="#1-查看镜像：" class="headerlink" title="1.查看镜像："></a>1.查看镜像：</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">docker images<br><br></code></pre></td></tr></table></figure><ul><li><code>Repository</code>:仓库名称</li></ul><h4 id="2-搜索镜像："><a href="#2-搜索镜像：" class="headerlink" title="2.搜索镜像："></a>2.搜索镜像：</h4><p>如果需要从网络中查找需要的镜像，可以通过以下命令查看是否存在</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">docker search 镜像名<br></code></pre></td></tr></table></figure><h4 id="3-拉取镜像："><a href="#3-拉取镜像：" class="headerlink" title="3.拉取镜像："></a>3.拉取镜像：</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http">docker pull 镜像名<br><br>也可以指定标签：docker pull redis:5 (例子)<br></code></pre></td></tr></table></figure><h4 id="4-删除镜像："><a href="#4-删除镜像：" class="headerlink" title="4.删除镜像："></a>4.删除镜像：</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">docker rmi 镜像名<br>也可以指定标签：docker rmi redis:5 (例子)<br></code></pre></td></tr></table></figure><h3 id="容器命令："><a href="#容器命令：" class="headerlink" title="容器命令："></a>容器命令：</h3><h4 id="1-查看命令："><a href="#1-查看命令：" class="headerlink" title="1.查看命令："></a>1.查看命令：</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http">docker ps  查看运行的容器<br>docker ps -a 查看所有的容器<br>docker ps -l 查看最后创建的容器<br>docker ps -l -n 最后几个容器<br>docker ps -f status:exited  过滤查询<br>不知道怎么操作就可以加 --help来获得帮助<br></code></pre></td></tr></table></figure><h4 id="2-创建与启动："><a href="#2-创建与启动：" class="headerlink" title="2.创建与启动："></a>2.创建与启动：</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs http">docker run 镜像名  创建容器<br>参数：<br>--name: 指定创建的容器名<br>-p:指定端口  （宿主机端口：容器端口）<br>-P：自动指定<br>-i: 运行容器<br>-t:表示容器启动后会进入其命令行界面<br>-v:可以指定目录映射关系，可以用多个-v 映射多个目录<br>-it：启动并进入，有些容器创建后不会进入，就可以这样启动后并进入<br></code></pre></td></tr></table></figure><h4 id="3-守护进程进入"><a href="#3-守护进程进入" class="headerlink" title="3.守护进程进入"></a>3.守护进程进入</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">docker run -di 镜像名<br>docker exec -it [自己取的镜像名，容器ID]  进入容器<br></code></pre></td></tr></table></figure><h4 id="4-停止启动容器"><a href="#4-停止启动容器" class="headerlink" title="4.停止启动容器"></a>4.停止启动容器</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">docker stop 容器名<br>docker start 容器名<br></code></pre></td></tr></table></figure><h4 id="5-文件拷贝："><a href="#5-文件拷贝：" class="headerlink" title="5.文件拷贝："></a>5.文件拷贝：</h4><p>可以把宿主机的拷贝到容器，也可以把容器的拷贝到宿主机</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">docker cp 需要拷贝的文件或目录 容器名称:容器目录<br>docker cp 容器名称:容器目录或文件 拷贝到宿的主机的位置<br></code></pre></td></tr></table></figure><h4 id="6-目录挂载："><a href="#6-目录挂载：" class="headerlink" title="6.目录挂载："></a>6.目录挂载：</h4><p>如果不挂载，当容器被删除后，数据也就被删除了，挂载后，宿主机的数据则还在</p><ol><li><p>指定目录挂载：<code>docker run -di -v 宿主机位置:容器目录 镜像名称</code>，docker会自动创建相应的容器目录，如果没在创建容器时挂载，后面想挂载可以通过修改配置文件来实现。</p><p><code>docker inspect 容器名 </code>可以查看所有的详细信息。</p></li><li><p>匿名挂载：<code>docker run -di -v 容器目录 镜像名称</code>,匿名挂载我们不用指定宿主机的位置，统一会被放到 <code>/var/lib/docker/volumes</code> 中，它会自动生成一个随机名称的目录，如果匿名挂载过多时，可以通过<code>docker inspect 容器名</code>来查看被挂载时随机生成的名字。</p></li><li><p>具名挂载：<code>docker run -di -v 宿主机中的目录名字:容器目录 镜像名称</code>,和上面一样会被放到<code>/var/lib/docker/volumes</code>中，不过这次可以指定名字</p></li><li><p>设置权限（只读&#x2F;读写，有时我们不希望容器在内部操作，就只允许宿主机操作，就可以挂只读），<code>docker run -di -v 容器目录:ro/rw 镜像名称</code> 只读&#x2F;读写</p></li><li><p>继承：<code>--volumes-from 被继承的容器名:ro/rw</code>，可以继承之前容器挂载的目录</p></li><li><p>查看容器ip地址：<code>docker inspect 容器名称</code></p></li><li><p>删除容器：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">docker rm 容器名称|容器ID<br>docker rm 容器名称|容器ID 容器名称|容器ID 容器名称|容器ID<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>打怪升级</category>
      
      <category>搞定docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The First Blog</title>
    <link href="/2022/06/28/The-First-Blog/"/>
    <url>/2022/06/28/The-First-Blog/</url>
    
    <content type="html"><![CDATA[<h1 id="😍全军出击🎉"><a href="#😍全军出击🎉" class="headerlink" title="😍全军出击🎉"></a>😍全军出击🎉</h1><h2 id="革命尚未成功，还需继续努力🎖"><a href="#革命尚未成功，还需继续努力🎖" class="headerlink" title="革命尚未成功，还需继续努力🎖"></a>革命尚未成功，还需继续努力🎖</h2>]]></content>
    
    
    <categories>
      
      <category>陈词滥调</category>
      
      <category>第一篇博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FirstBlog</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
