<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>搞定Docker--快速入门</title>
    <link href="/2022/07/19/Docker%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/19/Docker%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="🎉Docker🎉"><a href="#🎉Docker🎉" class="headerlink" title="🎉Docker🎉"></a>🎉Docker🎉</h1><p>之前老是听别人讲docker部署的各种优点，但之前单单就感觉确实挺好的，没去深入学习，这段时间有空所以打算把这把利器给捡起来！</p><span id="more"></span><blockquote><p>容器：操作系统级别的虚拟化技术。</p></blockquote><p>简史：前面是dotCloud，用了linux的容器化技术，中途发现活不下去了，就变成开源的了，活了之后就改名为docker了，后面为了进一步优化，投入了Go的怀抱，用了Go构建的引擎。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros">复习一点新虚拟机配网络的知识：<br><br>vim /etc/sysconfig/network-scripts/ifcfg-ens32 (32,也可能是33)<br><br>修改的参数：<br><span class="hljs-attribute">BOOTPROTO</span>=dhcp  (使用动态IP还是静态IP，dhcp改为static 动态改为静态)<br><span class="hljs-attribute">ONBOOT</span>=<span class="hljs-literal">no</span> (<span class="hljs-literal">no</span>改为<span class="hljs-literal">yes</span> 开机自启)<br><span class="hljs-attribute">IPADDR</span>=192.168.91.100 (IP地址，从VMware的虚拟网络设置里看)<br><span class="hljs-attribute">NETMASK</span>=255.255.255.0 (子网掩码)<br><span class="hljs-attribute">GATEWAY</span>=192.168.91.2 (网关，默认就是 IP地址 .2 )<br><span class="hljs-attribute">DNS1</span>=192.168.91.2 (自己的网关)<br><span class="hljs-attribute">DNS2</span>=144.144.144.44 (中国移动，联通 通用的 144.144.144.144)<br><span class="hljs-attribute">DNS3</span>=8.8.8.8(全球通用的,Google的)<br><br></code></pre></td></tr></table></figure><h2 id="🎖安装："><a href="#🎖安装：" class="headerlink" title="🎖安装："></a>🎖安装：</h2><ol><li><p><code>sudo yum install -y yum-utils </code>: 安装yum-utils这个包，我们才可以用它里面的工具:<code>yum-config-manager</code>来指定下载源</p></li><li><p><code>sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code>：设置为阿里的下载源</p></li><li><p><code> sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</code>  docker-ce ：docker引擎社区版、docker-ce-cli：docker引擎命令行界面 containerd.io：守护进程</p></li><li><p><code>docker -v</code>：查看版本，看是否成功。</p></li><li><p><code>docker run hello-world</code>:测试能否正常使用</p></li><li><p>配置镜像加速：1.<code>vim /etc/docker/daemon.json</code> </p><ol start="2"><li><p>添加到里面</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>启用配置、重启docker</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nsis">sudo <span class="hljs-params">system</span>ctl daemon-reload<br>sudo <span class="hljs-params">system</span>ctl restart docker<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="😱Docker-架构及工作原理："><a href="#😱Docker-架构及工作原理：" class="headerlink" title="😱Docker 架构及工作原理："></a>😱Docker 架构及工作原理：</h2><p>三个东西:</p><ul><li>Client：<strong>宿主机</strong>的命令行界面</li><li>Docker_Host：Docker引擎<ul><li>Docker daemon：<strong>守护进程</strong>，就像一个中枢一样，Client的命令发到这里，并由它来进行相应的操作，比如从远程仓库（Registry）拉取镜像，将拉取的镜像生成容器</li><li>images：镜像（模板，类似语言中的一个类）</li><li>Containers：容器 （真正工作的玩意，类似用上面的类创建的一个对象）</li></ul></li><li>Registry：远程仓库</li></ul><h3 id="Client客户端："><a href="#Client客户端：" class="headerlink" title="Client客户端："></a>Client客户端：</h3><h3 id="镜像分层："><a href="#镜像分层：" class="headerlink" title="镜像分层："></a>镜像分层：</h3><p><img src="http://i2.51cto.com/images/blog/201711/27/462718f3cd35608c20481b33b09db020.jpg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="Docker镜像的内部结构(四)"></p><p>在使用docker后，我们会拉取很多很多的镜像到本地，为了防止拉取的镜像互相间存在冗余的数据（比如Nginx和Redis都需要安装C++环境，如果拉取镜像的时候都拉取了一个，这部分相同的C++环境就是冗余的数据了，更深入些，每个镜像依赖的最基础的Linux环境也会成为冗余数据的一部分)，所以Docker采用了镜像分层的技术，也就是将最基础的Linux环境做为Base镜像，后面最终我们所使用的镜像（Nginx、Redis等等）都是在这个Base镜像的基础上，堆上一层层其它的镜像构成的，如果不同的镜像有利用到相同的部分，则不会重复拉取，而是直接复用。</p><h3 id="Volume-数据卷："><a href="#Volume-数据卷：" class="headerlink" title="Volume 数据卷："></a>Volume 数据卷：</h3><p>使容器与宿主机建立映射关系，把容器里的数据映射到宿主机上，在创建容器的时候可以指定数据卷，如果不指定，则数据还是只保存在容器中。</p><h3 id="Registry"><a href="#Registry" class="headerlink" title="Registry:"></a>Registry:</h3><p><a href="hub.docker.com">官方镜像仓库</a> 需要联网，而且上传后别人也能看到</p><p>所以docker 提供了 registry 镜像，可供我们在局域网内搭建仓库，也可以设置身份认证等等</p><h2 id="💘Docker-常用命令："><a href="#💘Docker-常用命令：" class="headerlink" title="💘Docker 常用命令："></a>💘Docker 常用命令：</h2><h3 id="镜像相关命令："><a href="#镜像相关命令：" class="headerlink" title="镜像相关命令："></a>镜像相关命令：</h3><h4 id="1-查看镜像："><a href="#1-查看镜像：" class="headerlink" title="1.查看镜像："></a>1.查看镜像：</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">docker images<br><br></code></pre></td></tr></table></figure><ul><li><code>Repository</code>:仓库名称</li></ul><h4 id="2-搜索镜像："><a href="#2-搜索镜像：" class="headerlink" title="2.搜索镜像："></a>2.搜索镜像：</h4><p>如果需要从网络中查找需要的镜像，可以通过以下命令查看是否存在</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">docker search 镜像名<br></code></pre></td></tr></table></figure><h4 id="3-拉取镜像："><a href="#3-拉取镜像：" class="headerlink" title="3.拉取镜像："></a>3.拉取镜像：</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http">docker pull 镜像名<br><br>也可以指定标签：docker pull redis:5 (例子)<br></code></pre></td></tr></table></figure><h4 id="4-删除镜像："><a href="#4-删除镜像：" class="headerlink" title="4.删除镜像："></a>4.删除镜像：</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">docker rmi 镜像名<br>也可以指定标签：docker rmi redis:5 (例子)<br></code></pre></td></tr></table></figure><h3 id="容器命令："><a href="#容器命令：" class="headerlink" title="容器命令："></a>容器命令：</h3><h4 id="1-查看命令："><a href="#1-查看命令：" class="headerlink" title="1.查看命令："></a>1.查看命令：</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http">docker ps  查看运行的容器<br>docker ps -a 查看所有的容器<br>docker ps -l 查看最后创建的容器<br>docker ps -l -n 最后几个容器<br>docker ps -f status:exited  过滤查询<br>不知道怎么操作就可以加 --help来获得帮助<br></code></pre></td></tr></table></figure><h4 id="2-创建与启动："><a href="#2-创建与启动：" class="headerlink" title="2.创建与启动："></a>2.创建与启动：</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs http">docker run 镜像名  创建容器<br>参数：<br>--name: 指定创建的容器名<br>-p:指定端口  （宿主机端口：容器端口）<br>-P：自动指定<br>-i: 运行容器<br>-t:表示容器启动后会进入其命令行界面<br>-v:可以指定目录映射关系，可以用多个-v 映射多个目录<br>-it：启动并进入，有些容器创建后不会进入，就可以这样启动后并进入<br></code></pre></td></tr></table></figure><h4 id="3-守护进程进入"><a href="#3-守护进程进入" class="headerlink" title="3.守护进程进入"></a>3.守护进程进入</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">docker run -di 镜像名<br>docker exec -it [自己取的镜像名，容器ID]  进入容器<br></code></pre></td></tr></table></figure><h4 id="4-停止启动容器"><a href="#4-停止启动容器" class="headerlink" title="4.停止启动容器"></a>4.停止启动容器</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">docker stop 容器名<br>docker start 容器名<br></code></pre></td></tr></table></figure><h4 id="5-文件拷贝："><a href="#5-文件拷贝：" class="headerlink" title="5.文件拷贝："></a>5.文件拷贝：</h4><p>可以把宿主机的拷贝到容器，也可以把容器的拷贝到宿主机</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">docker cp 需要拷贝的文件或目录 容器名称:容器目录<br>docker cp 容器名称:容器目录或文件 拷贝到宿的主机的位置<br></code></pre></td></tr></table></figure><h4 id="6-目录挂载："><a href="#6-目录挂载：" class="headerlink" title="6.目录挂载："></a>6.目录挂载：</h4><p>如果不挂载，当容器被删除后，数据也就被删除了，挂载后，宿主机的数据则还在</p><ol><li><p>指定目录挂载：<code>docker run -di -v 宿主机位置:容器目录 镜像名称</code>，docker会自动创建相应的容器目录，如果没在创建容器时挂载，后面想挂载可以通过修改配置文件来实现。</p><p><code>docker inspect 容器名 </code>可以查看所有的详细信息。</p></li><li><p>匿名挂载：<code>docker run -di -v 容器目录 镜像名称</code>,匿名挂载我们不用指定宿主机的位置，统一会被放到 <code>/var/lib/docker/volumes</code> 中，它会自动生成一个随机名称的目录，如果匿名挂载过多时，可以通过<code>docker inspect 容器名</code>来查看被挂载时随机生成的名字。</p></li><li><p>具名挂载：<code>docker run -di -v 宿主机中的目录名字:容器目录 镜像名称</code>,和上面一样会被放到<code>/var/lib/docker/volumes</code>中，不过这次可以指定名字</p></li><li><p>设置权限（只读&#x2F;读写，有时我们不希望容器在内部操作，就只允许宿主机操作，就可以挂只读），<code>docker run -di -v 容器目录:ro/rw 镜像名称</code> 只读&#x2F;读写</p></li><li><p>继承：<code>--volumes-from 被继承的容器名:ro/rw</code>，可以继承之前容器挂载的目录</p></li><li><p>查看容器ip地址：<code>docker inspect 容器名称</code></p></li><li><p>删除容器：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">docker rm 容器名称|容器ID<br>docker rm 容器名称|容器ID 容器名称|容器ID 容器名称|容器ID<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>打怪升级</category>
      
      <category>搞定docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>⚒认证与授权--cookie|session|token|JWT</title>
    <link href="/2022/07/19/%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/"/>
    <url>/2022/07/19/%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<p>用户认证与授权是一个系统最基本的功能，下面我们一起了解下常见的解决方案的特性与他们相互间的差别，最后是JWT在Go上的使用案例。</p><span id="more"></span><h1 id="😀认证与授权："><a href="#😀认证与授权：" class="headerlink" title="😀认证与授权："></a>😀认证与授权：</h1><blockquote><p>常见的解决方案有cookie、session、token</p><p>在知乎上看到有人用了一个很秒的例子来描述这三个东西👍：在学校或公司，入学入职的那一天，会录入你的身份、账户信息，然后给你发个卡，今后在园区内，你的门禁、打卡、消费都只需要这张卡。</p></blockquote><h2 id="😁Cookie："><a href="#😁Cookie：" class="headerlink" title="😁Cookie："></a>😁Cookie：</h2><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>保存在客户端</li><li>不可跨域，每个Cookie会被绑定在单一域名下，无法在别的域名下使用</li></ul><h3 id="属性（1-⑥）："><a href="#属性（1-⑥）：" class="headerlink" title="属性（1+⑥）："></a>属性（1+⑥）：</h3><ul><li><p><strong>键值对</strong>：在Cookie中设置自定义的值，eg：<code>id=&quot;123456&quot;</code></p></li><li><p><strong>Cookie的域：</strong>在响应首部的Set-Cookie添加domain属性，来控制哪些站点能看到这个Cookie。eg：<code>Set-Cookie: name=&quot;Peng&quot;;domain=&quot;m.zhuanzhuan.58.com&quot;</code>，如果用户访问的是m.zhuanzhuan.58.com，或者m.zhuanzhuan.58.com&#x2F;user 则都可以，而如果是<a href="http://www.aaa.com(非zhuanzhuan.58.com)就不会看到这个cookie./">www.aaa.com(非zhuanzhuan.58.com)就不会看到这个Cookie。</a></p></li><li><p><strong>Cookie的路径Path：</strong>通过添加Path属性可以在特定的路径（这个属性设置的Url和带有这个前缀的Url路径都是有效的）下获得Cookie。</p></li><li><p><strong>Secure：</strong>设置了属性Secure，<code>Set-Cookie: name=&quot;Peng&quot;;domain=&quot;m.zhuanzhuan.58.com&quot;;Secure</code>，则这个Cookie只有在https协议加密的情况下才会发送给客户端</p></li><li><p>**HTTP only:**设置该属性后，则无法通过JS脚本来获得Cookie。</p></li><li><p><strong>Expires：</strong>设置Cookie的过期时间，GMT格式，到达该时间后Cookie会自动失效。</p></li><li><p><strong>max-age：</strong>在HTTP1.1中定义的，优先级高于Expires，表示Cookie的有效期，单位为秒，当值为正数时表示再过去n秒后该Cookie失效，当值为负数时，表示该Cookie为临时Cookie，在浏览器退出后该Cookie则失效，如果值为0则表示取消该Cookie。默认为-1。</p></li></ul><h3 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3Eol34Ohsn3ibXzVibBrSYHMczem1p6fiah73MPbASqSThJhoWAjia6rDcNbTCoQniaByxUIpEZniboAvaOw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1"></p><ol><li>用户输入用户名，密码（或其它认证方式）到服务器。</li><li>服务器认证成功后，就会利用Set-cookie的头部字段，将Cookie返回给客户端。</li><li>客户端下一次发起请求时，请求首部则会带上这个Cookie</li><li>服务器通过客户端发来的Cookie，便能知道发出该请求的用户，并决定是否通过</li></ol><h2 id="Session-😜"><a href="#Session-😜" class="headerlink" title="Session:😜"></a>Session:😜</h2><blockquote><p>对应于Session就是，其实你的卡上只存了一个id（可能是你的学号），刷的时候物业系统就会去查你的信息、账户，再决定“这个门你能不能进”“这个鸡腿去哪个账户扣钱”</p></blockquote><h3 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h3><ul><li>有重要信息（用户信息，Session状态等）的Session保存在服务器中，而会生成一个SessionId给客户端保存。</li><li>一般基于Cookie实现。</li></ul><h3 id="过程：-1"><a href="#过程：-1" class="headerlink" title="过程："></a>过程：</h3><p><img src="https://pic3.zhimg.com/80/v2-18bd4826103a35c3ef4d99742ad1bd12_1440w.jpg"></p><ol><li>用户输入用户名，密码（或其它认证方式）到服务器。</li><li>服务器认证成功后，在服务器端生成一个Session，保存在文件或者内存或缓存中，然后返回给客户端一个SessionId，SessionId会被客户端保存在Cookie上。</li><li>客户端下一次发起请求时，会自动带上Cookie，Cookie中会携带SessionId。</li><li>服务器接受到Cookie后，检查SessionId的有效性后，决定是否通过。</li></ol><h2 id="😋Token："><a href="#😋Token：" class="headerlink" title="😋Token："></a>😋Token：</h2><blockquote><p>对应于Token就是，在比较早之前，在没有校园卡技术以前，我们都靠学生证。门卫小哥直接对照我和学生证上的脸，确认学生证有效期、年纪等信息，就可以放行了。</p></blockquote><h3 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h3><ul><li>服务器不用再存储信息，减少服务器的压力。</li><li>Token保存在客户端，服务器只需检验Token的有效性</li></ul><h3 id="过程：-2"><a href="#过程：-2" class="headerlink" title="过程："></a>过程：</h3><p><img src="https://pic2.zhimg.com/80/v2-45c53c27a611d78c489a25f3496c7625_1440w.jpg"></p><ol><li>用户输入用户名，密码（或其它认证方式）到服务器。</li><li>服务器认证成功后，在服务器端生成一个Token，这里展示的是通过Cookie传回token,token里面包括了基本的用户信息。</li><li>客户端保存Token后，下次请求时会带上Token</li><li>服务器检验Token的有效性后，决定是否通过。</li></ol><p><strong>考虑到编码，防篡改等问题我们直接讲Token的一个实践JWT（Json Web Token）</strong></p><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT:"></a>JWT:</h2><p><img src="C:\Users\57849\AppData\Roaming\Typora\typora-user-images\image-20220722172608892.png" alt="image-20220722172608892"></p><center>一个完整的JWT的结构</center><h3 id="特点：-3"><a href="#特点：-3" class="headerlink" title="特点："></a>特点：</h3><ul><li>继承上面Token的优势，进一步地改善了编码，防篡改的问题。</li></ul><h3 id="三大组成："><a href="#三大组成：" class="headerlink" title="三大组成："></a>三大组成：</h3><p><strong>Header：</strong></p><p>Header主要保存了这个JWT的元数据，主要就是两个部分:<code>alg</code>和<code>typ</code>，<code>alg</code>属性表示签名的算法(algorithm),默认是HMAC SHA256 简写为HS256，<code>typ</code>表示Token的类型，JWT则为JWT。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;alg&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;HS256&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;typ&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;JWT&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>Payload：</strong></p><p>Payload则是存放数据的地方，JWT规定了7个官方字段，供选用。</p><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul><p>我们也可以自己加入一些私有字段。</p><p><strong>这里要注意的是：</strong>虽说我们后面有签名的环节，但那只是为了防止篡改，上面两个部分我们采用的base64UrlEncode编码方法是可以通过防编码出来的，所以重要数据不能放在Payload中。</p><p><strong>Signature:</strong></p><p>在上面Token的部分你可能就有察觉到，我们这次是将用户的信息放在Token里面保存到Cookie中的，这里就存在我们的Token信息被读取，被人用来伪装的可能性，所以就加了签名这一步骤，服务器自己保存了一把密钥，这样就算别人窃取了信息，也无法进行签名，进行伪装。</p><p><strong>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户</strong>。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">HMACSHA256</span>(<br>  base64UrlEncode(header) + &quot;.&quot; +<br>  <span class="hljs-built_in">base64UrlEncode</span>(payload),<br>  secret)<br></code></pre></td></tr></table></figure><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（<code>.</code>）分隔，就可以返回给用户。</p><h3 id="过程：-3"><a href="#过程：-3" class="headerlink" title="过程："></a>过程：</h3><ol><li>用户输入用户名，密码（或其它认证方式）到服务器。</li><li>服务器认证成功后，生成一个JWT，返回给客户端，客户端将会保存JWT。</li><li>客户端下一次发起请求时会带上JWT</li><li>服务器用自己的私钥解析客户端发送过来的JWT，决定是否通过</li></ol><h2 id="JWT在Go中的使用案例："><a href="#JWT在Go中的使用案例：" class="headerlink" title="JWT在Go中的使用案例："></a>JWT在Go中的使用案例：</h2><p>首先go get 一下✨</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> get github.com/dgrijalva/jwt-<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><h3 id="获取JWT："><a href="#获取JWT：" class="headerlink" title="获取JWT："></a>获取JWT：</h3><p>根据前面的讲解，我们已经了解到JWT的数据结构，它就是由两个编码过的json文件加一个签名组成。那我们要做的就是拼装这三个部分。</p><p><strong>Header：</strong></p><p>这个部分包含两个字段，这两个字段都不用我们填，会由你选择的签名算法自动填写好。</p><p><strong>Payload：</strong>（获得Token对象）</p><p>首先我们看下<code>jwt.StandardClaims</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">type</span> StandardClaims <span class="hljs-keyword">struct</span> &#123;<br>Audience  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;aud,omitempty&quot;`</span><br>ExpiresAt <span class="hljs-type">int64</span>  <span class="hljs-string">`json:&quot;exp,omitempty&quot;`</span><br>Id        <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;jti,omitempty&quot;`</span><br>IssuedAt  <span class="hljs-type">int64</span>  <span class="hljs-string">`json:&quot;iat,omitempty&quot;`</span><br>Issuer    <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;iss,omitempty&quot;`</span><br>NotBefore <span class="hljs-type">int64</span>  <span class="hljs-string">`json:&quot;nbf,omitempty&quot;`</span><br>Subject   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;sub,omitempty&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这就是我们上面所说的官方提供的几个可选的字段，在Go中我们使用常用的方法–结构体组合来实现添加我们想要的字段，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Claims <span class="hljs-keyword">struct</span> &#123;<br>UserId <span class="hljs-type">int64</span><br>jwt.StandardClaims<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们把这些字段填充完整，就可以得到Token了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">claims := &amp;Claims&#123;<br>    UserId: user.UserInfoId,<br>    StandardClaims: jwt.StandardClaims&#123;<br>        ExpiresAt: expirationTime.<span class="hljs-built_in">Unix</span>(),<br>        IssuedAt:  time.<span class="hljs-built_in">Now</span>().<span class="hljs-built_in">Unix</span>(),<br>        Issuer:    <span class="hljs-string">&quot;douyin_pro_131&quot;</span>,<br>        Subject:   <span class="hljs-string">&quot;L_B__&quot;</span>,<br>    &#125;&#125;<br>token := jwt.<span class="hljs-built_in">NewWithClaims</span>(jwt.SigningMethodHS256, claims)<br><br></code></pre></td></tr></table></figure><p><strong>Signature:</strong></p><p>上面获得Token对象后，调用<code>jwt.SignedString()</code>，并传入自己服务器保存的密钥（一个 <code>byte[]</code>），就会自动完成Signature部分的编写和对上面三个部分分别进行base64url编码，再整合成一个最终的字符串返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">jwtKey:=[]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;我的密钥&quot;</span>)<br>tokenString,err:=token.SignedString(jwtKey)<br></code></pre></td></tr></table></figure><h3 id="验证JWT："><a href="#验证JWT：" class="headerlink" title="验证JWT："></a>验证JWT：</h3><p>以常用的Web框架Gin为例，我们会把这个部分放到中间件那里使用。</p><p>解析Token：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParseToken</span><span class="hljs-params">(tokenString <span class="hljs-type">string</span>)</span></span> (*MyClaims, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 验证token是否是我们自己签发的</span><br>token, err := jwt.ParseWithClaims(tokenString, &amp;MyClaims&#123;&#125;, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(token *jwt.Token)</span></span> (i <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> jwtKey, <span class="hljs-literal">nil</span><br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> claims, ok := token.Claims.(*MyClaims); ok &amp;&amp; token.Valid &#123; <span class="hljs-comment">// 校验token</span><br><span class="hljs-keyword">return</span> claims, <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;invalid token&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>用于中间件中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">JWTAuthMiddleware</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">// 客户端携带Token有三种方式 1.放在请求头 2.放在请求体 3.放在URI</span><br><span class="hljs-comment">// 这里假设Token放在Header的Authorization中，并使用Bearer开头</span><br><span class="hljs-comment">// 这里的具体实现方式要依据你的实际业务情况决定</span><br>authHeader := c.Query(<span class="hljs-string">&quot;token&quot;</span>)<br>fmt.Println(authHeader)<br><span class="hljs-keyword">if</span> authHeader == <span class="hljs-string">&quot;&quot;</span> &#123;<br>authHeader = c.PostForm(<span class="hljs-string">&quot;token&quot;</span>)<br>fmt.Println(authHeader)<br>&#125;<br><br><span class="hljs-keyword">if</span> authHeader == <span class="hljs-string">&quot; &quot;</span> &#123;<br>c.JSON(http.StatusOK, service.UserResponse&#123;<br>Response: service.Response&#123;StatusCode: <span class="hljs-number">1</span>&#125;,<br>&#125;)<br>c.Abort()<br><span class="hljs-keyword">return</span><br>&#125;<br><br>mc, err := app.ParseToken(authHeader)  <span class="hljs-comment">//就是调用上面的ParseToken</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>c.JSON(http.StatusOK, service.UserResponse&#123;<br>Response: service.Response&#123;StatusCode: <span class="hljs-number">1</span>&#125;,<br>&#125;)<br>c.Abort()<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(mc.UserId)<br><span class="hljs-comment">// 将当前请求的username信息保存到请求的上下文c上</span><br>c.Set(<span class="hljs-string">&quot;user_id&quot;</span>, mc.UserId)<br>c.Next() <span class="hljs-comment">// 后续的处理函数可以用过c.Get(&quot;user_id&quot;)来获取当前请求的用户信息</span><br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="JWT的一些问题："><a href="#JWT的一些问题：" class="headerlink" title="JWT的一些问题："></a>JWT的一些问题：</h3><ol><li><p>JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p></li><li><p>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p></li><li><p>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>打怪升级</category>
      
      <category>搞定docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The First Blog</title>
    <link href="/2022/06/28/The-First-Blog/"/>
    <url>/2022/06/28/The-First-Blog/</url>
    
    <content type="html"><![CDATA[<h1 id="😍全军出击🎉"><a href="#😍全军出击🎉" class="headerlink" title="😍全军出击🎉"></a>😍全军出击🎉</h1><h2 id="革命尚未成功，还需继续努力🎖"><a href="#革命尚未成功，还需继续努力🎖" class="headerlink" title="革命尚未成功，还需继续努力🎖"></a>革命尚未成功，还需继续努力🎖</h2>]]></content>
    
    
    <categories>
      
      <category>陈词滥调</category>
      
      <category>第一篇博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FirstBlog</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
