<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>⛽常见排序算法与实现📣</title>
    <link href="/2022/08/09/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/08/09/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>学习完数据结构与算法的课已经有很长时间了，排序算法忘的七七八八，好好复习一下吧</p><p>面对这道高频面试题，一定得好好理解下。包括了导航流程和TCP连接</p><span id="more"></span><h1 id="⛽常见排序算法与实现📣"><a href="#⛽常见排序算法与实现📣" class="headerlink" title="⛽常见排序算法与实现📣"></a>⛽常见排序算法与实现📣</h1><h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><p>排序算法可以分为两大类：<strong>比较类排序</strong>和<strong>非比较类排序</strong></p><p><strong>比较类排序：</strong>通过比较来决定元素间的相对次序，由于其时间复杂度无法突破O(nlog<del>2</del>n)，因此也称为非线性时间比较类排序。</p><p><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 </p><p>当前工业界和面试时考察的比较多的都是比较类排序，所以这次我们重点来学习下比较类排序中常见的两类排序：<strong>初级排序</strong>和<strong>高级排序</strong></p><p><img src="https://pic.rmb.bdstatic.com/bjh/839422a30a824720938d3e4a35f2f5d1.png" alt="常见排序的时间复杂度"></p><p><strong>初级排序：</strong>平均时间复杂度为O(n^2^)的排序，这些的重要性相对不高，多以了解为主。</p><p><strong>高级排序</strong>：平均时间复杂度为O(nlog<del>2</del>n)的排序，在公司面试和使用这方面主要就是这几个，优先级是最高的，我们一定要理解他们的原理并且自己能够实现这类排序算法。</p><h2 id="初级排序："><a href="#初级排序：" class="headerlink" title="初级排序："></a>初级排序：</h2><blockquote><p>我们主要熟悉下选择排序、插入排序、冒泡排序</p></blockquote><h3 id="选择排序："><a href="#选择排序：" class="headerlink" title="选择排序："></a>选择排序：</h3><blockquote><p>平均时间复杂度：O(n^2^)</p><p>最优时间复杂度：O(n^2^)  因为每次都要完整地遍历一次无序数组</p><p>最差时间复杂度：O(n^2^) 一样的，每次都是要完整地遍历一次无序数组</p><p>空间复杂度：O(1)  不用开辟新数组</p></blockquote><p>一句话理解：在乱序数组中遍历，找到最小元素，放到有序数组的最后面，如此反复最后就能得到有序数组。步骤就是每次都遍历一遍无序数组，找到最小元素，然后与无序数组的第一个元素交换（原理上是放到有序数组的下一个元素，其实也就是无序数组的第一个元素）</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h543464jifg20mj06w7l2.gif" alt="选择排序"></p><p><strong>代码实现（Go）：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arr)<span class="hljs-number">-1</span>; i++ &#123; <span class="hljs-comment">//每次遍历无序数组的第一个元素的位置</span><br>min := arr[i]<br>pos := i<br>        <span class="hljs-comment">//找到最小元素</span><br><span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(arr); j++ &#123;<br><span class="hljs-keyword">if</span> arr[j] &lt; min &#123;<br>min = arr[j]<br>pos = j<br>&#125;<br>&#125;<br>        <span class="hljs-comment">//与无序数组的第一个元素交换</span><br> arr[i],arr[pos]=arr[pos],arr[i]<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插入排序："><a href="#插入排序：" class="headerlink" title="插入排序："></a>插入排序：</h3><blockquote><p>平均时间复杂度：O(n^2^)</p><p>最优时间复杂度：O(n)  数组为本身有序的情况</p><p>最差时间复杂度：O(n^2^) 逆序的情况，每次都要一次与前面有序数组完整的比较</p><p>空间复杂度：O(1)  不用开辟新数组</p></blockquote><p>一句话理解：将乱序数组中的元素插入到有序数组中。步骤是每次选取无序数组的第一个元素从有序数组的最后一个元素开始一一判断，找到位置后，腾出插入位置后插入。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5436dwi6zg20mj0e113f.gif" alt="插入排序"></p><p><strong>代码实现（Go）：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span>&#123;<br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(arr);i++&#123;  <span class="hljs-comment">// 这里每次的i为乱序数组的第一个元素的下标</span><br><span class="hljs-keyword">var</span>(<br>j <span class="hljs-type">int</span><br>temp=arr[i]  <span class="hljs-comment">//后面要移动元素腾出插入的空间，所以要先保存下来</span><br>)<br><span class="hljs-comment">//查找插入位置</span><br><span class="hljs-keyword">for</span> j=i<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--&#123;   <span class="hljs-comment">// 这里的j是每次的有序数组的最后一个元素的下标</span><br><span class="hljs-keyword">if</span> arr[i]&lt;arr[j]&#123; <br><span class="hljs-keyword">continue</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">break</span>  <span class="hljs-comment">//j+1就是要插入的位置了</span><br>&#125;<br>&#125;<br><span class="hljs-comment">//移动位置，腾出插入空间</span><br><span class="hljs-keyword">for</span> ;i&gt;j+<span class="hljs-number">1</span>;i--&#123;<br>arr[i]=arr[i<span class="hljs-number">-1</span>]<br>&#125;<br>arr[j+<span class="hljs-number">1</span>]=temp<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="冒泡排序："><a href="#冒泡排序：" class="headerlink" title="冒泡排序："></a>冒泡排序：</h3><blockquote><p>平均时间复杂度：O(n^2^)</p><p>最优时间复杂度：O(n^2^)  数组为本身有序的情况</p><p>最差时间复杂度：数组为逆序的状态</p><p>空间复杂度：O(1)  不用开辟新数组</p></blockquote><p>一句话理解：每进行一次整个数组（除去浮出水面的）两两交换，就一定会有至少一个当前剩余数组中的最大元素会浮出水面。步骤就是在无序中，不断重复的进行一趟两两比较交换，每次会浮出一个至多个元素，随着浮出元素的增多，每次比较的次数也相应减少。</p><p><strong>代码实现（Go）：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span>&#123;<br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(arr);i++&#123;<br><span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;<span class="hljs-built_in">len</span>(arr)-i;j++&#123;<br><span class="hljs-keyword">if</span> arr[j]&lt;arr[j<span class="hljs-number">-1</span>]&#123;<br>arr[j<span class="hljs-number">-1</span>],arr[j]=arr[j],arr[j<span class="hljs-number">-1</span>]<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高级排序："><a href="#高级排序：" class="headerlink" title="高级排序："></a>高级排序：</h2><h3 id="快速排序："><a href="#快速排序：" class="headerlink" title="快速排序："></a>快速排序：</h3><blockquote><p>平均时间复杂度：O(nlog<del>2</del>n)</p><p>最优时间复杂度：O(nlog<del>2</del>n)  选取的pivot可以，每次都能把数组分成等份的两份</p><p>最差时间复杂度：O(n^2^)选取的pivot不行，分出的数组的元素数量严重不均等</p><p>空间复杂度：O(1)  不用开辟新数组</p></blockquote><p>一句话理解，运用了分治的思想，每次我们都选取一个pivot，将原数组分成左半边数组和右半边数组，左子数组都小于pivot，右子数组都大于pivot，再递归处理这两个左右子数组。步骤就是，我们这里是为了方便选用了数组的最后一个元素为pivot，真实应用场景下可能会根据数据的大致情况选择相应的pivot来提高效率，counter的值理解为经过分类后小于pivot的左子数组的最后一个元素位置加1，所以我们遍历过程中遇到比pivot小的元素就都和counter交换，扩充左子数组，遍历完成后，counter位置始终代表左子数组的下一个位置，所以最后pivot直接与counter交换位置，即能得到分好类的左右子数组。再递归处理左右子数组。</p><p>再记一下自己疑惑的点（不知道为啥疑惑😓）</p><p><strong>剩下两个的情况是怎么结束的？</strong></p><ol><li><p>倒序的情况，按照惯例，pivot设为第二个元素，遍历完比它小的左子数组的下一位即为第一个元素的位置（没有比它小的元素，counter没变），交换后就正序了，进入下面的情况。</p></li><li><p>正序的情况，按照惯例，pivot设为第二个元素，遍历后只有一个元素比它小，比它小的左子数组的下一位即为第二个元素的位置，这时我们再递归处理这两个子数组，我们先看右子数组，我们的左边界会设为counter+1，有边界还是high没有变，而此时counter+1已经大于high了，所以就结束了，我们再看左子数组，此时就是剩余一个元素的情况了。</p></li><li><p>剩余一个元素的情况：判断后low等于high，结束</p></li></ol><p><strong>复杂度为什么O(nlog<del>2</del>n)：</strong>首先是前面的n，前面的n代表是每一层在做<code>partition</code>的时候都要处理“n”次，log<del>2</del>n代表调用栈有多高，最坏情况，调用栈的高度就为n，所以复杂度为O(n^2^)。</p><p><strong>代码实现（Go）：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>,low <span class="hljs-type">int</span>,high <span class="hljs-type">int</span>)</span></span>&#123;<br><span class="hljs-keyword">if</span> low&gt;=high&#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(arr[low:high+<span class="hljs-number">1</span>])<br>pivot:=partition(arr,low,high)<br>quicksort(arr,low,pivot<span class="hljs-number">-1</span>)<br>quicksort(arr,pivot+<span class="hljs-number">1</span>,high)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partition</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>,begin,end <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>&#123;<br>pivot,counter:=arr[end],begin<br><span class="hljs-keyword">for</span> i:=begin;i&lt;end;i++&#123;<br><span class="hljs-keyword">if</span> arr[i]&lt;pivot&#123;<br>fmt.Println(arr[i],arr[counter])<br>arr[i],arr[counter]=arr[counter],arr[i]<br>counter++<br>&#125;<br>&#125;<br>arr[counter],arr[end]=arr[end],arr[counter]<br><span class="hljs-keyword">return</span> counter<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="归并排序："><a href="#归并排序：" class="headerlink" title="归并排序："></a>归并排序：</h3><blockquote><p>平均时间复杂度：O(nlog<del>2</del>n)</p><p>最优时间复杂度：O(nlog<del>2</del>n)  归并排序每次都要分到最小，再合并，所以变化不大</p><p>最差时间复杂度：同上</p><p>空间复杂度：O(n)  需要开辟新数组</p></blockquote><p>一句话理解，先切割成n个子序列，最小为1，然后再合并子序列（归并），在合并的过程中会使这两个子序列合并成整体有序的子序列，不断将整体有序的子序列合并，并且合并过程夹有排序，最终就能得到有序的序列。步骤就是，可以理解为一个后序遍历，先把数组一直切分，“在根结点”合并，把左右子树中整体有序的子序列合并就能最终得到整体有序的序列</p><p><strong>复杂度为什么O(nlog<del>2</del>n)：</strong>先说后面的log<del>2</del>n，归并的调用栈就固定为log<del>2</del>n了，不会像快排那样有变化，而前面的n代表着就是在每一层合并的时候都要处理“n”次。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h543b37d25g20mj0e1qcv.gif" alt="归并排序"></p><p><strong>代码实现（Go）：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, low, high <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> low &gt;= high &#123;  大于的情况是越界了，等于的情况是不用再分了<br><span class="hljs-keyword">return</span><br>&#125;<br>mid := (low + high) &gt;&gt; <span class="hljs-number">1</span><br>fmt.Println(mid)<br>MergeSort(arr, low, mid<span class="hljs-number">-1</span>)<br>MergeSort(arr, mid+<span class="hljs-number">1</span>, high)<br>Merge(arr, low, high, mid)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Merge</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, low, high, mid <span class="hljs-type">int</span>)</span></span> &#123;<br>left, right := low, mid+<span class="hljs-number">1</span><br>TempArr := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, high-low+<span class="hljs-number">1</span>)<br>k := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> left &lt;= mid &amp;&amp; right &lt;= high &#123;<br><span class="hljs-keyword">if</span> arr[left] &lt; arr[right] &#123;<br>TempArr[k] = arr[left]<br>k++<br>left++<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>TempArr[k] = arr[right]<br>k++<br>right++<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> left &lt;= mid &#123;<br>TempArr[k] = arr[left]<br>k++<br>left++<br>&#125;<br><span class="hljs-keyword">for</span> right &lt;= high &#123;<br>TempArr[k] = arr[right]<br>k++<br>right++<br>&#125;<br><span class="hljs-built_in">copy</span>(arr[low:high+<span class="hljs-number">1</span>], TempArr)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆排序："><a href="#堆排序：" class="headerlink" title="堆排序："></a>堆排序：</h3><blockquote><p>平均时间复杂度：O(nlog<del>2</del>n)</p><p>最优时间复杂度：O(nlog<del>2</del>n)  堆排序时间主要在维护堆上，和数组情况无关</p><p>最差时间复杂度：同上</p><p>空间复杂度：O(n)  需要开辟新数组</p></blockquote><p>一句话理解：用序列先维护一个堆(nlog<del>2</del>n)，再用堆弹出堆顶元素到新的数组中，完成排序。堆的维护我们常用语言自带的方法来实现，以Go为例就是实现接口的方法，它的底层实现里面默认弹出时使用的方法是堆顶与最后一个元素交换，弹出最后一个元素，再进行堆的维护，所以我们自己要实现的pop方法就是要弹出最后一个元素，Push方法也一样，默认放在最后一个元素，再进行堆的维护</p><p><strong>复杂度为什么O(nlog<del>2</del>n)：</strong>在维护堆时，堆的特性每次的插入和删除都需要log<del>2</del>n，而要插入n个元素，所以为O(nlog<del>2</del>n)</p><p><strong>代码实现（Go）：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myHeap []<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(heap *myHeap)</span></span>Len()<span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span>(<span class="hljs-built_in">len</span>(*heap))&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(heap *myHeap)</span></span>Less(i,j <span class="hljs-type">int</span>)<span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> (*heap)[i]&lt;(*heap)[j] &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(heap *myHeap)</span></span>Swap(i,j <span class="hljs-type">int</span>) &#123;(*heap)[i],(*heap)[j]=(*heap)[j],(*heap)[i]&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(heap *myHeap)</span></span>Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;*heap=<span class="hljs-built_in">append</span>(*heap,x.(<span class="hljs-type">int</span>))&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(heap *myHeap)</span></span>Pop()<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br><span class="hljs-keyword">var</span> x=(*heap)[<span class="hljs-built_in">len</span>(*heap)<span class="hljs-number">-1</span>] <br>*heap=(*heap)[<span class="hljs-number">0</span>:<span class="hljs-built_in">len</span>(*heap)<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>myheap:=&amp;myHeap&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>&#125;<br>a:=<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(*myheap))<br>heap.Init(myheap)<br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(a);i++&#123;<br>a[i]=heap.Pop(myheap).(<span class="hljs-type">int</span>)<br>&#125;<br>fmt.Println(a)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速排序与归并排序的比较："><a href="#快速排序与归并排序的比较：" class="headerlink" title="快速排序与归并排序的比较："></a>快速排序与归并排序的比较：</h3><p>快速排序和归并排序的平均时间复杂度都是O(nlog<del>2</del>n)，而快速排序的最坏情况是O(n^2^)，但快排还是优于归并，快排优于归并的地方在哪？</p><ol><li><p>快速排序中效率的主要来源之一是引用位置，在引用位置中，计算机硬件经过优化，因此访问彼此相邻的内存位置往往比访问分散在整个内存中的内存位置更快。quicksort中的分区步骤通常具有很好的局部性，因为它访问前面和后面附近的连续数组元素。因此，快速排序往往比其他排序算法（如heapsort）执行得更好，尽管它通常执行大致相同数量的比较和交换，因为在heapsort的情况下，访问更加分散。</p><p>也就是说，一个原因是计算机硬件经过优化，访问彼此相邻的内存位置往往比访问分散在整个内存中的内存位置更快，所以快速排序我们在划分数组的时候，元素都是相邻的，而归并排序在合并的时候是元素较为分散，所以在这一点上快排优于归并</p></li><li><p>另一个普遍都知道的原因就是快排我们可以直接在原数组上操作，而归并排序我们在合并的时候需要重新开辟数组（空间复杂度为O(n)），还要进行多次的赋值的操作，所以在这一点上让快排优于归并。</p></li></ol><p><strong>和堆排序的相比：</strong>在维护堆的时候，堆排里面有大量近乎无效的比较，因为被拿到堆顶的那个元素几乎肯定是很小的，而靠近堆顶的元素又几乎肯定是很大的，将一个很小的数和一个很大的数比较，结果几乎肯定是“小于”的，这就意味着问题的可能性只被排除掉了很小一部分。</p><p>所以堆排虽然和快排一样复杂度都是O(nlog<del>2</del>n)但堆排复杂度的常系数更大</p>]]></content>
    
    
    <categories>
      
      <category>站在巨人的肩膀上</category>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>🤯从输入URL到页面展示，这中间发生了什么？🤬</title>
    <link href="/2022/08/07/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%EF%BC%8C%E8%BF%99%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <url>/2022/08/07/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%EF%BC%8C%E8%BF%99%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<p>面对这道高频面试题，一定得好好理解下。包括了导航流程和TCP连接</p><span id="more"></span><h1 id="从输入URL到页面展示，这中间发生了什么？"><a href="#从输入URL到页面展示，这中间发生了什么？" class="headerlink" title="从输入URL到页面展示，这中间发生了什么？"></a>从输入URL到页面展示，这中间发生了什么？</h1><p><img src="https://static001.geekbang.org/resource/image/71/e3/714208d4e10499868688361130d1d2e3.jpg"></p><h2 id="三个进程："><a href="#三个进程：" class="headerlink" title="三个进程："></a>三个进程：</h2><p><strong>浏览器进程：</strong>主要负责用户的交互、子进程的控制和文件存储的服务</p><p><strong>网络进程</strong>：主要负责为浏览器进程和渲染进程提供下载功能</p><p><strong>渲染进程：</strong>对接受的javascript，css，html、图片等资源解析成可以显示和交互的界面</p><h2 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h2><ol><li>用户输入URL回车后，浏览器进程先判断输入的内容是否为搜索内容，是的话就会根据浏览器的默认搜索引擎，组成新的带有搜索内容的URL。如果输入的内容符合URL规则，那就会选用相应的协议，一般现在的网站都是HTTPS，组成新的URL。</li><li>浏览器进程会通过进程间通信（IPC），向网络进程发送URL请求，由网络进程真正进行URL请求。</li><li>获得URL后，网络进程不是直接就开始请求的步骤，而是先查找本地缓存是否缓存了该资源。如果有找到缓存资源则结束请求，直接把资源返回给浏览器进程。没有再进行接下来的步骤。</li><li>URL请求第一步是找目标服务器的地址和端口号，也就是域名解析，首先会在本地的域名解析缓存中查找是否有该域名的缓存记录，有则会直接使用该地址和端口号，本地缓存没有再会向DNS服务器发送请求，获得服务器地址和端口号。如果获取到的只有IP地址，则会使用默认的端口号，HTTP默认是80而HTTPS默认的是HTTPS。如果是HTTPS协议，这里还有一个步骤：建立TLS连接。</li><li>接下来就是使用IP地址与服务器进行TCP连接</li></ol><h3 id="TCP连接："><a href="#TCP连接：" class="headerlink" title="TCP连接："></a>TCP连接：</h3><p><img src="https://pic.rmb.bdstatic.com/bjh/d5169b6fc8b3fad501c31afb19f037ff.jpeg" alt="TCP结构"></p><h4 id="😊三次握手："><a href="#😊三次握手：" class="headerlink" title="😊三次握手："></a>😊三次握手：</h4><p><strong>第一次握手：</strong> 此次过程为TCP客户端发送一个TCP报文段，里面将首部的同步位SYN设为1，表明该报文段为连接请求报文段，并为序号字段（seq）设置一个值x，（这个序号会给消耗掉，即接下来的报文段要用x+1，因为TCP规定SYN设置为1后不可携带数据，但会消耗掉一个序号）作为TCP客户端所选择的初始序号，并进入同步已发送阶段。</p><p><strong>第二次握手：</strong>TCP服务器端接受到客户端发来请求连接报文段后，如果同意连接，会往客户端再发送一个TCP报文段，里面将首部的同步位SYN和确认为ACK都设为1，表明该报文段为连接请求确认报文段，并为序号字段（seq）设置一个值y，作为TCP服务器进程所选择的初始序号，确认号字段设为x+1，这是对TCP客户端所选择的初始序号的确认。同时进入同步己接受阶段</p><p><strong>第三次握手：</strong>TCP客户端接受到请求连接确认报文段后，会往服务器端再发送一次TCP报文段，里面将确认位ACK设为1，表明这是一个普通的TCP确认报文段，并将序号设置为x+1（TCP规定普通的确认报文段可以携带数据，如果这次报文段中有携带数据那这个序号将会给消耗掉，如果没有携带，那么下一次发送TCP请求时则还可以继续用这个x+1），确认号设置为y+1,这是对服务器的初始序号的确认。发送完成后，客户端进入连接已建立状态，服务器接收到确认报文段后也进入连接已建立状态。</p><p><strong>为什么要三次，两次不行吗？</strong></p><p>这是因为TCP为了保证连接的可靠性，始终认为网络层是不可靠的，如果是两次握手那TCP服务器端在发送完TCP请求连接确认报文段后就会进入连接已建立状态，这里就存在一种可能，在服务器端接收到请求连接报文段前，因为网络问题，客户端一直没接受到请求连接确认报文段已经发送了好几个请求连接报文段，而等到TCP服务器端接受到TCP请求连接报文段，TCP客户端接受到请求连接报文段，并完成了数据传输，四次挥手断开连接后，之前那些没能到达服务器端的TCP请求连接报文段又姗姗来迟到达了服务器端，这是我们如果我们采用的两次握手，服务器端就会进入连接已建立状态，而因为客户端已经认为这次连接已经完成了，那这个状态就会一直尬等着，没人传数据也没人告诉他断开，这样就导致占用了服务器端许多的资源。</p><h4 id="🤗四次挥手："><a href="#🤗四次挥手：" class="headerlink" title="🤗四次挥手："></a>🤗四次挥手：</h4><p>客户端和服务器端都可以发起断开连接，这里以客户端为例</p><p><strong>第一次挥手：</strong>此时客户端会发送一个TCP报文段，里面将终止位FIN和确认位ACK设置为1，表明该报文段为请求释放报文段，并将序号设置为u（u等于最后一次客户端发送到服务器端的数据的最后一个字节的序号加1，并且TCP规定即使该请求释放报文段不携带数据也会消耗一个序号），确认号设置为v(v等于客户端之前接受到的数据的最后一个字节的序号+1)，同时进入终止等待1状态</p><p><strong>第二次挥手：</strong>服务器端接受到连接释放字段后，再发送一个TCP报文段，里面将ACK设为1，表明该报文段为普通确认报文段，并将序号设置为v（与上面的v相等）确认号设置为u+1，并进入关闭等待状态。这时服务器端会通知应用层TCP客户端要断开与服务器端的连接，此时客户端到服务器端的这个方向的连接就释放了（由全双工变为半双工，客户端可以继续接受数据，但不可以发送数据了，这里别错误理解为不能发送任何东西了，只是不能依赖建立的通道可靠的发送数据，但是还是可以发送TCP报文段的），客户端接受到普通确认报文段后进入终止等待2状态。</p><p><strong>第三次挥手：</strong>等到应用层进程发送完数据后，它就会通知TCP服务器段进程关闭TCP连接，TCP服务端会再向客户端发送一个TCP报文段，里面将终止位FIN和确认位设置为1，表明该报文段为连接释放报文段，并将序号设置为w(w等于后来服务器端往客户端发送的剩余的数据的最后一个字节的序号+1)，确认号设置为u+1(对一次挥手的报文段的再次确认)，同时进入最后确认状态。</p><p><strong>第四次挥手：</strong>客户端收到连接释放字段后，再向服务器端发送一个TCP报文段，里面将确认位ACK设为1,表明该报文段为普通确认报文段，并将序号设置为u+1，确认号设为w+1，服务器端接受到该确认报文段后进入关闭状态，而客户端进入时间等待状态，只有等2MSL（Maximum Segment Lifetime，最长报文寿命）后进入关闭状态。</p><p><strong>为什么要等待：</strong>还是一样，TCP始终认为网络层是不可靠的，第四次挥手发送的TCP报文段可能因为某种原因未能到达服务器端，而服务器端没接受到客户端的确认报文字段就会发起超时重传连接释放字段，而这时客户端已经关闭了，服务器端不可能再接受到确认报文字段，会一直进行超时重传，一直处于最后确认状态，而无法进入关闭状态。而且经过了这个2MSL时间，就可以使本次连接的所有字段都消失，保证下一次连接不会收到旧的字段。</p><ol start="6"><li>TCP连接建立后，浏览器就会构建请求行和请求头等信息，并把和该域名相关的Cookie等数据附加到请求头中，然后向服务器发送构建好的请求信息。</li><li>服务器接受到消息后，就根据请求信息生成响应信息（包括响应行，响应头和响应体等信息），并发送回客户端。</li><li>网络进程接受到响应信息后就开始解析响应头信息，首先是判断状态码是否3xx，是否为重定向，如果是的话就读取响应头的Location字段中的地址信息，然后再发起HTTP或HTTPS请求，一切由从头开始了。</li><li>处理了跳转信息后，接下来就是处理响应数据类型，URL请求有时可能请求的是一个下载类型，也可能是一个正常的HTML界面，这时浏览器就会根据响应头中的Content-Type来处理请求，如果Content-Type为下载类型那就将它交给浏览器的下载管理器，而该URL的导航到此就结束了。但如果是HTML，那就会继续下面的导航流程。接下来就是通知浏览器进程开始<strong>准备渲染</strong>。</li><li>浏览器进程收到通知后，Chrome的方案是如果当前浏览器下已经有同一站点（同一域名，同一协议）的渲染进程，那就会复用其渲染进程，否则则是创建一个新的渲染进程，渲染进程准备好之后还不能进入文档解析阶段，因为此时的文档数据还在网络进程中，并没有提交给渲染进程。</li><li>提交文档阶段，提交响应信息中的响应体部分，<strong>提交文档</strong>的命令由浏览器进程发出，渲染进程接收到通知后，会和网络进程建立传输数据的“管道”，等到文档全部提交后，渲染进程会给浏览器进程发送<strong>确认提交</strong>的信息。</li><li>浏览器接受到<strong>确认提交</strong>的消息后，就会<strong>更新浏览器界面状态</strong>，包括了安全状态，地址栏的URL、前进后退的历史状态，并更新web界面。</li><li>之后就是渲染进程了，一旦渲染进程结束，就会往浏览器进程发送信息，收到信息后，浏览器就会停止标签图标上加载动画</li></ol>]]></content>
    
    
    <categories>
      
      <category>站在巨人的肩膀上</category>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>😃搞定Docker--进阶使用</title>
    <link href="/2022/07/30/%E6%90%9E%E5%AE%9ADocker--%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/30/%E6%90%9E%E5%AE%9ADocker--%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="😃搞定Docker–进阶使用"><a href="#😃搞定Docker–进阶使用" class="headerlink" title="😃搞定Docker–进阶使用"></a>😃搞定Docker–进阶使用</h1><p>在快速入门学习完后，我们开始来学习些真实工作场景下，需要了解学习的技术。</p><span id="more"></span><p>在快速入门那一节我们使用的镜像都是从公共的docker仓库拉取的，而对于一些真实使用的场景，我们常常需要将整个项目的环境都配置到一个镜像中，给使用者一个开箱即用的体验。这里就需要镜像构建的技术。通常有以下两种方式：</p><ul><li><code>docker commit</code>：从已有容器创建一个新的镜像。</li><li><code>docker build</code>：配合 Dockerfile 文件创建镜像。</li></ul><h2 id="Commit命令创建镜像："><a href="#Commit命令创建镜像：" class="headerlink" title="Commit命令创建镜像："></a>Commit命令创建镜像：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker commit [OPTIONS] 容器名 [创建后的镜像名[:TAG]]<br></code></pre></td></tr></table></figure><p> <strong>参数说明：</strong></p><ul><li><strong>-a</strong>：镜像作者</li><li><strong>-m</strong>：提交时的说明</li><li><strong>-p</strong>：在容器commit时，将容器暂停</li><li>TAG虽然是可选，但强烈建议还是加上比较好</li></ul><h3 id="一个栗子💭"><a href="#一个栗子💭" class="headerlink" title="一个栗子💭"></a>一个栗子💭</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.先拉取一个镜像<br>docker pull centos:7<br>2.创建一个容器<br>docker run -di --name centos centos:7<br>3.进入容器<br>docker <span class="hljs-built_in">exec</span> -it centos bash<br>4.配置Go环境，和mysql到里面（docker <span class="hljs-built_in">cp</span> 拷贝、解压）<br>5.创建镜像<br>docker commit -a <span class="hljs-string">&quot;PEngxJ&quot;</span> -m <span class="hljs-string">&quot;Go and mysql&quot;</span> centos mycentos:7<br>6.根据自己的镜像创建容器<br>docker run -di --name mycentos mycentos:7 <br><br></code></pre></td></tr></table></figure><h2 id="Dockerfile方式："><a href="#Dockerfile方式：" class="headerlink" title="Dockerfile方式："></a>Dockerfile方式：</h2><blockquote><p>总体来说就是把上面一个个的步骤写到一个Dockerfile文件中，然后运行这个文件，它就会自动帮我们完成所有步骤，然后创建相应的容器。</p></blockquote><p>在使用该方式前，我们得先学一学Dockerfile的常用命令</p><h3 id="FROM："><a href="#FROM：" class="headerlink" title="FROM："></a>FROM：</h3><p><strong>指定该镜像是基于哪个镜像构建的</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">eg:<br>FROM centos:7<br></code></pre></td></tr></table></figure><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN:"></a>RUN:</h3><p><strong>执行后面跟着的命令行命令</strong>,有以下两种格式：</p><p>shell格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> &lt;命令行命令&gt;</span><br><span class="hljs-comment">#&lt;命令行命令&gt;和在终端上的命令一样</span><br>eg:<br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;RUN&#x27;</span> &gt; /usr/local/run.text</span><br></code></pre></td></tr></table></figure><p>exec格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">&quot;可执行文件&quot;</span>,<span class="hljs-string">&quot;参数1&quot;</span>,<span class="hljs-string">&quot;参数2&quot;</span>]</span><br>eg：<br><span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">&quot;./main.go&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>]</span><br><span class="hljs-comment">#相当于 RUN ./main.go hello world</span><br></code></pre></td></tr></table></figure><p>**注意:**Dockerfile的指令每执行一次都会在docker上新建一层（之前镜像分层的概念），所以过多无意义的层必会导致生成的镜像的膨胀。所以常采用以下方式：</p><p>不用：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos<br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y install wget</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> wget -O redis.tar.gz <span class="hljs-string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span></span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> tar -xvf redis.tar.gz</span><br></code></pre></td></tr></table></figure><p>而用：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos<br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y install wget \</span><br><span class="language-bash">    &amp;&amp; wget -O redis.tar.gz <span class="hljs-string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span><br><span class="language-bash">    &amp;&amp; tar -xvf redis.tar.gz</span><br></code></pre></td></tr></table></figure><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY:"></a>COPY:</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> [--<span class="hljs-built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;...  &lt;目标路径&gt;</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> [--<span class="hljs-built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [<span class="hljs-string">&quot;&lt;源路径1&gt;&quot;</span>,...  <span class="hljs-string">&quot;&lt;目标路径&gt;&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>[–chown&#x3D;&lt;user&gt;:&lt;group&gt;]：可选参数，用户改变复制到容器内文件的拥有者和属组</p><p>**&lt;源路径&gt;**：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> hom* /mydir/</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> hom?.txt /mydir/</span><br></code></pre></td></tr></table></figure><p>**&lt;目标路径&gt;**：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。</p><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD:"></a>ADD:</h3><p>ADD 指令和 COPY 的使用格类似（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下：</p><p>区别：ADD命令，如果复制的内容是压缩包的话，则它会自动解压，当然这样也带来一个不好的地方就是它不能用来复制压缩包</p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD:"></a>CMD:</h3><p>和RUN一样用与执行命令，不过他们各自的执行时间不同。RUN在<code>docker build</code>的时候执行，而CMD是在<code>docker run</code>时执行的。</p><p>介于这点它常用于为启动的容器指定默认的启动程序，如果想让容器一直运行着那就必须得让这个程序在<strong>前台运行</strong>，不然根据docker的规则当命令运行结束后docker就退出了。</p><p><strong>注意：</strong></p><ol><li>CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</li></ol><p>eg：<code>docker run --name nginx -P nginx echo &#39;hello&#39;</code>如果是这样的话，那就会使Dockerfile中CMD的失效。</p><ol start="2"><li>如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。</li></ol><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="language-bash"> &lt;shell 命令&gt; </span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;可执行文件或命令&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...] </span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...]  <span class="hljs-comment"># 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</span></span><br></code></pre></td></tr></table></figure><p>推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。</p><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT:"></a>ENTRYPOINT:</h3><p>和上面CMD类型，在<code>docker run</code>时执行命令，但不同的是它不会被<code>docker run</code>跟着的参数中的命令所覆盖，而是把这些“命令”做为参数给ENTRYPOINT设置的命令使用。</p><p>当然, 如果运行 docker run 时使用了 –entrypoint 选项，将覆盖 ENTRYPOINT 指令指定的程序。</p><p><strong>优点</strong>：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。（ENTRYPOINT设置定参后，后面我们可以在docker run时自己指定变参，可以看后面例子）</p><p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;executeable&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...]</span><br></code></pre></td></tr></table></figure><p>示例：</p><p>假设已通过 Dockerfile 构建了 nginx:test 镜像：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> nginx<br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;nginx&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>] <span class="hljs-comment"># 定参</span></span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/etc/nginx/nginx.conf&quot;</span>] <span class="hljs-comment"># 变参 </span></span><br></code></pre></td></tr></table></figure><p>1、不传参运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run  nginx:<span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><p>容器内会默认运行以下命令，启动主进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx -c /etc/nginx/nginx.conf<br></code></pre></td></tr></table></figure><p>2、传参运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run nginx:<span class="hljs-built_in">test</span> <span class="hljs-string">&quot;/etc/nginx/new.conf&quot;</span></span><br></code></pre></td></tr></table></figure><p>容器内执行以下命令，启动主进程(&#x2F;etc&#x2F;nginx&#x2F;new.conf:假设容器内已有此文件)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx -c /etc/nginx/new.conf<br></code></pre></td></tr></table></figure><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV:"></a>ENV:</h3><p>设置环境变量</p><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> &lt;key&gt; &lt;value&gt;<br><span class="hljs-keyword">ENV</span> &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...<br></code></pre></td></tr></table></figure><h3 id="LABLE"><a href="#LABLE" class="headerlink" title="LABLE:"></a>LABLE:</h3><p>LABEL 指令用来给镜像添加一些元数据（metadata），以键值对的形式，语法格式如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">LABEL</span><span class="language-bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span><br></code></pre></td></tr></table></figure><p>eg:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">LABEL</span><span class="language-bash"> image.authors=<span class="hljs-string">&quot;runoob&quot;</span></span><br></code></pre></td></tr></table></figure><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE:"></a>EXPOSE:</h3><p>仅仅是声明端口并不会打开</p><p>作用：</p><ul><li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。（在docker run时 -p）</li><li>在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</li></ul><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">EXPOSE</span> &lt;端口<span class="hljs-number">1</span>&gt; [&lt;端口<span class="hljs-number">2</span>&gt;...]<br></code></pre></td></tr></table></figure><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR:"></a>WORKDIR:</h3><p>指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。如果不存在，docker会自动创建。</p><p>作用：</p><p>WORKDIR指令为Dockerfile中在其下面的任何RUN、CMD、ENTRYPOINT、COPY和ADD指令设置工作目录。</p><p><strong>怎么理解工作目录：</strong></p><p>在上面的RUN我们说过，每次的RUN都会在docker上新建一层，所以就会导致后面的命令不知道前面的命令的情况。举个例子：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">cd</span> /app</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello&quot;</span> &gt; world.txt</span><br></code></pre></td></tr></table></figure><p>这里我们构键完后会发现在目录&#x2F;app下找不到world.txt，而会在一个其它的地方找到这个东西，这就是上面所说的，因为下一个<code>RUN</code>根本不会在<code>/app</code>目录下。</p><p>这里我们就要用到<strong>WORKDIR</strong>了：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello&quot;</span> &gt; world.txt</span><br></code></pre></td></tr></table></figure><p>如果你的 <code>WORKDIR</code> 指令使用的相对路径，那么所切换的路径与之前的 <code>WORKDIR</code> 有关：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /a</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> b</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> c</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">pwd</span></span><br></code></pre></td></tr></table></figure><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME:"></a>VOLUME:</h3><p>定义&#x3D;&#x3D;匿名&#x3D;&#x3D;数据卷</p><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">VOLUME</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;容器路径1&gt;&quot;</span>, <span class="hljs-string">&quot;&lt;容器路径2&gt;&quot;</span>...]</span><br><span class="hljs-keyword">VOLUME</span><span class="language-bash"> &lt;容器路径&gt;</span><br></code></pre></td></tr></table></figure><p>不过我们一般通过在<code>docker run</code>时添加<code>-v</code>参数来指定挂载目录</p><h3 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build:"></a>docker build:</h3><p>常用的参数：</p><ul><li><code>-t</code>：镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</li><li><code>-f</code>：指定要使用的Dockerfile路径；</li></ul><h3 id="一个栗子🤖："><a href="#一个栗子🤖：" class="headerlink" title="一个栗子🤖："></a>一个栗子🤖：</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos:<span class="hljs-number">7</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> go1.18.4.linux-amd64.tar.gz /usr/local/go</span><br>&amp;&amp; Goweb /usr/home/<br><span class="hljs-keyword">ENV</span> PATH=$PATH:/usr/local/go/bin <br><span class="hljs-keyword">LABEL</span><span class="language-bash"> author=<span class="hljs-string">&quot;PEngxJ&quot;</span></span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /usr/home/</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> go run /usr/home/Goweb/main.go</span><br></code></pre></td></tr></table></figure><h2 id="镜像迁移："><a href="#镜像迁移：" class="headerlink" title="镜像迁移："></a>镜像迁移：</h2><h3 id="备份与恢复的方式："><a href="#备份与恢复的方式：" class="headerlink" title="备份与恢复的方式："></a>备份与恢复的方式：</h3><p><strong>备份：</strong></p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker save <span class="hljs-selector-attr">[OPTIONS]</span> IMAGE <span class="hljs-selector-attr">[IMAGE...]</span><br></code></pre></td></tr></table></figure><ul><li>-o :输出到的文件</li></ul><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker save -o myubuntu.tar ubuntu:v3<br></code></pre></td></tr></table></figure><p><strong>恢复：</strong></p><p>语法:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">docker <span class="hljs-keyword">load</span> [<span class="hljs-keyword">OPTIONS</span>]<br></code></pre></td></tr></table></figure><ul><li>-i : 指定导入的文件，代替 STDIN。</li><li>-q : 精简输出信息。</li></ul><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker load -i myubuntu.tar<br></code></pre></td></tr></table></figure><h3 id="上传至私人与共有的方式："><a href="#上传至私人与共有的方式：" class="headerlink" title="上传至私人与共有的方式："></a>上传至私人与共有的方式：</h3><p>得先注册一个在dockerhub上的号。然后使用<code>docker login</code>登录，<code>docker logout</code>退出。</p><h4 id="公共仓库："><a href="#公共仓库：" class="headerlink" title="公共仓库："></a>公共仓库：</h4><p><strong>上传：</strong></p><ol><li><p>docker tag : 标记本地镜像。</p><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker tag IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> tag hello-world:latest peng7066/test-hello-world:<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li><li><p>docker push：上传镜像。</p><p>语法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker push NAME[:TAG]<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> push peng7066/test-hello-world:<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li></ol><p><strong>拉取：</strong></p><ol><li>docker pull：拉取镜像</li></ol><h4 id="私有仓库："><a href="#私有仓库：" class="headerlink" title="私有仓库："></a>私有仓库：</h4><p><strong>配置私有仓库认证：</strong></p><ol><li><p>生成自签名证书：</p><ol><li><p>创建证书目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p /usr/local/registry/certs<br></code></pre></td></tr></table></figure></li><li><p>生成自签名证书命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl req -newkey rsa:2048 -nodes -sha256 -keyout /usr/local/registry/domain.key -x509 -days 365 -out /usr/local/registry/certs/domain.crt<br></code></pre></td></tr></table></figure><ul><li><code>openssl req</code>：创建证书签名请求等功能；</li><li><code>-newkey</code>：创建CSR证书签名文件和RSA私钥文件；</li><li><code>rsa:2048</code>：指定创建的RSA私钥长度为2048；</li><li><code>-nodes</code>：对私钥不进行加密；</li><li><code>-sha256</code>：使用SHA256算法</li><li><code>-keyout</code>：创建的私钥文件名称及位置</li><li><code>-x509</code>：自签发证书格式</li><li><code>-days</code>：证书有效期</li><li><code>-out</code>：指定CSR输出文件名称及位置</li></ul><p>通过openssl 先生成自签名证书，运行命令后需要填写一些证书信息，里面最关键的部分是：<code>Common Name (eg,your name or your server&#39;s hostname) []:81.70.10.115</code>，这里注意填写的要是自己服务器的地址。</p></li></ol></li><li><p>生成鉴权密码文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建存储鉴权密码文件的目录</span><br>mkdir -p /usr/local/registry/auth<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果没有htpasswd 功能需要安装 htpasswd</span><br>yum install -y httpd<br><span class="hljs-meta prompt_">#</span><span class="language-bash">创建用户和密码</span><br>htpasswd -Bbn root 1234 &gt; /usr/local/registry/auth/htpasswd<br></code></pre></td></tr></table></figure><blockquote><p>htpasswd 是 apache http 的基本认证文件，使用htpasswd 命令可以生成用户及密码文件</p></blockquote></li><li><p>拉取镜像后修改配置文件</p><p>修改配置文件<code>daemon.json</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/docker/daemon.json<br></code></pre></td></tr></table></figure><p>添加以下字段，指明我们的私有镜像仓库的地址</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-string">&quot;insecure-registries&quot;</span>: [<span class="hljs-string">&quot;81.70.10.115:5000&quot;</span>]<br></code></pre></td></tr></table></figure></li><li><p>创建私有仓库容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -di --name registry -p 5000:5000 \<br>-v /mydata/docker_registry:/var/lib/registry \<br>-v /usr/local/registry/certs:/certs \<br>-v /usr/local/registry/auth:/auth \<br>-e &quot;REGISTRY_AUTH=htpasswd&quot; \<br>-e &quot;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&quot; \<br>-e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \<br>-e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt \<br>-e REGISTRY_HTTP_TLE_KEY=/certs/domain.key \<br>registry<br></code></pre></td></tr></table></figure></li><li><p>登录</p><p>这时要指定仓库的地址</p><p><code>docker login 81.70.10.115:5000</code></p><p>然后就可以正常地<code>docker push</code>了</p><p>退出时也要指定仓库的地址</p><p><code>docker logout 81.70.10.115:5000</code></p></li></ol><h2 id="使用自定义网络："><a href="#使用自定义网络：" class="headerlink" title="使用自定义网络："></a>使用自定义网络：</h2><blockquote><p>默认的docker网络模式有三种：bridge，host，none</p><p>自定义的网络就是bridge的改进版，我们可以通过容器的名称直接来通讯，而不是每次启动都会改变的ip地址</p></blockquote><h3 id="创建网络："><a href="#创建网络：" class="headerlink" title="创建网络："></a>创建网络：</h3><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker network create [OPTIONS] 网络名称<br></code></pre></td></tr></table></figure><p>重要参数：</p><ul><li><code>-d</code>：定义网络的驱动程序，默认为bridge</li></ul><h3 id="使用自定义网络：-1"><a href="#使用自定义网络：-1" class="headerlink" title="使用自定义网络："></a>使用自定义网络：</h3><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --net 网络名称 镜像名称<br></code></pre></td></tr></table></figure><h3 id="其它"><a href="#其它" class="headerlink" title="其它:"></a>其它:</h3><p><strong>断开：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">docker network disconnect <br></code></pre></td></tr></table></figure><blockquote><p>还有个集群的部分，未完待续。。。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>打怪升级</category>
      
      <category>搞定docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>🎮redis入门--简单命令</title>
    <link href="/2022/07/28/redis%E5%85%A5%E9%97%A8--%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/07/28/redis%E5%85%A5%E9%97%A8--%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>之前学过一段时间的redis，但碍于囫囵吞枣，而且没做总结，后来又没怎么用，所以忘的七七八八了，这次要整体好好的学一学redis，首先从简单命令开始。</p><span id="more"></span><h1 id="⛽redis入门–简单命令🙂"><a href="#⛽redis入门–简单命令🙂" class="headerlink" title="⛽redis入门–简单命令🙂"></a>⛽redis入门–简单命令🙂</h1><h2 id="五种数据类型："><a href="#五种数据类型：" class="headerlink" title="五种数据类型："></a>五种数据类型：</h2><h3 id="键命令："><a href="#键命令：" class="headerlink" title="键命令："></a>键命令：</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/keys-del.html">DEL key</a></td><td>删除键</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-dump.html">DUMP key</a></td><td>序列化键对应的值</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-exists.html">EXISTS key</a></td><td>判断键是否存在</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-expire.html">EXPIRE key</a> seconds</td><td>设置键的过期时间</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-expireat.html">EXPIREAT key timestamp</a></td><td>设置键在具体的一个时间过期，参数是时间戳的形式</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-pexpire.html">PEXPIRE key milliseconds</a></td><td>设置键的过期时间，参数以毫秒为单位</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-pexpireat.html">PEXPIREAT key milliseconds-timestamp</a></td><td>设置键在具体的一个时间过期，参数是毫秒时间戳的形式</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-keys.html">KEYS pattern</a></td><td>匹配符合的KEY</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-move.html">MOVE key db</a></td><td>将键移到其它的数据库</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-persist.html">PERSIST key</a></td><td>将KEY的过期时间去掉，永久保存</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-pttl.html">PTTL key</a></td><td>返回Key的有效时间，以毫秒为单位</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-ttl.html">TTL key</a></td><td>同上，以秒为单位</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-randomkey.html">RANDOMKEY</a></td><td>随机返回一个Key</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-rename.html">RENAME key newkey</a></td><td>重命名，如果newkey已经存在，则会覆盖</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-renamenx.html">RENAMENX key newkey</a></td><td>重命名，不过只有newkey不存在时才会成功</td></tr><tr><td>[SCAN cursor <a href="https://www.runoob.com/redis/keys-scan.html">MATCH pattern] [COUNT count]</a></td><td>遍历键，每次返回一个</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-type.html">TYPE key</a></td><td>返回Key的类型</td></tr></tbody></table><h3 id="String-字符串-："><a href="#String-字符串-：" class="headerlink" title="String(字符串)："></a>String(字符串)：</h3><ul><li>string是redis中最基本的数据类型，一个key对应一个value。</li><li>string 类型是二进制安全的。意思是它可以存储任何数据，比如jpg图片和序列化后的对象。</li><li>最多可以存储512MB</li></ul><table><thead><tr><th>-</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/strings-set.html">SET key value</a></td><td>设置指定KEY的值，KEY不存在则是添加，存在则是修改覆盖</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-get.html">GET key</a></td><td>获取指定KEY的值</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-getrange.html">GETRANGE key start end</a></td><td>获取</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="Hash-哈希-："><a href="#Hash-哈希-：" class="headerlink" title="Hash(哈希)："></a>Hash(哈希)：</h3><h3 id="List-列表-："><a href="#List-列表-：" class="headerlink" title="List(列表)："></a>List(列表)：</h3><h3 id="Set-集合-："><a href="#Set-集合-：" class="headerlink" title="Set(集合)："></a>Set(集合)：</h3><h3 id="zset-sorted-set-有序集合-："><a href="#zset-sorted-set-有序集合-：" class="headerlink" title="zset(sorted set:有序集合)："></a>zset(sorted set:有序集合)：</h3>]]></content>
    
    
    <categories>
      
      <category>打怪升级</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>⚒认证与授权--cookie|session|token|JWT</title>
    <link href="/2022/07/27/%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/"/>
    <url>/2022/07/27/%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<p>用户认证与授权是一个系统最基本的功能，下面我们一起了解下常见的解决方案的特性与他们相互间的差别，最后是JWT在Go上的使用案例。</p><span id="more"></span><h1 id="😀认证与授权："><a href="#😀认证与授权：" class="headerlink" title="😀认证与授权："></a>😀认证与授权：</h1><blockquote><p>常见的解决方案有cookie、session、token</p><p>在知乎上看到有人用了一个很秒的例子来描述这三个东西👍：在学校或公司，入学入职的那一天，会录入你的身份、账户信息，然后给你发个卡，今后在园区内，你的门禁、打卡、消费都只需要这张卡。</p></blockquote><h2 id="😁Cookie："><a href="#😁Cookie：" class="headerlink" title="😁Cookie："></a>😁Cookie：</h2><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>保存在客户端</li><li>不可跨域，每个Cookie会被绑定在单一域名下，无法在别的域名下使用</li></ul><h3 id="属性（1-⑥）："><a href="#属性（1-⑥）：" class="headerlink" title="属性（1+⑥）："></a>属性（1+⑥）：</h3><ul><li><p><strong>键值对</strong>：在Cookie中设置自定义的值，eg：<code>id=&quot;123456&quot;</code></p></li><li><p><strong>Cookie的域：</strong>在响应首部的Set-Cookie添加domain属性，来控制哪些站点能看到这个Cookie。eg：<code>Set-Cookie: name=&quot;Peng&quot;;domain=&quot;m.zhuanzhuan.58.com&quot;</code>，如果用户访问的是m.zhuanzhuan.58.com，或者m.zhuanzhuan.58.com&#x2F;user 则都可以，而如果是<a href="http://www.aaa.com(非zhuanzhuan.58.com)就不会看到这个cookie./">www.aaa.com(非zhuanzhuan.58.com)就不会看到这个Cookie。</a></p></li><li><p><strong>Cookie的路径Path：</strong>通过添加Path属性可以在特定的路径（这个属性设置的Url和带有这个前缀的Url路径都是有效的）下获得Cookie。</p></li><li><p><strong>Secure：</strong>设置了属性Secure，<code>Set-Cookie: name=&quot;Peng&quot;;domain=&quot;m.zhuanzhuan.58.com&quot;;Secure</code>，则这个Cookie只有在https协议加密的情况下才会发送给客户端</p></li><li><p>**HTTP only:**设置该属性后，则无法通过JS脚本来获得Cookie。</p></li><li><p><strong>Expires：</strong>设置Cookie的过期时间，GMT格式，到达该时间后Cookie会自动失效。</p></li><li><p><strong>max-age：</strong>在HTTP1.1中定义的，优先级高于Expires，表示Cookie的有效期，单位为秒，当值为正数时表示再过去n秒后该Cookie失效，当值为负数时，表示该Cookie为临时Cookie，在浏览器退出后该Cookie则失效，如果值为0则表示取消该Cookie。默认为-1。</p></li></ul><h3 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h3><p><img src="https://pic.rmb.bdstatic.com/bjh/9005b6a0f0e19e96d433046bbf434448.png"></p><ol><li>用户输入用户名，密码（或其它认证方式）到服务器。</li><li>服务器认证成功后，就会利用Set-cookie的头部字段，将Cookie返回给客户端。</li><li>客户端下一次发起请求时，请求首部则会带上这个Cookie</li><li>服务器通过客户端发来的Cookie，便能知道发出该请求的用户，并决定是否通过</li></ol><h2 id="Session-😜"><a href="#Session-😜" class="headerlink" title="Session:😜"></a>Session:😜</h2><blockquote><p>对应于Session就是，其实你的卡上只存了一个id（可能是你的学号），刷的时候物业系统就会去查你的信息、账户，再决定“这个门你能不能进”“这个鸡腿去哪个账户扣钱”</p></blockquote><h3 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h3><ul><li>有重要信息（用户信息，Session状态等）的Session保存在服务器中，而会生成一个SessionId给客户端保存。</li><li>一般基于Cookie实现。</li></ul><h3 id="过程：-1"><a href="#过程：-1" class="headerlink" title="过程："></a>过程：</h3><p><img src="https://pic3.zhimg.com/80/v2-18bd4826103a35c3ef4d99742ad1bd12_1440w.jpg"></p><ol><li>用户输入用户名，密码（或其它认证方式）到服务器。</li><li>服务器认证成功后，在服务器端生成一个Session，保存在文件或者内存或缓存中，然后返回给客户端一个SessionId，SessionId会被客户端保存在Cookie上。</li><li>客户端下一次发起请求时，会自动带上Cookie，Cookie中会携带SessionId。</li><li>服务器接受到Cookie后，检查SessionId的有效性后，决定是否通过。</li></ol><h2 id="😋Token："><a href="#😋Token：" class="headerlink" title="😋Token："></a>😋Token：</h2><blockquote><p>对应于Token就是，在比较早之前，在没有校园卡技术以前，我们都靠学生证。门卫小哥直接对照我和学生证上的脸，确认学生证有效期、年纪等信息，就可以放行了。</p></blockquote><h3 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h3><ul><li>服务器不用再存储信息，减少服务器的压力。</li><li>Token保存在客户端，服务器只需检验Token的有效性</li></ul><h3 id="过程：-2"><a href="#过程：-2" class="headerlink" title="过程："></a>过程：</h3><p><img src="https://pic2.zhimg.com/80/v2-45c53c27a611d78c489a25f3496c7625_1440w.jpg"></p><ol><li>用户输入用户名，密码（或其它认证方式）到服务器。</li><li>服务器认证成功后，在服务器端生成一个Token，这里展示的是通过Cookie传回token,token里面包括了基本的用户信息。</li><li>客户端保存Token后，下次请求时会带上Token</li><li>服务器检验Token的有效性后，决定是否通过。</li></ol><p><strong>考虑到编码，防篡改等问题我们直接讲Token的一个实践JWT（Json Web Token）</strong></p><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT:"></a>JWT:</h2><p><img src="https://pic.rmb.bdstatic.com/bjh/f5b29a28f7c421c77022122c1d291c6c.png" alt="image-20220722172608892"></p><center>一个完整的JWT的结构</center><h3 id="特点：-3"><a href="#特点：-3" class="headerlink" title="特点："></a>特点：</h3><ul><li>继承上面Token的优势，进一步地改善了编码，防篡改的问题。</li></ul><h3 id="三大组成："><a href="#三大组成：" class="headerlink" title="三大组成："></a>三大组成：</h3><p><strong>Header：</strong></p><p>Header主要保存了这个JWT的元数据，主要就是两个部分:<code>alg</code>和<code>typ</code>，<code>alg</code>属性表示签名的算法(algorithm),默认是HMAC SHA256 简写为HS256，<code>typ</code>表示Token的类型，JWT则为JWT。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;alg&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;HS256&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;typ&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;JWT&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>Payload：</strong></p><p>Payload则是存放数据的地方，JWT规定了7个官方字段，供选用。</p><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul><p>我们也可以自己加入一些私有字段。</p><p><strong>这里要注意的是：</strong>虽说我们后面有签名的环节，但那只是为了防止篡改，上面两个部分我们采用的base64UrlEncode编码方法是可以通过防编码出来的，所以重要数据不能放在Payload中。</p><p><strong>Signature:</strong></p><p>在上面Token的部分你可能就有察觉到，我们这次是将用户的信息放在Token里面保存到Cookie中的，这里就存在我们的Token信息被读取，被人用来伪装的可能性，所以就加了签名这一步骤，服务器自己保存了一把密钥，这样就算别人窃取了信息，也无法进行签名，进行伪装。</p><p><strong>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户</strong>。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">HMACSHA256</span>(<br>  base64UrlEncode(header) + &quot;.&quot; +<br>  <span class="hljs-built_in">base64UrlEncode</span>(payload),<br>  secret)<br></code></pre></td></tr></table></figure><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（<code>.</code>）分隔，就可以返回给用户。</p><h3 id="过程：-3"><a href="#过程：-3" class="headerlink" title="过程："></a>过程：</h3><ol><li>用户输入用户名，密码（或其它认证方式）到服务器。</li><li>服务器认证成功后，生成一个JWT，返回给客户端，客户端将会保存JWT。</li><li>客户端下一次发起请求时会带上JWT</li><li>服务器用自己的私钥解析客户端发送过来的JWT，决定是否通过</li></ol><h2 id="JWT在Go中的使用案例："><a href="#JWT在Go中的使用案例：" class="headerlink" title="JWT在Go中的使用案例："></a>JWT在Go中的使用案例：</h2><p>首先go get 一下✨</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> get github.com/dgrijalva/jwt-<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><h3 id="获取JWT："><a href="#获取JWT：" class="headerlink" title="获取JWT："></a>获取JWT：</h3><p>根据前面的讲解，我们已经了解到JWT的数据结构，它就是由两个编码过的json文件加一个签名组成。那我们要做的就是拼装这三个部分。</p><p><strong>Header：</strong></p><p>这个部分包含两个字段，这两个字段都不用我们填，会由你选择的签名算法自动填写好。</p><p><strong>Payload：</strong>（获得Token对象）</p><p>首先我们看下<code>jwt.StandardClaims</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">type</span> StandardClaims <span class="hljs-keyword">struct</span> &#123;<br>Audience  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;aud,omitempty&quot;`</span><br>ExpiresAt <span class="hljs-type">int64</span>  <span class="hljs-string">`json:&quot;exp,omitempty&quot;`</span><br>Id        <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;jti,omitempty&quot;`</span><br>IssuedAt  <span class="hljs-type">int64</span>  <span class="hljs-string">`json:&quot;iat,omitempty&quot;`</span><br>Issuer    <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;iss,omitempty&quot;`</span><br>NotBefore <span class="hljs-type">int64</span>  <span class="hljs-string">`json:&quot;nbf,omitempty&quot;`</span><br>Subject   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;sub,omitempty&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这就是我们上面所说的官方提供的几个可选的字段，在Go中我们使用常用的方法–结构体组合来实现添加我们想要的字段，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Claims <span class="hljs-keyword">struct</span> &#123;<br>UserId <span class="hljs-type">int64</span><br>jwt.StandardClaims<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们把这些字段填充完整，就可以得到Token了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">claims := &amp;Claims&#123;<br>    UserId: user.UserInfoId,<br>    StandardClaims: jwt.StandardClaims&#123;<br>        ExpiresAt: expirationTime.<span class="hljs-built_in">Unix</span>(),<br>        IssuedAt:  time.<span class="hljs-built_in">Now</span>().<span class="hljs-built_in">Unix</span>(),<br>        Issuer:    <span class="hljs-string">&quot;douyin_pro_131&quot;</span>,<br>        Subject:   <span class="hljs-string">&quot;L_B__&quot;</span>,<br>    &#125;&#125;<br>token := jwt.<span class="hljs-built_in">NewWithClaims</span>(jwt.SigningMethodHS256, claims)<br><br></code></pre></td></tr></table></figure><p><strong>Signature:</strong></p><p>上面获得Token对象后，调用<code>jwt.SignedString()</code>，并传入自己服务器保存的密钥（一个 <code>byte[]</code>），就会自动完成Signature部分的编写和对上面三个部分分别进行base64url编码，再整合成一个最终的字符串返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">jwtKey:=[]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;我的密钥&quot;</span>)<br>tokenString,err:=token.SignedString(jwtKey)<br></code></pre></td></tr></table></figure><h3 id="验证JWT："><a href="#验证JWT：" class="headerlink" title="验证JWT："></a>验证JWT：</h3><p>以常用的Web框架Gin为例，我们会把这个部分放到中间件那里使用。</p><p>解析Token：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParseToken</span><span class="hljs-params">(tokenString <span class="hljs-type">string</span>)</span></span> (*MyClaims, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 验证token是否是我们自己签发的</span><br>token, err := jwt.ParseWithClaims(tokenString, &amp;MyClaims&#123;&#125;, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(token *jwt.Token)</span></span> (i <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> jwtKey, <span class="hljs-literal">nil</span><br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> claims, ok := token.Claims.(*MyClaims); ok &amp;&amp; token.Valid &#123; <span class="hljs-comment">// 校验token</span><br><span class="hljs-keyword">return</span> claims, <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;invalid token&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>用于中间件中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">JWTAuthMiddleware</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">// 客户端携带Token有三种方式 1.放在请求头 2.放在请求体 3.放在URI</span><br><span class="hljs-comment">// 这里假设Token放在Header的Authorization中，并使用Bearer开头</span><br><span class="hljs-comment">// 这里的具体实现方式要依据你的实际业务情况决定</span><br>authHeader := c.Query(<span class="hljs-string">&quot;token&quot;</span>)<br>fmt.Println(authHeader)<br><span class="hljs-keyword">if</span> authHeader == <span class="hljs-string">&quot;&quot;</span> &#123;<br>authHeader = c.PostForm(<span class="hljs-string">&quot;token&quot;</span>)<br>fmt.Println(authHeader)<br>&#125;<br><br><span class="hljs-keyword">if</span> authHeader == <span class="hljs-string">&quot; &quot;</span> &#123;<br>c.JSON(http.StatusOK, service.UserResponse&#123;<br>Response: service.Response&#123;StatusCode: <span class="hljs-number">1</span>&#125;,<br>&#125;)<br>c.Abort()<br><span class="hljs-keyword">return</span><br>&#125;<br><br>mc, err := app.ParseToken(authHeader)  <span class="hljs-comment">//就是调用上面的ParseToken</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>c.JSON(http.StatusOK, service.UserResponse&#123;<br>Response: service.Response&#123;StatusCode: <span class="hljs-number">1</span>&#125;,<br>&#125;)<br>c.Abort()<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(mc.UserId)<br><span class="hljs-comment">// 将当前请求的username信息保存到请求的上下文c上</span><br>c.Set(<span class="hljs-string">&quot;user_id&quot;</span>, mc.UserId)<br>c.Next() <span class="hljs-comment">// 后续的处理函数可以用过c.Get(&quot;user_id&quot;)来获取当前请求的用户信息</span><br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="JWT的一些问题："><a href="#JWT的一些问题：" class="headerlink" title="JWT的一些问题："></a>JWT的一些问题：</h3><ol><li><p>JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p></li><li><p>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p></li><li><p>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>常用中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>认证与授权</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搞定Docker--快速入门</title>
    <link href="/2022/07/19/Docker%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/19/Docker%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="🎉Docker🎉"><a href="#🎉Docker🎉" class="headerlink" title="🎉Docker🎉"></a>🎉Docker🎉</h1><p>之前老是听别人讲docker部署的各种优点，但之前单单就感觉确实挺好的，没去深入学习，这段时间有空所以打算把这把利器给捡起来！</p><span id="more"></span><blockquote><p>容器：操作系统级别的虚拟化技术。</p></blockquote><p>简史：前面是dotCloud，用了linux的容器化技术，中途发现活不下去了，就变成开源的了，活了之后就改名为docker了，后面为了进一步优化，投入了Go的怀抱，用了Go构建的引擎。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros">复习一点新虚拟机配网络的知识：<br><br>vim /etc/sysconfig/network-scripts/ifcfg-ens32 (32,也可能是33)<br><br>修改的参数：<br><span class="hljs-attribute">BOOTPROTO</span>=dhcp  (使用动态IP还是静态IP，dhcp改为static 动态改为静态)<br><span class="hljs-attribute">ONBOOT</span>=<span class="hljs-literal">no</span> (<span class="hljs-literal">no</span>改为<span class="hljs-literal">yes</span> 开机自启)<br><span class="hljs-attribute">IPADDR</span>=192.168.91.100 (IP地址，从VMware的虚拟网络设置里看)<br><span class="hljs-attribute">NETMASK</span>=255.255.255.0 (子网掩码)<br><span class="hljs-attribute">GATEWAY</span>=192.168.91.2 (网关，默认就是 IP地址 .2 )<br><span class="hljs-attribute">DNS1</span>=192.168.91.2 (自己的网关)<br><span class="hljs-attribute">DNS2</span>=144.144.144.44 (中国移动，联通 通用的 144.144.144.144)<br><span class="hljs-attribute">DNS3</span>=8.8.8.8(全球通用的,Google的)<br><br></code></pre></td></tr></table></figure><h2 id="🎖安装："><a href="#🎖安装：" class="headerlink" title="🎖安装："></a>🎖安装：</h2><ol><li><p><code>sudo yum install -y yum-utils </code>: 安装yum-utils这个包，我们才可以用它里面的工具:<code>yum-config-manager</code>来指定下载源</p></li><li><p><code>sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code>：设置为阿里的下载源</p></li><li><p><code> sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</code>  docker-ce ：docker引擎社区版、docker-ce-cli：docker引擎命令行界面 containerd.io：守护进程</p></li><li><p><code>docker -v</code>：查看版本，看是否成功。</p></li><li><p><code>docker run hello-world</code>:测试能否正常使用</p></li><li><p>配置镜像加速：1.<code>vim /etc/docker/daemon.json</code> </p><ol start="2"><li><p>添加到里面</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>启用配置、重启docker</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nsis">sudo <span class="hljs-params">system</span>ctl daemon-reload<br>sudo <span class="hljs-params">system</span>ctl restart docker<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="😱Docker-架构及工作原理："><a href="#😱Docker-架构及工作原理：" class="headerlink" title="😱Docker 架构及工作原理："></a>😱Docker 架构及工作原理：</h2><p>三个东西:</p><ul><li>Client：<strong>宿主机</strong>的命令行界面</li><li>Docker_Host：Docker引擎<ul><li>Docker daemon：<strong>守护进程</strong>，就像一个中枢一样，Client的命令发到这里，并由它来进行相应的操作，比如从远程仓库（Registry）拉取镜像，将拉取的镜像生成容器</li><li>images：镜像（模板，类似语言中的一个类）</li><li>Containers：容器 （真正工作的玩意，类似用上面的类创建的一个对象）</li></ul></li><li>Registry：远程仓库</li></ul><h3 id="Client客户端："><a href="#Client客户端：" class="headerlink" title="Client客户端："></a>Client客户端：</h3><h3 id="镜像分层："><a href="#镜像分层：" class="headerlink" title="镜像分层："></a>镜像分层：</h3><p><img src="http://i2.51cto.com/images/blog/201711/27/462718f3cd35608c20481b33b09db020.jpg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="Docker镜像的内部结构(四)"></p><p>在使用docker后，我们会拉取很多很多的镜像到本地，为了防止拉取的镜像互相间存在冗余的数据（比如Nginx和Redis都需要安装C++环境，如果拉取镜像的时候都拉取了一个，这部分相同的C++环境就是冗余的数据了，更深入些，每个镜像依赖的最基础的Linux环境也会成为冗余数据的一部分)，所以Docker采用了镜像分层的技术，也就是将最基础的Linux环境做为Base镜像，后面最终我们所使用的镜像（Nginx、Redis等等）都是在这个Base镜像的基础上，堆上一层层其它的镜像构成的，如果不同的镜像有利用到相同的部分，则不会重复拉取，而是直接复用。</p><h3 id="Volume-数据卷："><a href="#Volume-数据卷：" class="headerlink" title="Volume 数据卷："></a>Volume 数据卷：</h3><p>使容器与宿主机建立映射关系，把容器里的数据映射到宿主机上，在创建容器的时候可以指定数据卷，如果不指定，则数据还是只保存在容器中。</p><h3 id="Registry"><a href="#Registry" class="headerlink" title="Registry:"></a>Registry:</h3><p><a href="hub.docker.com">官方镜像仓库</a> 需要联网，而且上传后别人也能看到</p><p>所以docker 提供了 registry 镜像，可供我们在局域网内搭建仓库，也可以设置身份认证等等</p><h2 id="💘Docker-常用命令："><a href="#💘Docker-常用命令：" class="headerlink" title="💘Docker 常用命令："></a>💘Docker 常用命令：</h2><h3 id="镜像相关命令："><a href="#镜像相关命令：" class="headerlink" title="镜像相关命令："></a>镜像相关命令：</h3><h4 id="1-查看镜像："><a href="#1-查看镜像：" class="headerlink" title="1.查看镜像："></a>1.查看镜像：</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">docker images<br><br></code></pre></td></tr></table></figure><ul><li><code>Repository</code>:仓库名称</li></ul><h4 id="2-搜索镜像："><a href="#2-搜索镜像：" class="headerlink" title="2.搜索镜像："></a>2.搜索镜像：</h4><p>如果需要从网络中查找需要的镜像，可以通过以下命令查看是否存在</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">docker search 镜像名<br></code></pre></td></tr></table></figure><h4 id="3-拉取镜像："><a href="#3-拉取镜像：" class="headerlink" title="3.拉取镜像："></a>3.拉取镜像：</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http">docker pull 镜像名<br><br>也可以指定标签：docker pull redis:5 (例子)<br></code></pre></td></tr></table></figure><h4 id="4-删除镜像："><a href="#4-删除镜像：" class="headerlink" title="4.删除镜像："></a>4.删除镜像：</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">docker rmi 镜像名<br>也可以指定标签：docker rmi redis:5 (例子)<br></code></pre></td></tr></table></figure><h3 id="容器命令："><a href="#容器命令：" class="headerlink" title="容器命令："></a>容器命令：</h3><h4 id="1-查看命令："><a href="#1-查看命令：" class="headerlink" title="1.查看命令："></a>1.查看命令：</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http">docker ps  查看运行的容器<br>docker ps -a 查看所有的容器<br>docker ps -l 查看最后创建的容器<br>docker ps -l -n 最后几个容器<br>docker ps -f status:exited  过滤查询<br>不知道怎么操作就可以加 --help来获得帮助<br></code></pre></td></tr></table></figure><h4 id="2-创建与启动："><a href="#2-创建与启动：" class="headerlink" title="2.创建与启动："></a>2.创建与启动：</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs http">docker run 镜像名  创建容器<br>参数：<br>--name: 指定创建的容器名<br>-p:指定端口  （宿主机端口：容器端口）<br>-P：自动指定<br>-i: 运行容器<br>-t:表示容器启动后会进入其命令行界面<br>-v:可以指定目录映射关系，可以用多个-v 映射多个目录<br>-it：启动并进入，有些容器创建后不会进入，就可以这样启动后并进入<br></code></pre></td></tr></table></figure><h4 id="3-守护进程进入"><a href="#3-守护进程进入" class="headerlink" title="3.守护进程进入"></a>3.守护进程进入</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">docker run -di 镜像名<br>docker exec -it [自己取的镜像名，容器ID]  进入容器<br></code></pre></td></tr></table></figure><h4 id="4-停止启动容器"><a href="#4-停止启动容器" class="headerlink" title="4.停止启动容器"></a>4.停止启动容器</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">docker stop 容器名<br>docker start 容器名<br></code></pre></td></tr></table></figure><h4 id="5-文件拷贝："><a href="#5-文件拷贝：" class="headerlink" title="5.文件拷贝："></a>5.文件拷贝：</h4><p>可以把宿主机的拷贝到容器，也可以把容器的拷贝到宿主机</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">docker cp 需要拷贝的文件或目录 容器名称:容器目录<br>docker cp 容器名称:容器目录或文件 拷贝到宿的主机的位置<br></code></pre></td></tr></table></figure><h4 id="6-目录挂载："><a href="#6-目录挂载：" class="headerlink" title="6.目录挂载："></a>6.目录挂载：</h4><p>如果不挂载，当容器被删除后，数据也就被删除了，挂载后，宿主机的数据则还在</p><ol><li><p>指定目录挂载：<code>docker run -di -v 宿主机位置:容器目录 镜像名称</code>，docker会自动创建相应的容器目录，如果没在创建容器时挂载，后面想挂载可以通过修改配置文件来实现。</p><p><code>docker inspect 容器名 </code>可以查看所有的详细信息。</p></li><li><p>匿名挂载：<code>docker run -di -v 容器目录 镜像名称</code>,匿名挂载我们不用指定宿主机的位置，统一会被放到 <code>/var/lib/docker/volumes</code> 中，它会自动生成一个随机名称的目录，如果匿名挂载过多时，可以通过<code>docker inspect 容器名</code>来查看被挂载时随机生成的名字。</p></li><li><p>具名挂载：<code>docker run -di -v 宿主机中的目录名字:容器目录 镜像名称</code>,和上面一样会被放到<code>/var/lib/docker/volumes</code>中，不过这次可以指定名字</p></li><li><p>设置权限（只读&#x2F;读写，有时我们不希望容器在内部操作，就只允许宿主机操作，就可以挂只读），<code>docker run -di -v 容器目录:ro/rw 镜像名称</code> 只读&#x2F;读写</p></li><li><p>继承：<code>--volumes-from 被继承的容器名:ro/rw</code>，可以继承之前容器挂载的目录</p></li><li><p>查看容器ip地址：<code>docker inspect 容器名称</code></p></li><li><p>删除容器：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">docker rm 容器名称|容器ID<br>docker rm 容器名称|容器ID 容器名称|容器ID 容器名称|容器ID<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>打怪升级</category>
      
      <category>搞定docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The First Blog</title>
    <link href="/2022/06/28/The-First-Blog/"/>
    <url>/2022/06/28/The-First-Blog/</url>
    
    <content type="html"><![CDATA[<h1 id="😍全军出击🎉"><a href="#😍全军出击🎉" class="headerlink" title="😍全军出击🎉"></a>😍全军出击🎉</h1><h2 id="革命尚未成功，还需继续努力🎖"><a href="#革命尚未成功，还需继续努力🎖" class="headerlink" title="革命尚未成功，还需继续努力🎖"></a>革命尚未成功，还需继续努力🎖</h2>]]></content>
    
    
    <categories>
      
      <category>陈词滥调</category>
      
      <category>第一篇博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FirstBlog</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
