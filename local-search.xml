<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>🥞Redis数据结构----跳跃表、整数集合、压缩列表</title>
    <link href="/2022/10/15/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84----%E8%B7%B3%E8%B7%83%E8%A1%A8%E3%80%81%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E3%80%81%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/"/>
    <url>/2022/10/15/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84----%E8%B7%B3%E8%B7%83%E8%A1%A8%E3%80%81%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E3%80%81%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="🥞Redis数据结构—-跳跃表、整数集合、压缩列表"><a href="#🥞Redis数据结构—-跳跃表、整数集合、压缩列表" class="headerlink" title="🥞Redis数据结构—-跳跃表、整数集合、压缩列表"></a>🥞Redis数据结构—-跳跃表、整数集合、压缩列表</h1><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h75zymgq7wj30vq0hsq9b.jpg"></p><h2 id="跳跃表："><a href="#跳跃表：" class="headerlink" title="跳跃表："></a>跳跃表：</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><blockquote><p>跳跃表是一种有序的数据结构，通过在每个节点维护指向其他节点的指针，以达到快速访问节点的目的，时间复杂度平均能达到O(log<sub>n</sub>)，最坏为n，介于它是有序的特点，也提供了对节点进行范围操作的能力。</p><p>跳跃表做为有序集合的底层实现之一，当有序集合中的对象较多，又或者有序集合中元素的成员是比较长的字符串时，就会使用跳跃表做为底层实现。</p><p>和前几个数据结构在redis中被广泛使用不同的是，除了作为有序集合的底层实现，跳跃表就还使用在一个地方：在集群节点中用作内部数据结构</p></blockquote><h4 id="关于跳跃表："><a href="#关于跳跃表：" class="headerlink" title="关于跳跃表："></a>关于跳跃表：</h4><p><strong>介绍下跳跃表</strong></p><p><strong>前提：跳表处理的是有序的链表，所以我们先看个不能再普通了的有序列表（一般是双向链表）</strong></p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h75q7zr1esj30u002ut94.jpg"></p><p>如果我们想查找某个数，只能遍历链表逐个比对，时间复杂度 ，插入和删除操作都一样。</p><p>为了提高查找效率，我们对链表做个”索引“</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h75q81zwegj30u005vq3q.jpg"></p><p>像这样，我们每隔一个节点取一个数据作为索引节点（或者增加一个指针），比如我们要找 31 直接在索引链表就找到了（遍历 3 次），如果找 16 的话，在遍历到 31的时候，发现大于目标节点，就跳到下一层(原数据层)，接着遍历~ (蓝线表示搜索路径)</p><blockquote><p>可能你会以为，就这，不加索引我找16也是4次。把数据量扩大看看～～</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h75qegql35j30u009hq3c.jpg"></p><p>每加一层索引，我们搜索的时间复杂度就降为原来的</p><p>加了几层索引，查找一个节点需要遍历的节点个数明线减少了，效率提高不少，bingo~</p><p>有没有似曾相识的感觉，像不像二分查找或者二叉搜索树，通过索引来跳过大量的节点，从而提高搜索效率。</p><p>这样的多层链表结构，就是『<strong>跳表</strong>』了</p><p><strong>跳表索引动态更新</strong></p><p>我们上边建立索引层都是下层节点个数的 1&#x2F;2，高层索引的节点数就是 2 个，但是我们随意插入或者删除一个原有链表的节点，这个比例就肯定会被破坏。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h75qxapckij30u00b474p.jpg"></p><p>作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中节点多了，索引节点就相应地增加一些，避免复杂度退化。</p><p>如果重建索引的话，效率就不能保证了。跳表是通过随机函数来维护前面提到的“平衡性”</p><p>redis正是如此，它的实现方法很妙，等下面关于redis中跳跃表实现的内容读完再来体会体会。</p><h3 id="跳跃表的实现："><a href="#跳跃表的实现：" class="headerlink" title="跳跃表的实现："></a>跳跃表的实现：</h3><p>Redis 的跳跃表由 <code>redis.h/zskiplistNode</code> 和 <code>redis.h/zskiplist</code> 两个结构定义， 其中 <code>zskiplistNode</code> 结构用于表示跳跃表节点， 而 <code>zskiplist</code> 结构则用于保存跳跃表节点的相关信息， 比如节点的数量， 以及指向表头节点和表尾节点的指针， 最大的层数。</p><p>跳跃表的实现如下图：</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h75rc92u5pj30jf0f3my1.jpg"></p><p>最左边的结构为zskiplist，它的4个结构描述如下：</p><ul><li>header：指向头节点的指针</li><li>tail：指向尾节点的指针</li><li>level: 当前跳跃表节点中最大的层数</li><li>length: 当前跳跃表的节点个数</li></ul><p>后边的几个则为zskiplistNode，它分为4个部分，描述如下：</p><ul><li>层(level)：节点中用 <code>L1</code> 、 <code>L2</code> 、 <code>L3</code> 等字样标记节点的各个层，每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。</li><li>后退（backward）指针：节点中用 <code>BW</code> 字样标记节点的后退指针，它指向位于当前节点的前一个节点。</li><li>分值（score）：各个节点中的 <code>1.0</code> 、 <code>2.0</code> 和 <code>3.0</code> 是节点所保存的分值。</li><li>成员对象（obj）：各个节点中的 <code>o1</code> 、 <code>o2</code> 和 <code>o3</code> 是节点所保存的成员对象。</li></ul><p>下面我们再对这两个结构进行详细讨论：</p><h4 id="跳跃表节点："><a href="#跳跃表节点：" class="headerlink" title="跳跃表节点："></a>跳跃表节点：</h4><p>跳跃表节点的实现由 <code>redis.h/zskiplistNode</code> 结构定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistNode</span> &#123;<br><br>    <span class="hljs-comment">// 后退指针</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistNode</span> *backward;<br>    <span class="hljs-comment">// 分值</span><br>    <span class="hljs-type">double</span> score;<br>    <span class="hljs-comment">// 成员对象</span><br>    robj *obj;<br>    <span class="hljs-comment">// 层</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistLevel</span> &#123;<br>        <span class="hljs-comment">// 前进指针</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistNode</span> *forward;<br>        <span class="hljs-comment">// 跨度</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> span;<br>    &#125; level[];<br><br>&#125; zskiplistNode;<br></code></pre></td></tr></table></figure><p><strong>先说level</strong></p><ol><li><p>跳跃表节点的 <code>level</code> 数组可以包含多个元素， 每个元素都包含一个指向其他节点的指针， 程序可以通过这些层来加快访问其他节点的速度， 一般来说， 层的数量越多， 访问其他节点的速度就越快。</p><p>每次创建一个新跳跃表节点的时候， 程序都根据幂次定律 （<a href="http://en.wikipedia.org/wiki/Power_law">power law</a>，越大的数出现的概率越小） 随机生成一个介于 <code>1</code> 和 <code>32</code> 之间的值作为 <code>level</code> 数组的大小， 这个大小就是层的“高度”。<strong>还记得我们上面说的跳跃表索引动态更新的随机函数吗？就是这了</strong>，通过这样就能均匀的在每一层加索引，而且越高层的索引中元素个数越少，恩，很妙～</p></li><li><p>每一个level中两个结构：<code>forward</code>前进指针，指向在同一层上的下一个节点。<code>span</code>，记录了通过该前进指针到达下一个节点的跨度，跨度被用来计算排位（rank）： 在查找某个节点的过程中， 将沿途访问过的所有层的跨度累计起来， 得到的结果就是目标节点在跳跃表中的排位。</p></li></ol><p><strong>BW后退指针</strong></p><p>节点的后退指针（<code>backward</code> 属性）用于从表尾向表头方向访问节点： 跟可以一次跳过多个节点的前进指针不同， 因为每个节点只有一个后退指针， 所以每次只能后退至前一个节点。</p><p><strong>分值和成员</strong></p><p>节点的分值（<code>score</code> 属性）是一个 <code>double</code> 类型的浮点数， 跳跃表中的所有节点都按分值从小到大来排序。</p><p>节点的成员对象（<code>obj</code> 属性）是一个指针， 它指向一个字符串对象， 而字符串对象则保存着一个 SDS 值。</p><p>在同一个跳跃表中， 各个节点保存的成员对象必须是唯一的， 但是多个节点保存的分值却可以是相同的： 分值相同的节点将按照成员对象在字典序中的大小来进行排序，</p><h4 id="跳跃表：-1"><a href="#跳跃表：-1" class="headerlink" title="跳跃表："></a>跳跃表：</h4><p>虽然仅靠多个跳跃表节点就可以组成一个跳跃表。</p><p>但通过使用一个 <code>zskiplist</code> 结构来持有这些节点， 程序可以更方便地对整个跳跃表进行处理， 比如快速访问跳跃表的表头节点和表尾节点， 又或者快速地获取跳跃表节点的数量（也即是跳跃表的长度）等信息</p><p><code>zskiplist</code> 结构的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplist</span> &#123;<br>    <span class="hljs-comment">// 表头节点和表尾节点</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistNode</span> *header, *tail;<br>    <span class="hljs-comment">// 表中节点的数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length;<br>    <span class="hljs-comment">// 表中层数最大的节点的层数</span><br>    <span class="hljs-type">int</span> level;<br>&#125; zskiplist;<br></code></pre></td></tr></table></figure><p><code>header</code> 和 <code>tail</code> 指针分别指向跳跃表的表头和表尾节点， 通过这两个指针， 程序定位表头节点和表尾节点的复杂度为 O(1) 。</p><p>通过使用 <code>length</code> 属性来记录节点的数量， 程序可以在 O(1) 复杂度内返回跳跃表的长度。</p><p><code>level</code> 属性则用于在 O(1) 复杂度内获取跳跃表中层高最大的那个节点的层数量， 注意表头节点的层高并不计算在内。</p><h2 id="整数集合："><a href="#整数集合：" class="headerlink" title="整数集合："></a>整数集合：</h2><h3 id="简介：-1"><a href="#简介：-1" class="headerlink" title="简介："></a>简介：</h3><blockquote><p>整数集合（intset）是集合键的底层实现之一： 当一个集合只包含整数值元素， 并且这个集合的元素数量不多时， Redis 就会使用整数集合作为集合键的底层实现。</p></blockquote><h3 id="整数集合的实现："><a href="#整数集合的实现：" class="headerlink" title="整数集合的实现："></a>整数集合的实现：</h3><p>每个 <code>intset.h/intset</code> 结构表示一个整数集合：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">intset</span> &#123;<br>    <span class="hljs-comment">// 编码方式</span><br>    <span class="hljs-type">uint32_t</span> encoding;<br>    <span class="hljs-comment">// 集合包含的元素数量</span><br>    <span class="hljs-type">uint32_t</span> length;<br>    <span class="hljs-comment">// 保存元素的数组</span><br>    <span class="hljs-type">int8_t</span> contents[];<br>&#125; intset;<br></code></pre></td></tr></table></figure><p><strong>encoding</strong></p><p>这里contents的类型写着int8_t，但并非如此，数据的编码方式是由encoding属性决定的。</p><ul><li>如果 <code>encoding</code> 属性的值为 <code>INTSET_ENC_INT16</code> ， 那么 <code>contents</code> 就是一个 <code>int16_t</code> 类型的数组， 数组里的每个项都是一个 <code>int16_t</code> 类型的整数值 （最小值为 <code>-32,768</code> ，最大值为 <code>32,767</code> ）。</li><li>如果 <code>encoding</code> 属性的值为 <code>INTSET_ENC_INT32</code> ， 那么 <code>contents</code> 就是一个 <code>int32_t</code> 类型的数组， 数组里的每个项都是一个 <code>int32_t</code> 类型的整数值 （最小值为 <code>-2,147,483,648</code> ，最大值为 <code>2,147,483,647</code> ）。</li><li>如果 <code>encoding</code> 属性的值为 <code>INTSET_ENC_INT64</code> ， 那么 <code>contents</code> 就是一个 <code>int64_t</code> 类型的数组， 数组里的每个项都是一个 <code>int64_t</code> 类型的整数值 （最小值为 <code>-9,223,372,036,854,775,808</code> ，最大值为 <code>9,223,372,036,854,775,807</code> ）。</li></ul><p><strong>length</strong>表示当前集合拥有的元素个数</p><p><strong>contents</strong>，contents数组中的每一个元素就代表着集合中的一个元素，<mark>各个项在数组中按值的大小从小到大有序地排列</mark>， 并且数组中不包含任何重复项。</p><h3 id="升级："><a href="#升级：" class="headerlink" title="升级："></a>升级：</h3><p>在整数集合中有一个<strong>升级</strong>的概念，升级策略主要有两个好处， 一个是提升整数集合的灵活性， 另一个是尽可能地节约内存。我们先讲它是如何升级的，待会能更好地理解为啥会有这两好处</p><h4 id="如何升级："><a href="#如何升级：" class="headerlink" title="如何升级："></a>如何升级：</h4><p>每当我们要将一个新元素添加到整数集合里面， 并且新元素的类型比整数集合现有所有元素的类型都要长时， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。</p><p>升级整数集合并添加新元素共分为三步进行：</p><ol><li>根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。</li><li>将新元素添加到底层数组里面。</li></ol><p>因为每次向整数集合添加新元素都可能会引起升级， 而每次升级都需要对底层数组中已有的所有元素进行类型转换， 所以向整数集合添加新元素的时间复杂度为 O(N) 。</p><h4 id="升级的好处："><a href="#升级的好处：" class="headerlink" title="升级的好处："></a>升级的好处：</h4><ol><li>提升灵活性：因为 C 语言是静态类型语言， 为了避免类型错误， 我们通常不会将两种不同类型的值放在同一个数据结构里面。比如说， 我们一般只使用 <code>int16_t</code> 类型的数组来保存 <code>int16_t</code> 类型的值， 只使用 <code>int32_t</code> 类型的数组来保存 <code>int32_t</code> 类型的值，加入了升级策略后，你就可以<del>为所欲为</del>，可以随意地将 <code>int16_t</code> 、 <code>int32_t</code> 或者 <code>int64_t</code> 类型的整数添加到集合中， 而不必担心出现类型错误， 这种做法非常灵活。</li><li>节约内存：当然， 要让一个数组可以同时保存 <code>int16_t</code> 、 <code>int32_t</code> 、 <code>int64_t</code> 三种类型的值， 最简单的做法就是直接使用 <code>int64_t</code> 类型的数组作为整数集合的底层实现。 不过这样一来， 即使添加到整数集合里面的都是 <code>int16_t</code> 类型或者 <code>int32_t</code> 类型的值， 数组都需要使用 <code>int64_t</code> 类型的空间去保存它们， 从而出现浪费内存的情况。有了升级策略后，我们就是非必要不升级，不浪费了。</li></ol><h4 id="能不能降级？"><a href="#能不能降级？" class="headerlink" title="能不能降级？"></a>能不能降级？</h4><p>答案：不能，升了就降不回来了</p><h2 id="压缩列表："><a href="#压缩列表：" class="headerlink" title="压缩列表："></a>压缩列表：</h2><h3 id="简介：-2"><a href="#简介：-2" class="headerlink" title="简介："></a>简介：</h3><p>压缩列表（ziplist）是列表键（凑合算吧，redis3.2后用的是快速列表，而快速列表的基础就是压缩列表）和哈希键的底层实现之一。</p><p>当一个哈希键只包含少量键值对， 并且每个键值对的键和值要么就是小整数值， 要么就是长度比较短的字符串， 那么 Redis 就会使用压缩列表来做哈希键的底层实现。</p><p>当一个列表键只包含少量列表项， 并且每个列表项要么就是小整数值， 要么就是长度比较短的字符串，那么 Redis <strong>也不会</strong>使用压缩列表来做列表键的底层实现。现在改为都用快速列表了。</p><h3 id="压缩列表的实现："><a href="#压缩列表的实现：" class="headerlink" title="压缩列表的实现："></a>压缩列表的实现：</h3><p>压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的<strong>连续内存块</strong>组成的顺序型数据结构。</p><p>一个压缩列表可以包含任意多个节点（entry）， 每个节点可以保存一个字节数组或者一个整数值。</p><p><strong>压缩列表</strong></p><p>压缩列表的结构如下：</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h75txr05mij30ty03yq31.jpg"></p><p>由4大部分组层，下面是关于这4大部分详细的介绍</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h75txsvyn9j31iq0e0q7u.jpg"></p><p><strong>压缩列表节点</strong></p><p>每个压缩列表节点可以保存一个字节数组或者一个整数值， 其中， 字节数组可以是以下三种长度的其中一种：</p><ol><li>长度小于等于 <code>63</code> （2^{6}-1）字节的字节数组；</li><li>长度小于等于 <code>16383</code> （2^{14}-1） 字节的字节数组；</li><li>长度小于等于 <code>4294967295</code> （2^{32}-1）字节的字节数组；</li></ol><p>而整数值则可以是以下六种长度的其中一种：</p><ol><li><code>4</code> 位长，介于 <code>0</code> 至 <code>12</code> 之间的无符号整数；</li><li><code>1</code> 字节长的有符号整数；</li><li><code>3</code> 字节长的有符号整数；</li><li><code>int16_t</code> 类型整数；</li><li><code>int32_t</code> 类型整数；</li><li><code>int64_t</code> 类型整数。</li></ol><p>每个压缩列表节点都由 <code>previous_entry_length</code> 、 <code>encoding</code> 、 <code>content</code> 三个部分组成， 如下图。</p><p>![image-20221015120553391](&#x2F;Users&#x2F;pengxj&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20221015120553391.png)</p><p>接下来我们详细地看看这三个部分。</p><h4 id="previous-entry-length"><a href="#previous-entry-length" class="headerlink" title="previous_entry_length"></a>previous_entry_length</h4><p>节点的 <code>previous_entry_length</code> 属性以字节为单位， 记录了压缩列表中前一个节点的长度。这里要关注的<strong>第一个重点</strong>就是<mark>它可能用一个字节也可能用五个字节来保存这个长度</mark>，具体如下：</p><ul><li>如果前一节点的长度小于 <code>254</code> 字节， 那么 <code>previous_entry_length</code> 属性的长度为 <code>1</code> 字节： 前一节点的长度就保存在这一个字节里面。</li><li>如果前一节点的长度大于等于 <code>254</code> 字节， 那么 <code>previous_entry_length</code> 属性的长度为 <code>5</code> 字节： 其中属性的第一字节会被设置为 <code>0xFE</code>（十进制值 <code>254</code>）， <strong>而之后的四个字节</strong>则用于保存前一节点的长度。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h75uija6ipj318y044wew.jpg"></p><p><strong>第二个重点是</strong>：因为节点的 <code>previous_entry_length</code> 属性记录了前一个节点的长度， 所以程序可以通过指针运算， 根据当前节点的起始地址来计算出前一个节点的起始地址。</p><h4 id="encoding："><a href="#encoding：" class="headerlink" title="encoding："></a>encoding：</h4><p>节点的 <code>encoding</code> 属性记录了节点的 <code>content</code> 属性所保存数据的类型以及长度：</p><ul><li>一字节、两字节或者五字节长， 值的最高位为 <code>00</code> 、 <code>01</code> 或者 <code>10</code> 的是<strong>字节数组编码</strong>： 这种编码表示节点的 <code>content</code> 属性保存着字节数组， <strong>数组的长度由编码除去最高两位之后的其他位记录</strong>；</li><li>一字节长， 值的最高位以 <code>11</code> 开头的是<strong>整数编码</strong>： 这种编码表示节点的 <code>content</code> 属性保存着整数值， <strong>整数值的类型和长度由编码除去最高两位之后的其他位记录</strong>；</li></ul><p>字节数组编码：</p><table><thead><tr><th align="left">编码</th><th align="left">编码长度</th><th align="left"><code>content</code> 属性保存的值</th></tr></thead><tbody><tr><td align="left"><code>00bbbbbb</code></td><td align="left"><code>1</code> 字节</td><td align="left">长度小于等于 <code>63</code> 字节的字节数组。</td></tr><tr><td align="left"><code>01bbbbbb xxxxxxxx</code></td><td align="left"><code>2</code> 字节</td><td align="left">长度小于等于 <code>16383</code> 字节的字节数组。</td></tr><tr><td align="left"><code>10______ aaaaaaaa bbbbbbbb cccccccc dddddddd</code></td><td align="left"><code>5</code> 字节</td><td align="left">长度小于等于 <code>4294967295</code> 的字节数组。</td></tr></tbody></table><p>整数编码：</p><table><thead><tr><th align="left">编码</th><th align="left">编码长度</th><th align="left"><code>content</code> 属性保存的值</th></tr></thead><tbody><tr><td align="left"><code>11000000</code></td><td align="left"><code>1</code> 字节</td><td align="left"><code>int16_t</code> 类型的整数。</td></tr><tr><td align="left"><code>11010000</code></td><td align="left"><code>1</code> 字节</td><td align="left"><code>int32_t</code> 类型的整数。</td></tr><tr><td align="left"><code>11100000</code></td><td align="left"><code>1</code> 字节</td><td align="left"><code>int64_t</code> 类型的整数。</td></tr><tr><td align="left"><code>11110000</code></td><td align="left"><code>1</code> 字节</td><td align="left"><code>24</code> 位有符号整数。</td></tr><tr><td align="left"><code>11111110</code></td><td align="left"><code>1</code> 字节</td><td align="left"><code>8</code> 位有符号整数。</td></tr><tr><td align="left"><code>1111xxxx</code></td><td align="left"><code>1</code> 字节</td><td align="left">使用这一编码的节点没有相应的 <code>content</code> 属性， 因为编码本身的 <code>xxxx</code> 四个位已经保存了一个介于 <code>0</code> 和 <code>12</code> 之间的值， 所以它无须 <code>content</code> 属性。</td></tr></tbody></table><h4 id="content："><a href="#content：" class="headerlink" title="content："></a>content：</h4><p>节点的 <code>content</code> 属性负责保存节点的值， 节点值可以是一个字节数组或者整数， 值的类型和长度由节点的 <code>encoding</code> 属性决定。</p><p>下面展示了一个保存字节数组的节点示例：</p><ul><li>编码的最高两位 <code>00</code> 表示节点保存的是一个字节数组；</li><li>编码的后六位 <code>001011</code> 记录了字节数组的长度 <code>11</code> ；</li><li><code>content</code> 属性保存着节点的值 <code>&quot;hello world&quot;</code> 。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h75yd6tosuj30bz03agln.jpg"></p><p>下面展示了一个保存整数值的节点示例：</p><ul><li>编码 <code>11000000</code> 表示节点保存的是一个 <code>int16_t</code> 类型的整数值；</li><li><code>content</code> 属性保存着节点的值 <code>10086</code> 。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h75yd8fsubj30aq03adfu.jpg"></p><h3 id="连续更新："><a href="#连续更新：" class="headerlink" title="连续更新："></a>连续更新：</h3><p>前面说过， 每个节点的 <code>previous_entry_length</code> 属性都记录了前一个节点的长度，但是这个用于保存该长度的字节数是不一定的，有可能为5也可能为1。</p><p>以下面的一个例子为例，我们看看何时会发生连续更新。</p><p>现在， 考虑这样一种情况： 在一个压缩列表中， 有多个连续的、长度介于 <code>250</code> 字节到 <code>253</code> 字节之间的节点 <code>e1</code> 至 <code>eN</code>，因为<code>e1</code>到<code>eN</code>都是小于254个字节的，所以它们的<code>previous_entry_length</code> ，就只为一个字节，这时我们将一个长度大于等于254字节的节点插到列表的前面，这时<code>e1</code>的<code>previous_entry_length</code>也就得更新为5个字节长度来保存这个信息，而因为<code>e1</code>的<code>previous_entry_length</code>更新后使<code>e1</code>的总长也发生了改变，这时<code>e2</code>也得更新它的<code>previous_entry_length</code>，如此反复更新<code>e3</code>，一直到<code>eN</code></p><p>删除一个节点也一样。</p><p>我们这里提到的是变长的情况，那如果是变短的情况呢，<mark>后面的previous_entry_length会不会变回一个字节？</mark>，答案是不会，因为redis认为这个空间重新分配是很复杂的事，会影响效率，居然它现在能容纳前面节点的长度，那就先用着，避免后面一修改又要去重新分配空间。</p><p>因为连锁更新在最坏情况下需要对压缩列表执行 <code>N</code> 次空间重分配操作， 而每次空间重分配的最坏复杂度为 O(N) ， 所以连锁更新的最坏复杂度为 O(N^2) 。</p><blockquote><p> 这里插一嘴，之前看一个人(<a href="http://zhangtielei.com/posts/blog-redis-ziplist.html">Redis内部数据结构详解(4)——ziplist</a>)对压缩列表插入的源码分析，里面说了是先计算出需要新分配空间后我们再去分配的，当时误解了意思，以为是对后面的每个结点都计算出需要新分配的空间后再去分配新空间。其实不然，实际真的是一个一个节点来分配的。</p></blockquote><p>当然也不用很悲观，上面引用的例子是一个极端的情况，它真正造成性能问题的几率是很低的：</p><ul><li>首先， 压缩列表里要恰好有多个连续的、<strong>长度介于 <code>250</code> 字节至 <code>253</code> 字节之间的节点</strong>， 连锁更新才有可能被引发， 在实际中， 这种情况并不多见；</li><li>其次， 即使出现连锁更新， 但只要被更新的节点数量不多， 就不会对性能造成任何影响： 比如说， 对三五个节点进行连锁更新是绝对不会影响性能的；</li></ul><blockquote><p>至此，redis的基本数据结构告一段落～～🎉</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>打怪升级</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>🏀打造Go的武器--Gorm☢︎</title>
    <link href="/2022/10/11/%E6%89%93%E9%80%A0Go%E7%9A%84%E6%AD%A6%E5%99%A8--Gorm/"/>
    <url>/2022/10/11/%E6%89%93%E9%80%A0Go%E7%9A%84%E6%AD%A6%E5%99%A8--Gorm/</url>
    
    <content type="html"><![CDATA[<p>Go程序的第一把武器：优雅的CRUD，by <strong>Gorm</strong></p><span id="more"></span><h1 id="🏀打造Go的武器–Gorm☢︎"><a href="#🏀打造Go的武器–Gorm☢︎" class="headerlink" title="🏀打造Go的武器–Gorm☢︎"></a>🏀打造Go的武器–Gorm☢︎</h1><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h72mzx624lj30vq0hsgnp.jpg"></p><h2 id="什么是Gorm："><a href="#什么是Gorm：" class="headerlink" title="什么是Gorm："></a>什么是Gorm：</h2><blockquote><p>在用Go开发项目时，我们免不了要和数据库打交道。每种语言都有优秀的ORM可供选择，在Go中也不例外，比如<a href="https://github.com/go-gorm/gorm">gorm</a>、<a href="https://github.com/go-xorm/xorm">xorm</a>、<a href="https://github.com/gohouse/gorose">gorose</a>等。目前，GitHub上 star数最多的是GORM，它也是当前Go项目中使用最多的ORM。</p></blockquote><p>GORM是Go语言的ORM包，功能强大，调用方便。像腾讯、华为、阿里这样的大厂，都在使用GORM来构建企业级的应用。GORM有很多特性，开发中常用的核心特性如下：</p><ul><li>功能全。使用ORM操作数据库的接口，GORM都有，可以满足我们开发中对数据库调用的各类需求。</li><li>支持钩子方法。这些钩子方法可以应用在Create、Save、Update、Delete、Find方法中。</li><li>开发者友好，调用方便。</li><li>支持Auto Migration。</li><li>支持关联查询。</li><li>支持多种关系数据库，例如MySQL、Postgres、SQLite、SQLServer等。</li></ul><p>GORM有两个版本，<a href="https://github.com/jinzhu/gorm">V1</a>和<a href="https://github.com/go-gorm/gorm">V2</a>。遵循用新不用旧的原则，我们学习最新的V2版本。</p><h2 id="快速使用🫥："><a href="#快速使用🫥：" class="headerlink" title="快速使用🫥："></a>快速使用🫥：</h2><p><strong>安装：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>安装gorm包<br>go get -u gorm.io/gorm<br><br><span class="hljs-regexp">//</span>安装mysql数据库驱动<br>go get -u gorm.io<span class="hljs-regexp">/driver/my</span>sql<br></code></pre></td></tr></table></figure><p><strong>使用：</strong></p><p>首先是<strong>导包</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">&quot;gorm.io/driver/mysql&quot;</span><br>  <span class="hljs-string">&quot;gorm.io/gorm&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>然后<strong>定义一个GORM模型</strong>（Models），Models是标准的Go struct，用来代表数据库中的一个表结构。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>  ID <span class="hljs-type">int64</span> <span class="hljs-comment">// 主键</span><br><span class="hljs-comment">//通过在字段后面的标签说明，定义golang字段和表字段的关系</span><br><span class="hljs-comment">//例如 `gorm:&quot;column:username&quot;` 标签说明含义是: 在Mysql中表的列名（字段名)为username</span><br><span class="hljs-comment">//这里golang定义的Username变量和MYSQL表字段username一样，他们的名字可以不一样。</span><br>Username <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;column:username&quot;`</span><br>Password <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;column:password&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>连接数据库：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  username := <span class="hljs-string">&quot;root&quot;</span><br>  password := <span class="hljs-string">&quot;123456&quot;</span><br>  host := <span class="hljs-string">&quot;127.0.0.1&quot;</span><br>  port := <span class="hljs-number">3306</span><br>  Dbname := <span class="hljs-string">&quot;Dbname&quot;</span><br>  <br>  <span class="hljs-comment">// 拼接 mysql dsn，即拼接数据源，下方 &#123;&#125; 中的替换参数即可</span><br>  <span class="hljs-comment">// &#123;username&#125;:&#123;password&#125;@tcp(&#123;host&#125;:&#123;port&#125;)/&#123;Dbname&#125;?charset=utf8&amp;parseTime=True&amp;loc=Local&amp;timeout=10s&amp;readTimeout=30s&amp;writeTimeout=60s</span><br>  <span class="hljs-comment">// timeout 是连接超时时间，readTimeout 是读超时时间，writeTimeout 是写超时时间，可以不填</span><br>  dsn := fmt.Sprintf(<span class="hljs-string">&quot;%s:%s@tcp(%s:%d)/%s?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span>, username, password, host, port, Dbname)<br>  <span class="hljs-comment">// 连接 mysql</span><br>  db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;数据库连接失败, error&quot;</span> + err.Error())<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>正式使用：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">&quot;gorm.io/driver/mysql&quot;</span><br>  <span class="hljs-string">&quot;gorm.io/gorm&quot;</span><br>  <span class="hljs-string">&quot;fmt&quot;</span><br>  <span class="hljs-string">&quot;time&quot;</span><br>  <span class="hljs-string">&quot;errors&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>  ID <span class="hljs-type">int64</span><br>Username <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;column:username&quot;`</span><br>Password <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;column:password&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>username := <span class="hljs-string">&quot;root&quot;</span><br>password := <span class="hljs-string">&quot;123456&quot;</span><br>host := <span class="hljs-string">&quot;127.0.0.1&quot;</span><br>port := <span class="hljs-number">3306</span><br>Dbname := <span class="hljs-string">&quot;Dbname&quot;</span><br>  <br>dsn := fmt.Sprintf(<span class="hljs-string">&quot;%s:%s@tcp(%s:%d)/%s?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span>, username, password, host, port, Dbname)<br>  db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;连接数据库失败, error=&quot;</span> + err.Error())<br>&#125;<br><br><span class="hljs-comment">//定义一个用户，并初始化数据</span><br>u := User&#123;<br>Username:<span class="hljs-string">&quot;tizi365&quot;</span>,<br>Password:<span class="hljs-string">&quot;123456&quot;</span>,<br>&#125;<br><br><span class="hljs-comment">//插入一条用户数据</span><br><span class="hljs-comment">//下面代码会自动生成SQL语句：INSERT INTO `users` (`username`,`password`) VALUES (&#x27;tizi365&#x27;,&#x27;123456&#x27;)</span><br><span class="hljs-keyword">if</span> err := db.Create(&amp;u).Error; err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;插入失败&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>  <br><span class="hljs-comment">//查询并返回第一条数据</span><br>u = User&#123;&#125;<br><span class="hljs-comment">//自动生成sql： SELECT * FROM `users`  WHERE (username = &#x27;tizi365&#x27;) LIMIT 1</span><br>result := db.Where(<span class="hljs-string">&quot;username = ?&quot;</span>, <span class="hljs-string">&quot;tizi365&quot;</span>).First(&amp;u)<br><span class="hljs-keyword">if</span> errors.Is(result.Error, gorm.ErrRecordNotFound) &#123;<br>fmt.Println(<span class="hljs-string">&quot;找不到记录&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(u.Username,u.Password)<br><br><span class="hljs-comment">//更新</span><br><span class="hljs-comment">//自动生成Sql: UPDATE `users` SET `password` = &#x27;654321&#x27;  WHERE (username = &#x27;tizi365&#x27;)</span><br>db.Model(&amp;User&#123;&#125;).Where(<span class="hljs-string">&quot;username = ?&quot;</span>, <span class="hljs-string">&quot;tizi365&quot;</span>).Update(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;654321&quot;</span>)<br><br><span class="hljs-comment">//删除</span><br><span class="hljs-comment">//自动生成Sql： DELETE FROM `users`  WHERE (username = &#x27;tizi365&#x27;)</span><br>db.Where(<span class="hljs-string">&quot;username = ?&quot;</span>, <span class="hljs-string">&quot;tizi365&quot;</span>).Delete(&amp;User&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>在Go项目开发中，使用GORM库主要用来完成以下数据库操作：</p><ul><li>连接和关闭数据库。连接数据库时，可能需要设置一些参数，比如最大连接数、最大空闲连接数、最大连接时长等。</li><li>插入表记录。可以插入一条记录，也可以批量插入记录。</li><li>更新表记录。可以更新某一个字段，也可以更新多个字段。</li><li>查看表记录。可以查看某一条记录，也可以查看符合条件的记录列表。</li><li>删除表记录。可以删除某一个记录，也可以批量删除。删除还支持永久删除和软删除。</li><li>在一些小型项目中，还会用到GORM的表结构自动迁移功能。</li></ul><p>GORM功能强大，上面的示例代码展示的是比较通用的一种操作方式。上面展示的模型定义，连接数据库，增删差改的方法在Gorm中还有很多细节，下面我们开始进一步的学习。</p><h2 id="🤧GORM常用操作讲解："><a href="#🤧GORM常用操作讲解：" class="headerlink" title="🤧GORM常用操作讲解："></a>🤧GORM常用操作讲解：</h2><h3 id="模型定义："><a href="#模型定义：" class="headerlink" title="模型定义："></a>模型定义：</h3><blockquote><p>模型是标准的 struct，由 Go 的<strong>基本数据类型</strong>、实现了 Scanner和 Valuer接口的自定义类型及其指针或别名组成</p></blockquote><p><strong>约定</strong></p><p>GORM 倾向于约定，而不是配置。默认情况下，GORM 使用 <code>ID</code> 作为主键，使用结构体名的 <code>蛇形复数</code> 作为表名，字段名的 <code>蛇形</code> 作为列名，并使用 <code>CreatedAt</code>、<code>UpdatedAt</code> 字段追踪创建、更新时间</p><p>分别的细节：</p><ol><li><p>默认情况下，GORM 会使用 <code>ID</code> 作为表的主键。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>  ID   <span class="hljs-type">string</span> <span class="hljs-comment">// 默认情况下，名为 `ID` 的字段会作为表的主键</span><br>  Name <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p> 不过我们可以使用标签 <code>primaryKey</code> 将其它字段设为主键</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 将 `UID` 设为主键</span><br><span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">struct</span> &#123;<br>  ID     <span class="hljs-type">int64</span><br>  UID   <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;primaryKey&quot;`</span><br>  Name   <span class="hljs-type">string</span><br>  Age    <span class="hljs-type">int64</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用结构体名的 <code>蛇形复数</code> 作为表名，字段名的 <code>蛇形</code> 作为列名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">struct</span> &#123;<br>  AnimalID <span class="hljs-type">int64</span>        <span class="hljs-comment">// 列名 `animal_id`</span><br>  Birthday time.Time    <span class="hljs-comment">// 列名 `birthday`</span><br>  Age      <span class="hljs-type">int64</span>        <span class="hljs-comment">// 列名 `age`</span><br>&#125;<br><span class="hljs-comment">//表名 animals</span><br></code></pre></td></tr></table></figure><p>如果想要自定义，Gorm也提供了相应的方法，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//自定义表名：为结构体定义一个TableName方法，返回表名</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Animal)</span></span> TableName() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;animal&quot;</span><br>&#125;<br><br><span class="hljs-comment">//自定义列名：在结构体的字段上添加关于列名的标签</span><br><span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">struct</span> &#123;<br>    AnimalID <span class="hljs-type">int64</span>     <span class="hljs-string">`gorm:&quot;column:animalID;primarykey&quot;`</span> <span class="hljs-comment">// 将列名设为 `animalID`</span><br>    Birthday time.Time <span class="hljs-string">`gorm:&quot;column:birthday&quot;`</span>            <span class="hljs-comment">// 将列名设为 `birthday`</span><br>    Age      <span class="hljs-type">int64</span>     <span class="hljs-string">`gorm:&quot;column:age&quot;`</span>                 <span class="hljs-comment">// 将列名设为 `age`</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Gorm.Model:</p><p>数据库表通常会包含4个字段。</p><ul><li>ID：自增字段，也作为主键。</li><li>CreatedAt：记录创建时间。</li><li>UpdatedAt：记录更新时间。</li><li>DeletedAt：记录删除时间（软删除时有用）。</li></ul><p>GORM也预定义了包含这4个字段的Models，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// gorm.Model 的定义</span><br><span class="hljs-keyword">type</span> Model <span class="hljs-keyword">struct</span> &#123;<br>  ID        <span class="hljs-type">uint</span>           <span class="hljs-string">`gorm:&quot;primaryKey&quot;`</span><br>  CreatedAt time.Time<br>  UpdatedAt time.Time<br>  DeletedAt gorm.DeletedAt <span class="hljs-string">`gorm:&quot;index&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在我们定义自己的Models时，可以直接内嵌到结构体内，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">struct</span> &#123;<br>    gorm.Model<br>    AnimalID <span class="hljs-type">int64</span>     <span class="hljs-string">`gorm:&quot;column:animalID&quot;`</span> <span class="hljs-comment">// 将列名设为 `animalID`</span><br>    Birthday time.Time <span class="hljs-string">`gorm:&quot;column:birthday&quot;`</span> <span class="hljs-comment">// 将列名设为 `birthday`</span><br>    Age      <span class="hljs-type">int64</span>     <span class="hljs-string">`gorm:&quot;column:age&quot;`</span>      <span class="hljs-comment">// 将列名设为 `age`</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>嵌入结构体：</p><p>对于匿名字段，GORM 会将其字段包含在父结构体中，就是与上面的嵌入gorm.Model一样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//嵌入后的Animal等效于下面这个</span><br><span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">struct</span> &#123;<br>    ID        <span class="hljs-type">uint</span><br>  CreatedAt time.Time<br>  UpdatedAt time.Time<br>  DeletedAt gorm.DeletedAt<br>    AnimalID <span class="hljs-type">int64</span>     <span class="hljs-string">`gorm:&quot;column:animalID&quot;`</span><br>    Birthday time.Time <span class="hljs-string">`gorm:&quot;column:birthday&quot;`</span><br>    Age      <span class="hljs-type">int64</span>     <span class="hljs-string">`gorm:&quot;column:age&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于正常的结构体字段，你也可以通过标签 <code>embedded</code> 将其嵌入，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Author <span class="hljs-keyword">struct</span> &#123;<br>    Name  <span class="hljs-type">string</span><br>    Email <span class="hljs-type">string</span><br>&#125;<br><span class="hljs-keyword">type</span> Blog <span class="hljs-keyword">struct</span> &#123;<br>  ID      <span class="hljs-type">int</span><br>  Author  Author <span class="hljs-string">`gorm:&quot;embedded&quot;`</span><br>  Upvotes <span class="hljs-type">int32</span><br>&#125;<br><span class="hljs-comment">// 等效于</span><br><span class="hljs-keyword">type</span> Blog <span class="hljs-keyword">struct</span> &#123;<br>  ID    <span class="hljs-type">int64</span><br>  Name  <span class="hljs-type">string</span><br>  Email <span class="hljs-type">string</span><br>  Upvotes  <span class="hljs-type">int32</span><br>&#125;<br></code></pre></td></tr></table></figure><p>并且，还可以使用标签 <code>embeddrefix</code> 来为 db 中的字段名添加前缀，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Blog <span class="hljs-keyword">struct</span> &#123;<br>  ID      <span class="hljs-type">int</span><br>  Author  Author <span class="hljs-string">`gorm:&quot;embedded;embeddedPrefix:author_&quot;`</span><br>  Upvotes <span class="hljs-type">int32</span><br>&#125;<br><span class="hljs-comment">// 等效于</span><br><span class="hljs-keyword">type</span> Blog <span class="hljs-keyword">struct</span> &#123;<br>  ID          <span class="hljs-type">int64</span><br>    AuthorName  <span class="hljs-type">string</span><br>    AuthorEmail <span class="hljs-type">string</span><br>  Upvotes     <span class="hljs-type">int32</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>字段标签</p><p>Models中的字段能支持很多GORM标签，但如果我们不使用GORM自动创建表和迁移表结构的功能，很多标签我们实际上是用不到的。在开发中，用得最多的是 <code>column</code> 标签。具体如下：</p><table><thead><tr><th align="left">标签名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">column</td><td align="left">指定 db 列名</td></tr><tr><td align="left">type</td><td align="left">列数据类型，推荐使用兼容性好的通用类型，例如：bool、int、uint、float、string、time、bytes。并可与其他标签一起使用，例如：<code>not null</code>、<code>size</code>, <code>autoIncrement</code>… 像 <code>varbinary(8)</code> 这样指定数据库数据类型也是支持的。在使用指定数据库数据类型时，它需要是完整的数据库数据类型，如：<code>MEDIUMINT UNSINED not NULL AUTO_INSTREMENT</code></td></tr><tr><td align="left">size</td><td align="left">指定列大小，例如：<code>size:256</code></td></tr><tr><td align="left">primaryKey</td><td align="left">指定列为主键</td></tr><tr><td align="left">unique</td><td align="left">指定列为唯一</td></tr><tr><td align="left">default</td><td align="left">指定列的默认值</td></tr><tr><td align="left">precision</td><td align="left">指定列的精度</td></tr><tr><td align="left">not null</td><td align="left">指定列为 NOT NULL</td></tr><tr><td align="left">autoIncrement</td><td align="left">指定列为自动增长</td></tr><tr><td align="left">embedded</td><td align="left">嵌套字段</td></tr><tr><td align="left">embeddedPrefix</td><td align="left">嵌套字段的前缀</td></tr><tr><td align="left">autoCreateTime</td><td align="left">track current time when creating, for <code>int</code> fields, it will track unix seconds, use value <code>nano</code>&#x2F;<code>milli</code> to track unix nano&#x2F;milli seconds, e.g: <code>autoCreateTime:nano</code></td></tr><tr><td align="left">autoUpdateTime</td><td align="left">track current time when creating&#x2F;updating, for <code>int</code> fields, it will track unix seconds, use value <code>nano</code>&#x2F;<code>milli</code> to track unix nano&#x2F;milli seconds, e.g: <code>autoUpdateTime:milli</code></td></tr><tr><td align="left">index</td><td align="left">根据参数创建索引，多个字段拥有相同的名称则创建复合索引，参考 <a href="https://www.bookstack.cn/read/gorm-2.0/$docs-indexes.html">索引</a> 获取详情</td></tr><tr><td align="left">uniqueIndex</td><td align="left">与 <code>index</code> 相同，但创建的是唯一索引</td></tr><tr><td align="left">check</td><td align="left">创建检查约束，例如 <code>check:(age &gt; 13)</code>，查看 <a href="https://www.bookstack.cn/read/gorm-2.0/$docs-constraints.html">约束</a> 获取详情</td></tr><tr><td align="left">&lt;-</td><td align="left">设置字段写入的权限， <code>&lt;-:create</code> 只创建、<code>&lt;-:update</code> 只更新、<code>&lt;-:false</code> 无权限</td></tr><tr><td align="left">-&gt;</td><td align="left">设置字段读取权限</td></tr><tr><td align="left">-</td><td align="left">忽略此字段（禁止读写）</td></tr></tbody></table></li></ol><h3 id="连接数据库："><a href="#连接数据库：" class="headerlink" title="连接数据库："></a>连接数据库：</h3><ol><li>就像快速使用的例子一样，我们可以这样直接连接数据库：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">&quot;gorm.io/driver/mysql&quot;</span><br>  <span class="hljs-string">&quot;gorm.io/gorm&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">// 参考 https://github.com/go-sql-driver/mysql#dsn-data-source-name 获取详情</span><br>  dsn := <span class="hljs-string">&quot;user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span><br>  db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要GORM正确地处理 <code>time.Time</code> 类型，在连接数据库时需要带上 <code>parseTime</code> 参数(通常都要加的，这样Gorm就支持把数据库datetime和date类型转换为golang的time.Time类型，不然会出现一堆奇奇怪怪的问题)。如果要支持完整的UTF-8编码，可将<code>charset=utf8</code>更改为<code>charset=utf8mb4</code>（为了避免乱码，可以mysql字符集那篇博客)。</p><ol start="2"><li><strong>gorm调试模式：</strong></li></ol><p>为了方便调试，了解gorm操作到底执行了怎么样的sql语句，<strong>开发的时候</strong>需要打开调试日志，这样gorm会打印出执行的每一条sql语句。使用Debug函数执行查询即可，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">result := db.Debug().Where(<span class="hljs-string">&quot;username = ?&quot;</span>, <span class="hljs-string">&quot;tizi365&quot;</span>).First(&amp;u)<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>gorm连接池:</strong></li></ol><p>在高并发实践中，为了提高数据库连接的使用率，避免重复建立数据库连接带来的性能消耗，会经常使用数据库连接池技术来维护数据库连接。<br>gorm自带了数据库连接池使用非常简单只要设置下数据库连接池参数即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">sqlDB, err := db.DB()<br>sqlDB.SetMaxIdleConns(<span class="hljs-number">10</span>)              <span class="hljs-comment">// 设置MySQL的最大空闲连接数（推荐10）</span><br>sqlDB.SetMaxOpenConns(<span class="hljs-number">100</span>)             <span class="hljs-comment">// 设置MySQL的最大连接数（推荐100）</span><br>sqlDB.SetConnMaxLifetime(time.Hour)    <span class="hljs-comment">// 设置MySQL的空闲连接最大存活时间（推荐10s）</span><br></code></pre></td></tr></table></figure><p>具体使用例子如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//定义一个工具包，用来管理gorm数据库连接池的初始化工作。</span><br><span class="hljs-keyword">package</span> tools<br><br><span class="hljs-comment">//定义全局的db对象，我们执行数据库操作主要通过他实现。</span><br><span class="hljs-keyword">var</span> _db *gorm.DB<br><br><span class="hljs-comment">//包初始化函数，golang特性，每个包初始化的时候会自动执行init函数，这里用来初始化gorm。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    ...忽略dsn配置，请参考上面例子...<br>    <br>    <span class="hljs-comment">// 声明err变量，下面不能使用:=赋值运算符，否则_db变量会当成局部变量，导致外部无法访问_db变量</span><br>    <span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>    <span class="hljs-comment">//连接MYSQL, 获得DB类型实例，用于后面的数据库读写操作。</span><br>    _db, err = gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;连接数据库失败, error=&quot;</span> + err.Error())<br>&#125;<br>     <br>    sqlDB, _ := db.DB()  <span class="hljs-comment">//注意：这里的db可和上面的_db不是同个东西</span><br><br>    <span class="hljs-comment">//设置数据库连接池参数</span><br>    sqlDB.SetMaxOpenConns(<span class="hljs-number">100</span>)   <span class="hljs-comment">//设置数据库连接池最大连接数</span><br>    sqlDB.SetMaxIdleConns(<span class="hljs-number">10</span>)   <span class="hljs-comment">//连接池最大允许的空闲连接数，如果没有sql任务需要执行的连接数大于20，超过的连接会被连接池关闭。</span><br>&#125;<br><br><span class="hljs-comment">//获取gorm db对象，其他包需要执行数据库查询的时候，只要通过tools.getDB()获取db对象即可。</span><br><span class="hljs-comment">//不用担心协程并发使用同样的db对象会共用同一个连接，db对象在调用他的方法的时候会从数据库连接池中获取新的连接</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetDB</span><span class="hljs-params">()</span></span> *gorm.DB &#123;<br><span class="hljs-keyword">return</span> _db<br>&#125;<br></code></pre></td></tr></table></figure><p>使用例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-comment">//导入tools包</span><br><span class="hljs-keyword">import</span> tools<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">//获取DB</span><br>  db := tools.GetDB()<br>  <span class="hljs-comment">//执行数据库查询操作</span><br>  u := User&#123;&#125;<br><span class="hljs-comment">//自动生成sql： SELECT * FROM `users`  WHERE (username = &#x27;tizi365&#x27;) LIMIT 1</span><br>db.Where(<span class="hljs-string">&quot;username = ?&quot;</span>, <span class="hljs-string">&quot;tizi365&quot;</span>).First(&amp;u)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建记录："><a href="#创建记录：" class="headerlink" title="创建记录："></a>创建记录：</h3><ol><li>我们可以通过 <code>db.Create</code> 方法来创建一条记录：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>  gorm.Model<br>  Name         <span class="hljs-type">string</span><br>  Age          <span class="hljs-type">uint8</span><br>  Birthday     *time.Time<br>&#125;<br>user := User&#123;Name: <span class="hljs-string">&quot;Jinzhu&quot;</span>, Age: <span class="hljs-number">18</span>, Birthday: time.Now()&#125;<br>result := db.Create(&amp;user) <span class="hljs-comment">// 通过数据的指针来创建</span><br></code></pre></td></tr></table></figure><p>db.Create函数会返回如下3个值：</p><ul><li>user.ID：返回插入数据的主键，这个是直接赋值给user变量。</li><li>result.Error：返回error。</li><li>result.RowsAffected：返回插入记录的条数。</li></ul><ol start="2"><li>当需要插入的数据量比较大时，可以批量插入，以提高插入性能：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> users = []User&#123;&#123;Name: <span class="hljs-string">&quot;jinzhu1&quot;</span>&#125;, &#123;Name: <span class="hljs-string">&quot;jinzhu2&quot;</span>&#125;, &#123;Name: <span class="hljs-string">&quot;jinzhu3&quot;</span>&#125;&#125;<br>DB.Create(&amp;users)<br><br><span class="hljs-keyword">for</span> _, user := <span class="hljs-keyword">range</span> users &#123;<br>  user.ID <span class="hljs-comment">// 1,2,3</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除记录："><a href="#删除记录：" class="headerlink" title="删除记录："></a>删除记录：</h3><ol><li>我们可以通过Delete方法删除记录：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// DELETE from users where id = 10 AND name = &quot;jinzhu&quot;;</span><br>db.Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;jinzhu&quot;</span>).Delete(&amp;User&#123;&#125;)<br></code></pre></td></tr></table></figure><p>GORM也支持根据主键进行删除，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// DELETE FROM users WHERE id = 10;</span><br>db.Delete(&amp;User&#123;&#125;, <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>不过，更推荐使用db.Where的方式进行删除，这种方式有两个优点。</p><p>第一个优点是删除方式更通用。使用db.Where不仅可以根据主键删除，还能够随意组合条件进行删除。</p><p>第二个优点是删除方式更显式，这意味着更易读。如果使用<code>db.Delete(&amp;User&#123;&#125;, 10)</code>，你还需要确认User的主键，如果记错了主键，还可能会引入Bug。</p><p>此外，GORM也支持批量删除：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Where(<span class="hljs-string">&quot;name in (?)&quot;</span>, []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;jinzhu&quot;</span>, <span class="hljs-string">&quot;colin&quot;</span>&#125;).Delete(&amp;User&#123;&#125;)<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>软硬删除：</strong></li></ol><p>软删除是指执行Delete时，记录不会被从数据库中真正删除。GORM会将 <code>DeletedAt</code> 设置为当前时间，并且不能通过正常的方式查询到该记录。<strong>怎么触发软删除呢？</strong>如果模型包含了一个 <code>gorm.DeletedAt</code> 字段，那么GORM在执行删除操作时，就会软删除该记录。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// UPDATE users SET deleted_at=&quot;2013-10-29 10:23&quot; WHERE age = 20;</span><br>db.Where(<span class="hljs-string">&quot;age = ?&quot;</span>, <span class="hljs-number">20</span>).Delete(&amp;User&#123;&#125;)<br><br><span class="hljs-comment">// SELECT * FROM users WHERE age = 20 AND deleted_at IS NULL;</span><br>db.Where(<span class="hljs-string">&quot;age = 20&quot;</span>).Find(&amp;user)<br></code></pre></td></tr></table></figure><p>可以看到，GORM并没有真正把记录从数据库删除掉，而是只更新了 <code>deleted_at</code> 字段。在查询时，GORM查询条件中新增了<code>AND deleted_at IS NULL</code>条件，所以这些被设置过 <code>deleted_at</code> 字段的记录不会被查询到。对于一些比较重要的数据，我们可以通过软删除的方式删除记录，软删除可以使这些重要的数据后期能够被恢复，并且便于以后的排障。</p><p>我们也可以通过下面的方式查找被软删除的记录：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// SELECT * FROM users WHERE age = 20;</span><br>db.Unscoped().Where(<span class="hljs-string">&quot;age = 20&quot;</span>).Find(&amp;users)<br></code></pre></td></tr></table></figure><p><strong>永久删除:</strong></p><p>如果想永久删除一条记录，可以使用Unscoped：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// DELETE FROM orders WHERE id=10;</span><br>db.Unscoped().Delete(&amp;order)<br></code></pre></td></tr></table></figure><p>或者，也可以在模型中去掉gorm.DeletedAt。</p><h3 id="更新记录："><a href="#更新记录：" class="headerlink" title="更新记录："></a>更新记录：</h3><ol><li>GORM中，<strong>最常用的更新方法</strong>如下：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//先找到那条记录，赋值于结构体中</span><br>db.First(&amp;user)<br><span class="hljs-comment">//修改结构体的值</span><br>user.Name = <span class="hljs-string">&quot;jinzhu 2&quot;</span><br>user.Age = <span class="hljs-number">100</span><br><span class="hljs-comment">// UPDATE users SET name=&#x27;jinzhu 2&#x27;, age=100, birthday=&#x27;2016-01-01&#x27;, updated_at = &#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span><br>db.Save(&amp;user)<br></code></pre></td></tr></table></figure><p>上述方法会保留所有字段，所以执行Save时，需要先执行First，获取某个记录的所有列的值，然后再对需要更新的字段设置值。</p><ol start="2"><li><strong>还可以指定更新单个列：</strong></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// UPDATE users SET age=200, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE name=&#x27;colin&#x27;;</span><br>db.Model(&amp;User&#123;&#125;).Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;colin&quot;</span>).Update(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">200</span>)<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>也可以指定更新多个列：</strong></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18, updated_at = &#x27;2013-11-17 21:34:10&#x27; WHERE name = &#x27;colin&#x27;;</span><br>db.Model(&amp;user).Where(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;colin&quot;</span>).Updates(User&#123;Name: <span class="hljs-string">&quot;hello&quot;</span>, Age: <span class="hljs-number">18</span>, Active: <span class="hljs-literal">false</span>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>提示： 通过结构体变量更新字段值, gorm库会忽略零值字段。就比如如果我们想一个字段的值改为0，那用结构体就行不通了，字段值等于0, nil, “”, false这些值会被忽略掉，不会更新。如果想更新零值，可以使用map类型替代结构体。</p></blockquote><ol start="4"><li><strong>更新表达式</strong>:</li></ol><p><em>UPDATE <code>foods</code> SET <code>stock</code> &#x3D; <code>stock</code> + 1 WHERE id &#x3D; ‘2’</em><br>这样的带计算表达式的更新语句gorm怎么写？</p><p><del>挺重要‼️的哦，而且挺常用的，之前就有搜过这个</del></p><p>gorm提供了Expr函数用于设置表达式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//等价于: UPDATE `foods` SET `stock` = stock + 1  WHERE `foods`.`id` = &#x27;2&#x27;</span><br>db.Model(&amp;food).Update(<span class="hljs-string">&quot;stock&quot;</span>, gorm.Expr(<span class="hljs-string">&quot;stock + 1&quot;</span>))<br></code></pre></td></tr></table></figure><h3 id="查询数据："><a href="#查询数据：" class="headerlink" title="查询数据："></a>查询数据：</h3><p>GORM支持不同的查询方法，下面我来讲解三种在开发中经常用到的查询方式，分别是检索单个记录、查询所有符合条件的记录和智能选择字段。</p><ol><li>检索单个记录</li></ol><p>下面是检索单个记录的示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 获取根据主键排序的第一条记录（主键升序）</span><br><span class="hljs-comment">// 如果model类型没有定义主键，则按第一个字段排序。</span><br><span class="hljs-comment">// SELECT * FROM users ORDER BY id LIMIT 1;</span><br>db.First(&amp;user)<br><br><span class="hljs-comment">// 获取最后一条记录（主键降序）</span><br><span class="hljs-comment">// SELECT * FROM users ORDER BY id DESC LIMIT 1;</span><br>db.Last(&amp;user)<br>result := db.First(&amp;user)<br>result.RowsAffected <span class="hljs-comment">// 返回找到的记录数</span><br>result.Error        <span class="hljs-comment">// returns error</span><br><br><span class="hljs-comment">// 检查 ErrRecordNotFound 错误</span><br>errors.Is(result.Error, gorm.ErrRecordNotFound)<br><br><span class="hljs-comment">//下面这种方式也较为常见</span><br>err := db.Take(&amp;food).Error   <span class="hljs-comment">//Take是随机获取一条数据</span><br><span class="hljs-keyword">if</span> errors.Is(err, gorm.ErrRecordNotFound) &#123;<br>    fmt.Println(<span class="hljs-string">&quot;查询不到数据&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">//如果err不等于record not found错误，又不等于nil，那说明sql执行失败了。</span><br>fmt.Println(<span class="hljs-string">&quot;查询失败&quot;</span>, err)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>查询所有符合条件的记录</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">users := <span class="hljs-built_in">make</span>([]*User, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment">// SELECT * FROM users WHERE name &lt;&gt; &#x27;jinzhu&#x27;;</span><br>db.Where(<span class="hljs-string">&quot;name &lt;&gt; ?&quot;</span>, <span class="hljs-string">&quot;jinzhu&quot;</span>).Find(&amp;users)<br></code></pre></td></tr></table></figure><ol start="3"><li>智能选择字段</li></ol><p>你可以通过Select方法，选择特定的字段。我们可以定义一个较小的结构体来接受选定的字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> APIUser <span class="hljs-keyword">struct</span> &#123;<br>  ID   <span class="hljs-type">uint</span><br>  Name <span class="hljs-type">string</span><br>&#125;<br>user:=APIUser&#123;&#125;<br>db.Select(<span class="hljs-string">&quot;id,name&quot;</span>).Where(<span class="hljs-string">&quot;id = ?&quot;</span>, <span class="hljs-number">1</span>).Take(&amp;user)<br><br><span class="hljs-comment">//例子2:</span><br><span class="hljs-comment">//可以直接书写聚合语句</span><br><span class="hljs-comment">//等价于: SELECT count(*) as total FROM `foods`</span><br>total := []<span class="hljs-type">int</span>&#123;&#125;<br><br><span class="hljs-comment">//Model函数，用于指定绑定的模型，这里生成了一个Food&#123;&#125;变量。目的是从模型变量里面提取表名，Pluck函数我们没有直接传递绑定表名的结构体变量，gorm库不知道表名是什么，所以这里需要指定表名</span><br><span class="hljs-comment">//Pluck函数，主要用于查询一列值</span><br>db.Model(&amp;Food&#123;&#125;).Select(<span class="hljs-string">&quot;count(*) as total&quot;</span>).Pluck(<span class="hljs-string">&quot;total&quot;</span>, &amp;total)<br><span class="hljs-comment">//这里就是我们计算出total后，我们从返回结果中取出total列的值</span><br>fmt.Println(total[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><p>除了上面讲的三种常用的基本查询方法，GORM还支持高级查询</p><ol><li>指定检索记录时的排序方式</li></ol><p>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// SELECT * FROM users ORDER BY age desc, name;</span><br>db.Order(<span class="hljs-string">&quot;age desc, name&quot;</span>).Find(&amp;users)<br></code></pre></td></tr></table></figure><ol start="2"><li>Limit &amp; Offset</li></ol><p>Offset指定从第几条记录开始查询，Limit指定返回的最大记录数。Offset和Limit值为-1时，消除Offset和Limit条件。另外，Limit和Offset位置不同，效果也不同。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// SELECT * FROM users OFFSET 5 LIMIT 10;</span><br>db.Limit(<span class="hljs-number">10</span>).Offset(<span class="hljs-number">5</span>).Find(&amp;users)<br></code></pre></td></tr></table></figure><ol start="3"><li>Distinct</li></ol><p>Distinct可以从数据库记录中选择不同的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Distinct(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>).Order(<span class="hljs-string">&quot;name, age desc&quot;</span>).Find(&amp;results)<br></code></pre></td></tr></table></figure><ol start="4"><li>Count</li></ol><p>Count可以获取匹配的条数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> count <span class="hljs-type">int64</span><br><span class="hljs-comment">// SELECT count(1) FROM users WHERE name = &#x27;jinzhu&#x27;; (count)</span><br>db.Model(&amp;User&#123;&#125;).Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;jinzhu&quot;</span>).Count(&amp;count)<br></code></pre></td></tr></table></figure><p>5.Group</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//例子:</span><br><span class="hljs-comment">//统计每个商品分类下面有多少个商品</span><br><span class="hljs-comment">//定一个Result结构体类型，用来保存查询结果</span><br><span class="hljs-keyword">type</span> Result <span class="hljs-keyword">struct</span> &#123;<br>    Type  <span class="hljs-type">int</span><br>    Total <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> results []Result<br><span class="hljs-comment">//等价于: SELECT type, count(*) as  total FROM `foods` GROUP BY type HAVING (total &gt; 0)</span><br>db.Model(Food&#123;&#125;).Select(<span class="hljs-string">&quot;type, count(*) as  total&quot;</span>).Group(<span class="hljs-string">&quot;type&quot;</span>).Having(<span class="hljs-string">&quot;total &gt; 0&quot;</span>).Scan(&amp;results)<br><br><span class="hljs-comment">//scan类似Find都是用于执行查询语句，然后把查询结果赋值给结构体变量，区别在于scan不会从传递进来的结构体变量提取表名.</span><br><span class="hljs-comment">//这里因为我们重新定义了一个结构体用于保存结果，但是这个结构体并没有绑定foods表，所以这里只能使用scan查询函数。</span><br></code></pre></td></tr></table></figure><p>GORM还支持很多高级查询功能，比如内联条件、Not 条件、Or 条件、Joins、FirstOrInit、FirstOrCreate、迭代、FindInBatches等。因为IAM项目中没有用到这些高级特性，我在这里就不展开介绍了。你如果感兴趣，可以看下<a href="https://gorm.io/zh_CN/docs/index.html">GORM的官方文档</a>。</p><h3 id="原生SQL"><a href="#原生SQL" class="headerlink" title="原生SQL"></a>原生SQL</h3><p>GORM支持原生查询SQL和执行SQL。原生查询SQL用法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Result <span class="hljs-keyword">struct</span> &#123;<br>  ID   <span class="hljs-type">int</span><br>  Name <span class="hljs-type">string</span><br>  Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> result Result<br>db.Raw(<span class="hljs-string">&quot;SELECT id, name, age FROM users WHERE name = ?&quot;</span>, <span class="hljs-number">3</span>).Scan(&amp;result)<br></code></pre></td></tr></table></figure><p>原生执行SQL用法如下；</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">db<span class="hljs-selector-class">.Exec</span>(<span class="hljs-string">&quot;DROP TABLE users&quot;</span>)<br>db<span class="hljs-selector-class">.Exec</span>(<span class="hljs-string">&quot;UPDATE orders SET shipped_at=? WHERE id IN ?&quot;</span>, <span class="hljs-selector-tag">time</span><span class="hljs-selector-class">.Now</span>(), <span class="hljs-selector-attr">[]</span>int64&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;)<br></code></pre></td></tr></table></figure><h2 id="⭐️高级操作："><a href="#⭐️高级操作：" class="headerlink" title="⭐️高级操作："></a>⭐️高级操作：</h2><h3 id="🪝钩子："><a href="#🪝钩子：" class="headerlink" title="🪝钩子："></a>🪝钩子：</h3><p>钩子是在创建、查询、更新、删除等操作之前、之后调用的函数。</p><p>如果您已经为模型定义了指定的方法，它会在创建、更新、查询、删除时自动被调用。如<strong>果任何回调返回错误，GORM 将停止后续的操作并回滚事务。</strong></p><p>钩子方法的函数签名应该是 <code>func(*gorm.DB) error</code></p><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象:"></a>创建对象:</h4><p>创建时可用的钩子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 开始事务</span><br>BeforeSave<br>BeforeCreate<br><span class="hljs-comment">// 关联前的 save</span><br><span class="hljs-comment">// 插入记录至 db</span><br><span class="hljs-comment">// 关联后的 save</span><br>AfterCreate<br>AfterSave<br><span class="hljs-comment">// 提交或回滚事务</span><br><br></code></pre></td></tr></table></figure><p>以下面的代码为例，在创建用户前会申请一个uuid，如果申请失败则会报错回滚，且在成功创建后对id进行判断，进行后续操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *User)</span></span> BeforeCreate(tx *gorm.DB) (err <span class="hljs-type">error</span>) &#123;<br>  u.UUID = uuid.New()<br><br>  <span class="hljs-keyword">if</span> !u.IsValid() &#123;<br>    err = errors.New(<span class="hljs-string">&quot;can&#x27;t save invalid data&quot;</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *User)</span></span> AfterCreate(tx *gorm.DB) (err <span class="hljs-type">error</span>) &#123;<br>  <span class="hljs-keyword">if</span> u.ID == <span class="hljs-number">1</span> &#123;<br>    tx.Model(u).Update(<span class="hljs-string">&quot;role&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> 在 GORM 中保存、删除操作会默认运行在事务上， 因此在事务完成之前该事务中所作的更改是不可见的，如果您的钩子返回了任何错误，则修改将被回滚。</p></blockquote><p>其他类型的操作是相似于上面的，这里就只贴出他们可用的钩子：</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h72lz1oz47j310o0ny0vi.jpg"></p><h3 id="事务："><a href="#事务：" class="headerlink" title="事务："></a>事务：</h3><h4 id="自动事务："><a href="#自动事务：" class="headerlink" title="自动事务："></a>自动事务：</h4><p>通过db.Transaction函数实现事务，如果闭包任何一个函数返回错误，则回滚事务。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Transaction(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(tx *gorm.DB)</span></span> <span class="hljs-type">error</span> &#123;<br>  <span class="hljs-comment">// 在事务中执行一些 db 操作（从这里开始，您应该使用 &#x27;tx&#x27; 而不是 &#x27;db&#x27;）</span><br>  <span class="hljs-keyword">if</span> err := tx.Create(&amp;Animal&#123;Name: <span class="hljs-string">&quot;Giraffe&quot;</span>&#125;).Error; err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// 返回任何错误都会回滚事务</span><br>    <span class="hljs-keyword">return</span> err<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> err := tx.Create(&amp;Animal&#123;Name: <span class="hljs-string">&quot;Lion&quot;</span>&#125;).Error; err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> err<br>  &#125;<br><br>  <span class="hljs-comment">// 返回 nil 提交事务</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="手动事务："><a href="#手动事务：" class="headerlink" title="手动事务："></a>手动事务：</h4><p>在开发中经常需要数据库事务来保证多个数据库写操作的原子性。例如电商系统中的扣减库存和保存订单。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 开启事务</span><br>tx := db.Begin()<br><br><span class="hljs-comment">//在事务中执行数据库操作，使用的是tx变量，不是db。</span><br><br><span class="hljs-comment">//库存减一</span><br><span class="hljs-comment">//等价于: UPDATE `foods` SET `stock` = stock - 1  WHERE `foods`.`id` = &#x27;2&#x27; and stock &gt; 0</span><br><span class="hljs-comment">//RowsAffected用于返回sql执行后影响的行数</span><br>rowsAffected := tx.Model(&amp;food).Where(<span class="hljs-string">&quot;stock &gt; 0&quot;</span>).Update(<span class="hljs-string">&quot;stock&quot;</span>, gorm.Expr(<span class="hljs-string">&quot;stock - 1&quot;</span>)).RowsAffected<br><span class="hljs-keyword">if</span> rowsAffected == <span class="hljs-number">0</span> &#123;<br>    <span class="hljs-comment">//如果更新库存操作，返回影响行数为0，说明没有库存了，结束下单流程</span><br>    <span class="hljs-comment">//这里回滚作用不大，因为前面没成功执行什么数据库更新操作，也没什么数据需要回滚。</span><br>    <span class="hljs-comment">//这里就是举个例子，事务中可以执行多个sql语句，错误了可以回滚事务</span><br>    tx.Rollback()<br>    <span class="hljs-keyword">return</span><br>&#125;<br>err := tx.Create(保存订单).Error<br><br><span class="hljs-comment">//保存订单失败，则回滚事务</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    tx.Rollback()<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    tx.Commit()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="✨错误处理："><a href="#✨错误处理：" class="headerlink" title="✨错误处理："></a>✨错误处理：</h2><blockquote><p>在上面的查询数据里我们已经有提到错误处理了，其实那就是全部了，我们在这里再单独总结下～～～～</p></blockquote><h3 id="错误处理："><a href="#错误处理：" class="headerlink" title="错误处理："></a>错误处理：</h3><p>如果遇到任何错误，GORM 会将错误信息保存到 *gorm.DB 的Error字段，我们只要检测Error字段就可以知道是否存在错误。即：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err := db.Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;tizi365&quot;</span>).First(&amp;user).Error; err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-comment">// 错误处理</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ErrRecordNotFound-error："><a href="#ErrRecordNotFound-error：" class="headerlink" title="ErrRecordNotFound error："></a>ErrRecordNotFound error：</h3><p>当 <code>First</code>、<code>Last</code>、<code>Take</code> 方法找不到记录时，GORM 会返回 <code>ErrRecordNotFound</code> 错误。如果发生了多个错误，你可以通过 <code>errors.Is</code> 判断错误是否为 <code>ErrRecordNotFound</code>，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 检查错误是否为 RecordNotFound</span><br>err := db.First(&amp;user, <span class="hljs-number">100</span>).Error<br>errors.Is(err, gorm.ErrRecordNotFound)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>Gorm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Gorm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>🍟Mysql--乱码的前世今生-字符集和比较规则</title>
    <link href="/2022/09/24/Mysql--%E4%B9%B1%E7%A0%81%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F-%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/"/>
    <url>/2022/09/24/Mysql--%E4%B9%B1%E7%A0%81%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F-%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="🍟Mysql–乱码的前世今生-字符集和比较规则"><a href="#🍟Mysql–乱码的前世今生-字符集和比较规则" class="headerlink" title="🍟Mysql–乱码的前世今生-字符集和比较规则"></a>🍟Mysql–乱码的前世今生-字符集和比较规则</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6imy0r024j20vq0hsaah.jpg"></p><h2 id="字符集："><a href="#字符集：" class="headerlink" title="字符集："></a>字符集：</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>众所周知计算机中能存储的只有二进制的数据，那我们怎么存储字符串的呢？答案是我们建立了一种规则来将字符串映射为二进制数据。字符有那么多，总不可能所有都包含进来吧，几乎这两点我们就能得到字符集一个言简意赅的定义：<strong>某个字符范围的编码规则</strong>。</p><h3 id="一些重要的字符集："><a href="#一些重要的字符集：" class="headerlink" title="一些重要的字符集："></a>一些重要的字符集：</h3><p>对于同一个字符，不同的人为了达到不同的目的，人们设置了很多种字符集。下面是一些常见的字符集：</p><ul><li><p>ASCII字符集：共收录128个字符，包括空格、标点符号、数字、大小写字母和一些不可见字符。由于总共才128个字符，所以仅使用一个字节来编码。</p></li><li><p>GB2312字符集：收录了汉字以及拉丁字母、希腊字母、日文平假名及片假名字母，俄语西里尔字母。其中汉字6763个，其他文字符号682个。同时这种字符集又兼容ASCII字符集，所以在编码上有些奇怪：</p><ul><li>如果该字符在ASCII字符集中，那么将采用一个字节来编码</li><li>其他都为2个字节</li></ul><p>这里我们发现了个新概念：变长编码方式，即在一个字符集中表示一个字符所需要的字节数可能不同。</p></li><li><p>GBK字符集：在GB2312上进行了扩产，编码上兼容GB2312</p></li><li><p>utf8字符集：收录了地球上能想到的所有字符，而且还在不断扩充，一样地兼容了ASCII字符集，采用变长编码方式，编码一个字符需要使用1-4个字节</p></li></ul><h3 id="Mysql支持的字符集："><a href="#Mysql支持的字符集：" class="headerlink" title="Mysql支持的字符集："></a>Mysql支持的字符集：</h3><p>首先我们解决一个疑惑：utf8mb3与utf8mb4。</p><p>上面我们提到utf8字符集采用了变长编码方式，一个字符可能由1-4字节编码，但是其实我们常用的字符用1-3个字节就足够编码了，而在Mysql中一个字符编码所用最大字节长度在某些方面会影响系统的存储和性能所以，Mysql设立了以上两种概念：</p><ul><li>Utf8mb3: 其实就是utf8的阉割版，只使用1-3个字节表示字符。</li><li>Utf8mb4: 真正的utf8。</li></ul><p>在Mysql中，utf8实际上指的是utf8mb3，是它的一个别名，如果有要用4个字节编码的情况，例如存emoji表情，那一定要明确指定utf8mb4。</p><p>接着我们了解下查看字符集的指令：<code>SHOW (CHARACTER SET|CHARSET)[LIKE 匹配的模式] </code>CHARACTER SET和CHARSET是同义词，用哪个都行。</p><h2 id="比较规则："><a href="#比较规则：" class="headerlink" title="比较规则："></a>比较规则：</h2><h3 id="简介：-1"><a href="#简介：-1" class="headerlink" title="简介："></a>简介：</h3><p>在字符串被编码为相应的二进制数据后，如何比较字符的大小就是比较规则的事了，最简单的莫过于直接比较二进制编码的大小，而这种情况并不是一直都可以，比如我们有时的业务逻辑是将’a’与’A’认为是相等的，我们要怎样解决呢，将所有的字符都转换为大写或小写，再进行比较，这还算简单，就是转换下大小写，实际的情况是英文字符不止一种，汉字有几万个，所以人们为了达到适当的比较的目的，设计了很多比较规则，一个字符集就可以拥有多个比较规则。</p><h3 id="查看比较规则："><a href="#查看比较规则：" class="headerlink" title="查看比较规则："></a>查看比较规则：</h3><p>SHOW COLLATION [LIKE 匹配模式]，就可以看到系统支持的比较规则，可以注意到，一个字符集可以有多个比较规则，比较规则名称的前缀就是相应的字符集，而且每个字符集都有一个默认的比较规则。</p><h2 id="字符集和比较规则的应用："><a href="#字符集和比较规则的应用：" class="headerlink" title="字符集和比较规则的应用："></a>字符集和比较规则的应用：</h2><h3 id="各级别的字符集和比较规则："><a href="#各级别的字符集和比较规则：" class="headerlink" title="各级别的字符集和比较规则："></a>各级别的字符集和比较规则：</h3><p>在Mysql中字符集的级别分为：服务器级别，数据库级别，表级别，列级别。优先级越来越大，比如如果有设置了数据库级别的字符集那就不会去用服务器级别，如果没有设置那就用服务器级别的字符集。比较规则也同理。服务器级别和其它几个级别的设置方式有点不同，具体如下：</p><ul><li>服务器级别：服务器级别的在启动选项中设置，例如在配置选项中写入 character_set_server&#x3D;字符集名称，collaction_set_server&#x3D;比较规则。</li><li>其它：在创建时可以指明，也可以在后续进行更改，例如<code>CHARCTER SET GB2312 和 COLLATE gb2312_chinese_ci</code></li><li>可以通过相应的系统变量(SHOW VARIABLES [LIKE 匹配模式])查看各级别当前的字符集，具体如下：<ul><li>服务器级别：SHOW VARIABLES LIKE ‘character_set_server’，便可查看，同样的还有’character_set_collaction’</li><li>数据库级别：‘character_set_database’ 和 ‘collaction_set_database’，当然前提你得先输入USE进入相应数据库</li><li>表级别：SHOW CREATE TABLE ‘表名’</li><li>列级别：show full columns from ‘表名’</li></ul></li><li>需要注意的一点：在上方数据库及以下级别中我们可以中途修改它们的字符集和比较规则，但要注意一点：对于字段中的值，转换后的字符集一定要能表示，不然就会出错</li></ul><p>上面我们展示了各级别查看和修改字符集的方法，在修改时都是一起修改的，那如果只修改其中一个会怎样呢？</p><ul><li>只修改字符集：如果我们只修改了字符集，由于比较规则是和字符集想对应的，所以比较规则也会被改为字符集的默认比较规则。</li><li>只修改比较规则：这个也同理，字符集也要进行修改，修改成支持该比较规则的字符集。</li></ul><h3 id="客户端和服务器通信中的字符集："><a href="#客户端和服务器通信中的字符集：" class="headerlink" title="客户端和服务器通信中的字符集："></a>客户端和服务器通信中的字符集：</h3><blockquote><p>毋庸质疑，字符在编码时和解码时使用不同的字符集是绝对行不通的，如果真这样做了，解码后就会出现我们的熟客–乱码。正常人谁会用不同的字符集去编解码字符呀，但Mysql的客户端和服务器可能会发生这样的情况，具体如下。</p></blockquote><p>首先，我们知道我们在客户端向服务器发送请求时其实发送的是一段字符串，服务器向客户端发送的响应结果也是一段字符串，而字符串其实就是一段对字符进行编码而形成的二进制数据，在mysql中对这段二进制数据的处理涉及多个步骤，它也会被不同的字符集进行编解码。主要涉及到以下三个系统变量：</p><ul><li>character_set_client:服务器解码时使用的字符集。</li><li>character_set_connection:在上一步解码后的数据会被该字符集重新编码。</li><li>character_set_result: 服务器返回的结果编码时使用的字符集。</li></ul><p>我们将整个过程分为三个阶段，看看其中可能发生的问题。</p><p><strong>请求阶段：</strong></p><p>Mysql客户端会使用操作系统使用的字符集（windows为gbk，类Unix为utf8）对请求进行编码，需要注意的是如果我们使用的是可视化工具如navicat来发送，因为其里面可以设置字符集所以可能和系统不一样。</p><p>Mysql服务器端接收到请求的字符串采用的就是和character_set_client一样的字符集，所以其就使用character_set_client去解码，这时就会可能就会出现第一处便解码使用的字符集不同的情况，这样的结果就是服务器不能正确解码，无法明白客户端的请求，无法做出正确的回应。</p><p><strong>处理阶段：</strong></p><p>如果第一步都正常完成了，那么解码后的字符串就会再被character_set_connection编码，然后如果该请求涉及的列的字符集刚好和character_set_connection一样，那么它就会直接进行相应的操作，否则还要进行一次字符集转换的操作，最后拿得结果。</p><p><strong>返回阶段：</strong></p><p>上面处理结果最后拿到的记录也是编码过的二进制数据，我们首先对其解码，解码后再通过character_set_result进行编码，编码后发送到客户端，这里又可能出现便解码使用的字符集不同的情况，而这次导致的后果，就是<strong>乱码</strong>，客户端无法理解服务端返回的二进制数据。</p><p>很头晕，转来转去的，所以我们一般将上面三个系统变量设置为与客户端使用的字符集一致的情况，也减少了许多无谓的字符集转换。Mysql为我们设置一个方便的指令：<code>SET NAMES 字符集名</code>,这样就能一次性设置三个系统变量。另外如果想在服务器启动的时候这三个系统变量就一样，可以指定一个<code>default-character-set</code>的启动选项。</p><h3 id="比较规则的应用："><a href="#比较规则的应用：" class="headerlink" title="比较规则的应用："></a>比较规则的应用：</h3><p>比较规则的应用，说一个我们较常见的例子就是排序，排序时我们就是遵循比较规则得出一定的顺序。而且同一个字符集可以有不同的比较规则（例如区分字母大小写的，和不区分大小写的），所以当我们对某个字符串做比较或者对某个字符串的列做排序操作时没有得到想象中的结果，可以考虑一下是不是比较规则的问题。</p>]]></content>
    
    
    <categories>
      
      <category>打怪升级</category>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>🍔Redis数据结构----字典</title>
    <link href="/2022/09/24/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84----%E5%AD%97%E5%85%B8/"/>
    <url>/2022/09/24/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84----%E5%AD%97%E5%85%B8/</url>
    
    <content type="html"><![CDATA[<p>Redis高效的原因很大一部分原因就是因为数据库的底层实现为字典，Redis的字典暗藏了什么玄机，让我们一探究竟。</p><span id="more"></span><h1 id="🍔Redis数据结构—-字典"><a href="#🍔Redis数据结构—-字典" class="headerlink" title="🍔Redis数据结构—-字典"></a>🍔Redis数据结构—-字典</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6hwwms7coj20vq0hswhm.jpg"></p><h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><blockquote><p>字典是一种用于存储键值对的数据结构，里面的值被唯一的键一一映射，具有高效的查询能力，和链表同样的是C语言没有自带字典，所以Redis自己实现了字典。</p><p>字典在Redis中很受重用，比如Redis数据库的底层实现正是字典，还有Hash键的底层实现之一也是字典（当键比较多或者值都是较长的字符串时）</p></blockquote><h2 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><strong>dict.h&#x2F;dictht:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">type <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dictht</span>&#123;<br>  dictEntry **table;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sizemask;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> used;<br>&#125;dictht;<br></code></pre></td></tr></table></figure><ul><li>table: 哈希表节点指针数组，里面存放了指向该哈希表中哈希表节点的指针。</li><li>size：哈希表大小，即上方table的大小。</li><li>sizemask：始终是size-1,会在后面用于一起确定哈希表节点的存放位置。</li><li>used：该哈希表中已经拥有的节点。</li></ul><h3 id="哈希表节点："><a href="#哈希表节点：" class="headerlink" title="哈希表节点："></a>哈希表节点：</h3><p><strong>dict.h&#x2F;dictEntry:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">type <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dictEntry</span>&#123;<br><span class="hljs-type">void</span> *key;<br>  <span class="hljs-keyword">union</span>&#123;<br>    <span class="hljs-type">void</span> *val;<br>    uint64_tu64;<br>    int64_ts64;<br>&#125;v;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dictEntry</span> *next;<br>&#125;dictEntry;<br></code></pre></td></tr></table></figure><ul><li>key: 哈希表节点的键。</li><li>v：保存着哈希表节点的值，里面的值可以是一个int64&#x2F;uint64的整数也可以是一个指针。</li><li>next: 用于解决键冲突，用该指针指向了和他键值相同的节点。</li></ul><h3 id="字典："><a href="#字典：" class="headerlink" title="字典："></a>字典：</h3><p><strong>dict.h&#x2F;dict:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">type <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dict</span>&#123;<br>dictType *type;<br>  <span class="hljs-type">void</span> *<span class="hljs-keyword">private</span>;<br>  dictht ht[<span class="hljs-number">2</span>];<br>  <span class="hljs-type">int</span> rehashidx;<br>&#125;dict;<br></code></pre></td></tr></table></figure><ul><li>type和private这两个属性是为了针对不同类型的键值对，为创建多态字典而设置的。<ul><li>type：dictType结构中保存了一簇用于操作特定类型键值对的函数，redis为用途不同的字典设置了不同的特定类型函数。</li><li>private则是要传入这些函数的可选参数。</li></ul></li><li>ht：哈希表数组，一般使用时只会操作ht[0]，只有在rehash时才会用到ht[1]。</li><li>rehashidx：索引计数器变量，当该值设为-1时表示没有在进行rehash，设置为0时表示rehash正式开始，后面会讲它的用法。</li></ul><h2 id="哈希算法："><a href="#哈希算法：" class="headerlink" title="哈希算法："></a>哈希算法：</h2><p>还记得我们上边说的dict中的type属性吗？这里的哈希函数正是来自于那里面，也就是dict-&gt;type-&gt;hashFunction(key);要想确定键值对的存放位置，我们要知道的就是两个值：hash值和索引值。hash值是通过hashFunction计算得的，索引值是通过与dictht的sizemask做与运算得到的，即<code>index = hash &amp; dict-&gt;ht[x].sizemask</code>，x表示可能为0或者1。</p><p>我们在dict的实现中也有说到type属性是针对不同类型键值对而设计的，redis会为了不同用途的键值对而设置不同的特定类型函数，所以这里的hashFunction是会根据情况改变的，例如在字典做为redis数据库底层实现时，Redis就采用了一个叫做MurmurHash2的算法来计算哈希值，它的特点是即使我们输入的键具有一定规律性，它算出来的hash值还是能有一个较好的随机分布性。</p><h2 id="解决键冲突："><a href="#解决键冲突：" class="headerlink" title="解决键冲突："></a>解决键冲突：</h2><p>这部分可以总结为两个关键词，拉链法，头插法。</p><p>记得我们上边介绍哈希表节点实现的实现提到的next指针吗？即当我们计算出来的hash值相同时，发生hash冲突时，redis会使用这个next指针将和其hash值相同的节点给串起来，形成链表。</p><p>而为了提高插入的效率，redis采用了头插法，也就是将新节点添加到链表的表头位置（时间复杂度为O(1）)。</p><h2 id="Rehash："><a href="#Rehash：" class="headerlink" title="Rehash："></a>Rehash：</h2><p>在哈希表使用了很长时间后，随着插入和删除的次数增多，相应的就造成了链表节点数目过多或过少的问题。所以就要进行Rehash，让负载因子（used&#x2F;size）维持在一个正常水平。</p><h3 id="大致流程："><a href="#大致流程：" class="headerlink" title="大致流程："></a>大致流程：</h3><p>在dict实现中我们知道每个dict都维护了两个hash表，也说了正常使用时操作都会在ht[0]上进行，hash[1]则是在进行rehash的时候才会用到，这里我们在补充一点：ht[1]只有在需要进行rehash时才会被分配地址空间，平时是没有的。所以我们rehash的<strong>第一步：为ht[1]分配地址空间</strong>，分配地址空间也是有规则的，我们细细聊下：</p><ul><li>拓展：当我们的键值对太多而导致进行rehash时，我们就相当于对哈希表进行拓展，redis的规则是，拓展后的大小为<strong>大于或等于</strong>  当前拥有的键值对的数量的2倍的  **首个2<sup>n</sup>**。</li><li>缩小：拓展后的大小为<strong>大于或等于</strong>  当前拥有的键值对的数量的  <strong>首个2<sup>n</sup>。</strong></li></ul><p>而至此rehash还没真正开始，还记得rehashidx吗？我们执行<strong>第二步：将rehashidx设为0</strong>，然后我们就正式开始<strong>第三步：rehash</strong>了，rehash其实就是对ht[0]的所有键值对进行hash运算，然后存放到ht[1]中并且在存放成功后删除ht[0]上相应的指针。<strong>这里在补充一点</strong>，如果移除的哈希表节点上next属性不为空，即有相同索引值的哈希表节点时，这些哈希表节点也会个一同rehash。当所有ht[0]上的键值对被转移完毕后，就要进行<strong>第四步：rehashidx设为-1，释放ht[0]的内存地址空间，并将ht[1]改为ht[0]<strong>，接着</strong>第五步：新建一个hash表，为下一次rehash做准备。</strong></p><h3 id="何时拓展和收缩："><a href="#何时拓展和收缩：" class="headerlink" title="何时拓展和收缩："></a>何时拓展和收缩：</h3><p>首先了解下三个概念：<strong>BGSave</strong>、<strong>负载因子</strong>和<strong>BGrewriteAOF</strong></p><ul><li>BGSave: 用于在后台异步保存当前数据库的数据到磁盘</li><li>BGrewriteAOF: 命令用于异步执行一个 AOF（AppendOnly File） 文件重写操作。重写会创建一个当前 AOF 文件的体积优化版本。即使 Bgrewriteaof 执行失败，也不会有任何数据丢失，因为旧的 AOF 文件在 Bgrewriteaof 成功之前不会被修改。</li><li>负载因子</li></ul><p>自动开始拓展的两种情况：</p><ul><li>当服务器没有在进行BGSave或者BGrewriteAOF，且哈希表的负载因子大于等于1时。</li><li>当服务器有在进行BGSave或者BGrewriteAOF，而哈希表的负载因子大于等于5时。</li></ul><p><strong>为什么？</strong></p><p>因为要进行BGSave或者BGrewriteAOF，服务器则需要创建子进程，而大多数操作系统都采用写时复制技术来优化子进程的使用效率，所以提高所需的负载因子要求，就能避免不必要的内存写入操作，最大限度地节约内存。</p><p>自动开始收缩的情况：当负载因子小于0.1时。</p><h2 id="渐进式Rehash"><a href="#渐进式Rehash" class="headerlink" title="渐进式Rehash:"></a>渐进式Rehash:</h2><h3 id="大致流程：-1"><a href="#大致流程：-1" class="headerlink" title="大致流程："></a>大致流程：</h3><p>对于键值对少的哈希表还好，如果是对于几万，甚至几十万大小数量的哈希表，想要一次性完成rehash那这短时间内庞大的计算量必然导致服务器停止服务。为了减少rehash对服务器性能的影响，redis采用了分多次，渐进式的方式来rehash。</p><p>渐进式rehash的步骤和上面讲的<strong>大致流程</strong>差不多，主要差别就是在第三步rehash上，下面我们讲讲渐进式rehash怎么个渐进法，顺接上面的第二步，索引计数器变量rehashidx被设为0，rehash正式开始，在rehash过程中，每次我们进行对字典的添加、删除、查找、或更新操作时，rehashidx就会进行遍历（自增，不会超过used），找到ht[0]上第一个还未被rehash的键值对，对其进行rehash，rehash完成后加1。</p><blockquote><p> 😊刚开始读书时不太理解这个rehashidx的用法，看了下源码后知道了。</p><p>其实它就是对应于ht[0]上的索引（数组下标），它进行一步步的+1，一步步判断当前table[rehashidx]是否已经被rehash，随着遍历的进行我们也能知道比rehashidx小的索引上的键值对一定已经被rehash了。它就像一把刷子，一步步地将整个哈希表全扫了。</p></blockquote><p>贴上相关源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dictRehash</span><span class="hljs-params">(dict *d, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// 最大可以接受的空bucket数量</span><br>    <span class="hljs-type">int</span> empty_visits = n*<span class="hljs-number">10</span>; <span class="hljs-comment">/* Max number of empty buckets to visit. */</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dictIsRehashing</span>(d)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// ht第一个位置放的未rehash「没有转移前」的数据，第二个位置放的rehash后的数据。</span><br>    <span class="hljs-keyword">while</span>(n-- &amp;&amp; d-&gt;ht_used[<span class="hljs-number">0</span>] != <span class="hljs-number">0</span>) &#123;<br>        dictEntry *de, *nextde;<br><br>        <span class="hljs-comment">/* Note that rehashidx can&#x27;t overflow as we are sure there are more</span><br><span class="hljs-comment">         * elements because ht[0].used != 0 */</span><br>         <span class="hljs-comment">// rehashidx的值不能超过最大值，发生溢出</span><br>        <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">DICTHT_SIZE</span>(d-&gt;ht_size_exp[<span class="hljs-number">0</span>]) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)d-&gt;rehashidx);<br>        <span class="hljs-keyword">while</span>(d-&gt;ht_table[<span class="hljs-number">0</span>][d-&gt;rehashidx] == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-comment">// 跳过空bucket</span><br>            d-&gt;rehashidx++;<br>            <span class="hljs-keyword">if</span> (--empty_visits == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 取出数组的rehashidx下标对应的值，</span><br>        de = d-&gt;ht_table[<span class="hljs-number">0</span>][d-&gt;rehashidx];<br>        <span class="hljs-comment">/* Move all the keys in this bucket from the old to the new hash HT */</span><br>        <span class="hljs-keyword">while</span>(de) &#123;<br>            <span class="hljs-type">uint64_t</span> h;<br><br>            nextde = de-&gt;next;<br>            <span class="hljs-comment">/* Get the index in the new hash table */</span><br>            <span class="hljs-comment">// 计算hash值</span><br>            h = <span class="hljs-built_in">dictHashKey</span>(d, de-&gt;key) &amp; <span class="hljs-built_in">DICTHT_SIZE_MASK</span>(d-&gt;ht_size_exp[<span class="hljs-number">1</span>]);<br>            de-&gt;next = d-&gt;ht_table[<span class="hljs-number">1</span>][h];<br>            d-&gt;ht_table[<span class="hljs-number">1</span>][h] = de;<br>            d-&gt;ht_used[<span class="hljs-number">0</span>]--;<br>            d-&gt;ht_used[<span class="hljs-number">1</span>]++;<br>            <span class="hljs-comment">// de指向下一个</span><br>            de = nextde;<br>        &#125;<br>        <span class="hljs-comment">// 把ht【0】置空</span><br>        d-&gt;ht_table[<span class="hljs-number">0</span>][d-&gt;rehashidx] = <span class="hljs-literal">NULL</span>;<br>        d-&gt;rehashidx++;<br>    &#125;<br><br>    <span class="hljs-comment">/* Check if we already rehashed the whole table... */</span><br>    <span class="hljs-keyword">if</span> (d-&gt;ht_used[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;<br>         <span class="hljs-comment">// chek ht,并释放，ht第一个元素为空，则把 ht[0] = ht[1],这个时候ht[1]为空，ht[0]为整体rehash后的值</span><br>        <span class="hljs-built_in">zfree</span>(d-&gt;ht_table[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">/* Copy the new ht onto the old one */</span><br>        d-&gt;ht_table[<span class="hljs-number">0</span>] = d-&gt;ht_table[<span class="hljs-number">1</span>];<br>        d-&gt;ht_used[<span class="hljs-number">0</span>] = d-&gt;ht_used[<span class="hljs-number">1</span>];<br>        d-&gt;ht_size_exp[<span class="hljs-number">0</span>] = d-&gt;ht_size_exp[<span class="hljs-number">1</span>];<br>        _dictReset(d, <span class="hljs-number">1</span>);<br>        d-&gt;rehashidx = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* More to rehash... */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>rehash完后面就都一样了。</p><p>再附上rehash过程图解方便理解：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6hu3kgpfij20k10iu3zn.jpg"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6hu3pji1vj20k10ekab2.jpg"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6hu468ip4j20k10eo75c.jpg"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6hu48itd4j20k10gx75e.jpg"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6hu4am9obj20k10is0tx.jpg"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6hu4eumt9j20k10ed3zf.jpg"></p><p>渐进式rehash的好处就是它采取了分而治之的方式，将rehash键值对所需的计算均摊到对字典的每个添加、删除、查找、和更新操作上，从而避免了集中式rehash带来的庞大计算量。</p><h3 id="渐进式rehash期间的哈希表操作："><a href="#渐进式rehash期间的哈希表操作：" class="headerlink" title="渐进式rehash期间的哈希表操作："></a>渐进式rehash期间的哈希表操作：</h3><p>因为在rehash期间，键值对会分布在ht[0]和ht[1]上，所以在进行如删除、查找、更新等操作时就会先在ht[0]上找相应键值对，找不到则会再去ht[1]上找，而在添加操作上，则键值对会被直接添加到ht[1],这样ht[0]的键值对就会只减不增，随着rehash进行最后成为一张空表。</p>]]></content>
    
    
    <categories>
      
      <category>打怪升级</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>🥇Redis数据结构----SDS，链表</title>
    <link href="/2022/09/10/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84----SDS%EF%BC%8C%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/09/10/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84----SDS%EF%BC%8C%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>redis为什么能这么高效是有原因，这次我们来学习下保存字符串的SDS和链表在Redis中是如何实现的以及他们的特性。</p><span id="more"></span><h1 id="🥇Redis数据结构—-SDS，链表"><a href="#🥇Redis数据结构—-SDS，链表" class="headerlink" title="🥇Redis数据结构—-SDS，链表"></a>🥇Redis数据结构—-SDS，链表</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h63xebehwej20vq0hs753.jpg"></p><h2 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h2><blockquote><p>众所周知，C语音中的字符串底层实现为一个char类型数组，也就是一个字符数组，所以C字符串在Redis中仅在只需要一个字符串字面量的情况下使用，也就是用于一些不用修改的情景下，比如打印日志。</p><p>出于安全、效率与功能性等的要求Redis自己实现了一个存储字符串的结构–SDS</p><p>并且SDS在Redis中还被用于做缓冲区：AOF模块的AOF缓冲区，以及客户端状态中的输入缓存区</p></blockquote><h3 id="结构："><a href="#结构：" class="headerlink" title="结构："></a>结构：</h3><p>SDS的结构如下：(sds.h&#x2F;sdshdr)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sdshdr</span>&#123;<br>  <span class="hljs-type">int</span> len;<br>  <span class="hljs-type">int</span> free;<br>  <span class="hljs-type">char</span> buf[];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>**len:**当前SDS保存的字符串长度</li><li><strong>free：</strong>当前SDS中未分配的字节长度</li><li><strong>buf：</strong> <strong>字节</strong>数组，用于保存字符串</li></ul><p>同时要注意到一点，虽然Redis自己实现了SDS，但保存的字符串中依然延续了以空字符（&#x2F;0）结尾的传统，SDS在分配空间时会预留一字节长度保存空字符，同时在字符串的末尾加上空字符，这些都由SDS自动完成。这样得到的一个最大好处就是可以复用C语言中对字符串的函数。</p><h3 id="与C字符串的区别："><a href="#与C字符串的区别：" class="headerlink" title="与C字符串的区别："></a>与C字符串的区别：</h3><h4 id="常数复杂度获取字符串长度："><a href="#常数复杂度获取字符串长度：" class="headerlink" title="常数复杂度获取字符串长度："></a>常数复杂度获取字符串长度：</h4><p>对于C字符串，获取字符串长度则是一个时间复杂度为O(n)的操作，因为它是通过一个个遍历得来的</p><p>在SDS的结构中我们可以看到<strong>len</strong>这一属性，它保存了当前SDS保存的字符串的长度，所以我们要获取字符串长度时则只需访问这一属性就可以了。</p><h4 id="杜绝缓冲区溢出："><a href="#杜绝缓冲区溢出：" class="headerlink" title="杜绝缓冲区溢出："></a>杜绝缓冲区溢出：</h4><p>我们通过一个例子来介绍缓冲区溢出：</p><p>例如我们有两个紧邻的字符串，也就是说他们在内存空间上的紧邻着的，我们调用了函数<code>char *strcat(char *dest,const char *src)</code>(该函数会把src的内容拼接到dest上)，而这个函数是假定用户在执行这个函数时已经为dest分配了足够多的内存了，可以容纳src字符串中的所有内容，而一旦这个假设不成立，则会发生缓冲区溢出。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h61bskon31j215n04dglz.jpg" alt="相邻的两个c字符串"></p><p>例如这个上面这个例子，则是‘MongoDB’的内容会被修改。</p><p>而在SDS中，当SDS API需要进行对SDS的修改时，会先判断当前的SDS的空间是否满足此次修改，不满足的话，像上面的例子，SDS则会先扩容到合适的空间后再进行修改，<strong>所以使用SDS既不用自行申请空间，也不会出现缓冲区溢出的情况。</strong></p><p>还是上面这个例子，在SDS中我们调用的是<code>sdscat</code>，其在进行拼接操作前会先查看空间是否满足，发现不满足则先申请空间，</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h61c5gg3fkj216l0dmaaw.jpg" alt="image-20220910111231296"></p><p>申请后，再进行拼接操作。拼接后如下：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h61car6r7nj219i0dg3zy.jpg" alt="image-20220910111736890"></p><p>同时我们注意到一点，在分配足够的空间来完成拼接的同时，SDS还同样申请了同样大小空间的未分配空间，这不是偶然，而是SDS的预分配策略，详情如下。</p><h4 id="减少修改字符串时的内存重分配次数："><a href="#减少修改字符串时的内存重分配次数：" class="headerlink" title="减少修改字符串时的内存重分配次数："></a>减少修改字符串时的内存重分配次数：</h4><p>首先我们先说下C字符串的痛点，由于并没有<strong>len</strong>这一属性，所以底层数组的长度永远是字符串长度+1，正是存在这种字符串长度与底层数组长度的关联，所以在每次进行增长或缩短操作前总需要进行一次内存重分配，比如增长操作中的拼接操作，那么在执行操作前则必须进行一次内存重分配来扩展底层数组的空间，如果忘记这步操作则会造成缓冲区溢出，而比如缩短操作中的截断操作，在执行完此操作后必须进行一次内存重分配来回收这部分不再使用的内存，否则将会造成内存泄漏。<strong>而内存重分配涉及复杂的算法，并且需要执行系统调用，所以它通常是一个比较耗时的操作</strong></p><p>而对于Redis这样一个追求效率，频繁修改的场合，显然每次修改都要进行一次内存重分配是不能接受的。综上原因，Redis使用<strong>free</strong>属性，也就是未分配空间来断开字符串长度与底层数组长度的关联。数组里不再仅有字符串，还有未使用的空间。</p><p>通过未分配空间，SDS实现了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>来减少内存重分配的次数。</p><p><strong>空间预分配：</strong></p><p>上面拼接的例子我们已经看到了，当SDS API进行字符串增长操作，需要进行空间拓展的时候，SDS不仅分配了足够的空间来完成操作，还多分配了相同空间的未分配空间。这就是SDS的空间预分配策略，而分配空间的大小还与分配后SDS的长度有关（也就是len的值）,分两种情况：</p><ul><li>如果分配的SDS的长度&lt;1MB，则是和上面的情况一样，分配相同长度的未分配空间</li><li>如果分配的SDS的长度&gt;1MB，则是再分配1MB。</li></ul><p><strong>通过空间预分配策略，连续增长字符串N次时，内存重分配的次数从N次变为最多N次</strong></p><p><strong>惰性空间释放：</strong></p><p>与C字符串不同的是，SDS再进行缩短操作后并不会立即调用内存重分配来回收收缩后多出来的字节，而是用free属性将这些字节的数量记录下来，并等待将来使用。</p><h4 id="二进制安全："><a href="#二进制安全：" class="headerlink" title="二进制安全："></a>二进制安全：</h4><p>同样先说一下C字符串的痛点，我们知道C字符串是根据空字符来结尾的，所以在字符串里面不能包含空字符，否则最先被程序读入的空字符会被做为字符串的结尾，这些限制使得C字符串只能保存文本数据，而不能保存像图片，视频，压缩文件等的二进制数据</p><p>而SDS API则是二进制安全的，它会以处理二进制的方式来处理字符串，不会对输入的数据进行任何限制、过滤或假设，也就是<strong>数据在写入时什么样的，读出来就是怎么样的</strong>，这也是我们将SDS的buf属性称为<strong>字节数组</strong>的原因–<strong>Redis不是用这个数组来保存字符，而是用它来保存一系列二进制数据</strong>，最后虽然还是会在结尾加上空字符，但并不以其判断结尾，而是用<strong>len</strong>。</p><h4 id="兼容部分C字符串函数："><a href="#兼容部分C字符串函数：" class="headerlink" title="兼容部分C字符串函数："></a>兼容部分C字符串函数：</h4><p>上面我们有说到SDS延续了以空字符结尾的习惯，所以它可以直接复用一些C字符串的函数。</p><h2 id="链表："><a href="#链表：" class="headerlink" title="链表："></a>链表：</h2><blockquote><p>链表有着高效的节点重排能力，顺序性的节点访问方式，并且可以通过增删节点来灵活调整链表的长度。现在的高级编程语言能内置了链表这一数据结构，而C语言没有，所以Redis自己实现了链表。</p><p>在Redis中链表的使用场景：列表键的底层实现之一就是链表，即当列表的节点数量较多，或者列表存储的值都是较长的字符串时。除了列表键，链表还被用于发布与订阅，慢查询，监视器等功能，服务器端则还用来保存多个客户端的状态信息，客户端则还用来做输出缓冲区。</p></blockquote><h3 id="结构：-1"><a href="#结构：-1" class="headerlink" title="结构："></a>结构：</h3><p>节点结构（adlist.h&#x2F;listNode）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span>&#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span>* <span class="hljs-title">prev</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span>* <span class="hljs-title">next</span>;</span><br><span class="hljs-type">void</span>* value;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然通过两两的节点相连就能构成链表了，但Redis为了功能性，再包装了一层，直接定义了一个链表的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span>&#123;</span><br>listNode* head;<br>listNode* tail;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len;<br><span class="hljs-type">void</span>* (*dup)(<span class="hljs-type">void</span>* ptr);<br><span class="hljs-type">void</span> (*<span class="hljs-built_in">free</span>)(<span class="hljs-type">void</span> *ptr);<br><span class="hljs-type">int</span> (*match)(<span class="hljs-type">void</span>* ptr,<span class="hljs-type">void</span>* key);<br>&#125;<span class="hljs-built_in">list</span>;<br></code></pre></td></tr></table></figure><p>这里面包括了头节点，尾节点，节点个数，复制函数，释放函数，比较函数。</p><ul><li>dup 用于复制链表节点的值</li><li>free 用于释放链表节点的值</li><li>match 用于对比链表节点所保存的值和另一个输入值是否相等</li></ul><h3 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h3><p>Redis的链表特性可以总结如下：</p><ul><li>“无环”：head结点的父节点指针和tail节点的子指针都指向NULL。对链表的访问以NULL结尾。</li><li>“双端”：双向链表，访问某节点的父子节点的时间复杂度都是O(1)。</li><li>“头尾指针”：访问链表的头节点和尾节点的复杂度都是O(1)。</li><li>“len”: 因为增加了len属性，获取链表节点个数复杂度为O(1)。</li><li>“多态”：value的属性时void*，可以通过list结构的dup、free、match三个属性为节点设置特定类型函数，所以链表可以用于保存各种不同类型的值。</li></ul>]]></content>
    
    
    <categories>
      
      <category>打怪升级</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>🥤Context学习笔记</title>
    <link href="/2022/09/10/Context%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/10/Context%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>在我们学习 Go 的时候，肯定发现常常时不时就会看到在一些函数的的第一个参数就是 ctx context.Context，而这个context 在这边使用的目的及含义到底是什么呢，本篇我们一起来了解什么是 context，以及使用的场景及方式。</p><span id="more"></span><h1 id="🥤Context学习笔记"><a href="#🥤Context学习笔记" class="headerlink" title="🥤Context学习笔记"></a>🥤Context学习笔记</h1><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h72n6kt9hej30vq0hs0y2.jpg"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Context即上下文，我们可以将其想象做一个承载了截止日期、取消信号和其它请求范围值的包裹，在应用程序的各个层之间、连续调用的函数间穿梭。它主要被使用来实现以下功能：</p><ul><li>终止操作的取消信号</li><li>操作调用的每次函数调用所需的杂项数据</li></ul><p>我们根据这两个功能来好好认识下context。</p><h2 id="Cancel"><a href="#Cancel" class="headerlink" title="Cancel"></a>Cancel</h2><h3 id="为什么取消："><a href="#为什么取消：" class="headerlink" title="为什么取消："></a>为什么取消：</h3><p>简而言之，及时取消，为了防止我们的系统做不必要的工作。以一个完整的Web请求为例：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6ixprpipnj215008kjru.jpg"></p><p>如果一切正常，那么流程图如下所示：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6ixsldunkj213y05y0td.jpg"></p><p>但是，如果客户在中间取消请求，会发生什么？例如，如果客户端在请求中关闭浏览器，就会发生这种情况。</p><p>在不取消的情况下，即使这两项工作的结果无法得到利用，应用程序服务器和数据库还是会继续完成工作：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6ixvj2rtmj213w05umxy.jpg"></p><p>而我们理想中的状态如下，也就是在上层取消后，我们的下层的工作也跟着一起结束：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6ixyj94o6j21480800u8.jpg"></p><blockquote><p>context是Go并发控制的一大利器，我们这里先插播下Go的其他并发控制方式。</p></blockquote><h3 id="Go其他并发控制："><a href="#Go其他并发控制：" class="headerlink" title="Go其他并发控制："></a>Go其他并发控制：</h3><h4 id="WaitGroup："><a href="#WaitGroup：" class="headerlink" title="WaitGroup："></a>WaitGroup：</h4><p><strong>waitGroup常用于要并发执行多项相同的工作，并等到它们全部完成才可结束</strong>，一个简单的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>wg.Add(<span class="hljs-number">3</span>)<br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;i++&#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(num <span class="hljs-type">int</span>)</span></span>&#123;<br>fmt.Printf(<span class="hljs-string">&quot;PEngxjstudy done %d ! \n&quot;</span>,num)<br>wg.Done()<br>&#125;(i)<br>&#125;<br>wg.Wait()<br>fmt.Println(<span class="hljs-string">&quot;All Done !&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="channel-select"><a href="#channel-select" class="headerlink" title="channel+select:"></a>channel+select:</h4><p>和context的功能有点想象，channel和select的搭配使用常在主动取消的场景中被使用。一个简单的例子如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">channelSel</span><span class="hljs-params">()</span></span>&#123;<br>clo:=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;i++&#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(num <span class="hljs-type">int</span>)</span></span>&#123;<br><span class="hljs-keyword">for</span>&#123;<br><span class="hljs-keyword">select</span>&#123;<br><span class="hljs-keyword">case</span> &lt;-clo:<br>fmt.Println(<span class="hljs-string">&quot;PEnxJ&#x27;s study has been done !&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>fmt.Printf(<span class="hljs-string">&quot;PEnxxJ is studyind %d part \n&quot;</span>,num)<br>time.Sleep(<span class="hljs-number">1</span>*time.Second)<br>&#125;<br><br>&#125;<br>&#125;(i)<br>&#125;<br>time.Sleep(<span class="hljs-number">2</span>*time.Second)<br><span class="hljs-built_in">close</span>(clo)<br>time.Sleep(<span class="hljs-number">2</span>*time.Second)<br>fmt.Println(<span class="hljs-string">&quot;study done !&quot;</span>)<br>&#125;<br><br><br>PEnxxJ is studyind <span class="hljs-number">1</span> part <br>PEnxxJ is studyind <span class="hljs-number">2</span> part <br>PEnxxJ is studyind <span class="hljs-number">3</span> part <br>PEnxxJ is studyind <span class="hljs-number">3</span> part <br>PEnxxJ is studyind <span class="hljs-number">1</span> part <br>PEnxxJ is studyind <span class="hljs-number">2</span> part <br>PEnxJ<span class="hljs-string">&#x27;s study has been done !</span><br><span class="hljs-string">PEnxJ&#x27;</span>s study has been done !<br>PEnxJ<span class="hljs-string">&#x27;s study has been done !</span><br><span class="hljs-string">study done !</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><h3 id="Context"><a href="#Context" class="headerlink" title="Context:"></a>Context:</h3><p>上边我们提到了主动取消的<code>channel+select</code>，那我们为什么还要用context呢？其实一般使用已经挺不错了，只是如果遇到某些场景，例如处理一个请求衍生了很多协程，这些协程之间是相互关联的：需要共享一些全局变量、有共同的 deadline 等，而且可以同时被关闭。再用 <code>channel+select</code> 就会比较麻烦，这时就可以通过 context 来实现。</p><p>一句话：context 更适合用来一起解决 goroutine 之间<code>退出通知</code>、<code>元数据传递</code>的功能。而且还有一点如果一个goroutine1开了个goroutine2，goroutine2又开了个3，3又开了个4，而业务逻辑中会有一种情况：我们只想关掉3和4，那用selete+channel就会非常麻烦了。</p><p>搞明白后，我们正式开始看看context怎么用。</p><p>首先我们试着将上面的例子进行改写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Bycontext</span><span class="hljs-params">()</span></span>&#123;<br>ctx:=context.Background()<br>cancleCtx,cancle:=context.WithCancel(ctx)<br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;i++&#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(num <span class="hljs-type">int</span>)</span></span>&#123;<br><span class="hljs-keyword">for</span>&#123;<br><span class="hljs-keyword">select</span>&#123;<br><span class="hljs-keyword">case</span> &lt;-cancleCtx.Done():<br>fmt.Println(<span class="hljs-string">&quot;PEnxJ&#x27;s study has been done !&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>fmt.Printf(<span class="hljs-string">&quot;PEnxxJ is studyind %d part \n&quot;</span>,num)<br>time.Sleep(<span class="hljs-number">1</span>*time.Second)<br>&#125;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context)</span></span>&#123;<br><span class="hljs-keyword">select</span>&#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Println(<span class="hljs-string">&quot;Second groutine has been done !&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>fmt.Printf(<span class="hljs-string">&quot;Second groutine is run %d part \n&quot;</span>,num)<br>time.Sleep(<span class="hljs-number">1</span>*time.Second)<br>&#125;<br>&#125;(cancleCtx)<br><br>&#125;<br>&#125;(i)<br>&#125;<br>time.Sleep(<span class="hljs-number">2</span>*time.Second)<br>cancle()<br>time.Sleep(<span class="hljs-number">2</span>*time.Second)<br>fmt.Println(<span class="hljs-string">&quot;study done !&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面的代码，我们解析几个点：</p><ol><li>context.Background，在context包中和这个函数类似的还有一个叫context.TODO的函数，两者都是申请一个empty context来做父context。</li><li><code>context.WithCancel()</code>,传入一个父context后返回一个子context和一个cancle函数。</li><li>在 goroutine 中，使用 <code>&lt;-ctx.Done()</code> 来判断是否要结束</li><li>调用<code>cancel()</code>即可通知关闭groutine。</li></ol><p>下面我们进行更体系化的阐述，其实context取消主要有三个方面：</p><ol><li>倾听取消活动</li><li>发射取消事件</li><li>context超时</li></ol><h4 id="倾听取消："><a href="#倾听取消：" class="headerlink" title="倾听取消："></a>倾听取消：</h4><p><code>Context</code>提供了一个<code>Done()</code>方法。其实也就是返回一个channel，每次上下文收到取消事件时都会从这个channel收到空<code>struct&#123;&#125;</code>类型。我们以下面的web请求例子为例：一个需要两秒钟来处理事件的HTTP服务器。如果在此之前取消请求，我们希望立即返回：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.ListenAndServe(<span class="hljs-string">&quot;:8000&quot;</span>, http.HandlerFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>ctx := r.Context()<br>fmt.Fprint(os.Stdout, <span class="hljs-string">&quot;processing request\n&quot;</span>)<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-time.After(<span class="hljs-number">2</span> * time.Second):<br>w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;request processed&quot;</span>))<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Fprint(os.Stderr, <span class="hljs-string">&quot;request cancelled\n&quot;</span>)<br>&#125;<br>&#125;))<br>&#125;<br></code></pre></td></tr></table></figure><p>可以通过运行服务器并在浏览器上打开<a href="http://localhost:8000/">localhost:8000</a>来测试这一点。如果您在2秒前关闭浏览器，您应该会在终端窗口上看到“请求已取消”。</p><h4 id="发射取消事件："><a href="#发射取消事件：" class="headerlink" title="发射取消事件："></a>发射取消事件：</h4><p>也就是我们上面的例子，通过<code>context.WithCancel()</code>,传入一个父context后返回一个子context和一个cancle函数,当我们要取消时就调用cancel函数。</p><p>下面是一个简明点的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">operation1</span><span class="hljs-params">(ctx context.Context)</span></span> <span class="hljs-type">error</span> &#123;<br>time.Sleep(<span class="hljs-number">100</span> * time.Millisecond)<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;failed&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">operation2</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-time.After(<span class="hljs-number">500</span> * time.Millisecond):<br>fmt.Println(<span class="hljs-string">&quot;done&quot;</span>)<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Println(<span class="hljs-string">&quot;halted operation2&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ctx := context.Background()<br>ctx, cancel := context.WithCancel(ctx)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>err := operation1(ctx)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>cancel()<br>&#125;<br>&#125;()<br>operation2(ctx)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="context超时："><a href="#context超时：" class="headerlink" title="context超时："></a>context超时：</h4><p>通过调用<code>context.WithTimeout()</code>或者<code>context.WithDeadline()</code>来获得一个子context和一个cancle函数，其实使用方法和上边的发射取消事件差不多，只不过在这里，我们的context里面有一个计时器，当到时间时就会自动cancle。例如下面的例子，一个HTTP API请求我们不想它消耗时间太长，那么就可以做：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ctx := context.Background()<br>ctx, _ = context.WithTimeout(ctx, <span class="hljs-number">100</span>*time.Millisecond)<br><br>req, _ := http.NewRequest(http.MethodGet, <span class="hljs-string">&quot;http://google.com&quot;</span>, <span class="hljs-literal">nil</span>)<br>req = req.WithContext(ctx)<br><br>client := &amp;http.Client&#123;&#125;<br>res, err := client.Do(req)<br><span class="hljs-comment">// If the request failed, log to STDOUT</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Request failed:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// Print the status code if the request succeeds</span><br>fmt.Println(<span class="hljs-string">&quot;Response received, status code:&quot;</span>, res.StatusCode)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Context上下文值："><a href="#Context上下文值：" class="headerlink" title="Context上下文值："></a>Context上下文值：</h2><p>对于跨多个函数完成的操场，常用的值的使用，相比于在整个函数调用中一直将它们作为变量传递，使用上下文变量来传递是更惯用的方式。这也是context的最重要功能之一。</p><p>使用方法：调用<code>context.WithValue()</code>传入一个父context，和一个键值对，并且我们要知道的是，一个子context只能绑定一个键值对。</p><p>考虑一个具有多个函数调用的操作，并使用一个公共ID来识别它的身份。</p><p>实现这一点，天真点的方法是为每个函数调用传递ID：</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// create a random integer as the ID</span><br>rand.Seed(time.Now().Unix())<br>id := rand.Int()<br>operation1(id)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">operation1</span><span class="hljs-params">(id <span class="hljs-type">int64</span>)</span></span> &#123;<br><span class="hljs-comment">// do some work</span><br>log.Println(<span class="hljs-string">&quot;operation1 for id:&quot;</span>, id, <span class="hljs-string">&quot; completed&quot;</span>)<br>operation2(id)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">operation2</span><span class="hljs-params">(id <span class="hljs-type">int64</span>)</span></span> &#123;<br><span class="hljs-comment">// do some work</span><br>log.Println(<span class="hljs-string">&quot;operation2 for id:&quot;</span>, id, <span class="hljs-string">&quot; completed&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将其改为使用context实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">const</span> keyID = <span class="hljs-string">&quot;id&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>rand.Seed(time.Now().Unix())<br>ctx := context.WithValue(context.Background(), keyID, rand.Int())<br>operation1(ctx)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">operation1</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br><span class="hljs-comment">// do some work</span><br><br><span class="hljs-comment">// we can get the value from the context by passing in the key</span><br>log.Println(<span class="hljs-string">&quot;operation1 for id:&quot;</span>, ctx.Value(keyID), <span class="hljs-string">&quot; completed&quot;</span>)<br>operation2(ctx)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">operation2</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br><span class="hljs-comment">// do some work</span><br><br><span class="hljs-comment">// this way, the same ID is passed from one function call to the next</span><br>log.Println(<span class="hljs-string">&quot;operation2 for id:&quot;</span>, ctx.Value(keyID), <span class="hljs-string">&quot; completed&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>使用context来实现变量的传递还有以下优点：</p><ul><li><strong>线程安全</strong>：设置上下文键后，您无法修改上下文键的值。为给定密钥设置另一个值的唯一方法是使用<code>context.WithValue</code></li><li>这是<strong>规范的</strong>：context包在整个Go的官方库和应用程序中广泛用于传输操作范围的数据。即便于他人使用我们的函数。</li></ul><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><p><strong>不良做法 - 一切使用上下文</strong></p><p>应该注意的是，虽然您当然可以使用上下文在应用程序的层之间传递信息，但您绝对需要仅将其用于真正需要传播的东西。</p><p>您不应该将上下文用作所有信息的桶。这是一个补充对象，您可以存储<code>request IDs</code>或<code>trace IDs</code>等内容，然后用于日志记录和跟踪目的。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>Go的魔法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Context</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>🏵打造Go的武器--Viper✪</title>
    <link href="/2022/09/01/%E6%89%93%E9%80%A0Go%E7%9A%84%E6%AD%A6%E5%99%A8--Viper/"/>
    <url>/2022/09/01/%E6%89%93%E9%80%A0Go%E7%9A%84%E6%AD%A6%E5%99%A8--Viper/</url>
    
    <content type="html"><![CDATA[<p>Go程序的第一把武器：项目配置管理<strong>Viper</strong></p><span id="more"></span><h1 id="🏵打造Go的武器–Viper✪"><a href="#🏵打造Go的武器–Viper✪" class="headerlink" title="🏵打造Go的武器–Viper✪"></a>🏵打造Go的武器–Viper✪</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5s8nxlpa2j20fj08q0ti.jpg"></p><h2 id="什么是-Viper？"><a href="#什么是-Viper？" class="headerlink" title="什么是 Viper？"></a>什么是 Viper？</h2><p>Viper 是适用于 Go 应用程序（包括 Twelve-Factor App）的完整配置解决方案。它被设计为在应用程序中工作，并且可以处理所有类型的配置需求和格式。它支持</p><ul><li>设置默认值</li><li>可以读取 JSON，TOML，YAML，HCL，envfile 和 Java properties 格式的配置文件</li><li>实时监控和重新读取配置文件（可选）</li><li>读取环境变量中的配置信息</li><li>读取远程配置系统（etcd 或 Consul）中的配置信息，并监控配置信息发生改变</li><li>读取命令行参数中的配置信息</li><li>读取 buffer 中的配置信息</li><li>显式设置配置项</li></ul><p>可以将 Viper 视为满足您所有应用程序配置需求的注册表。</p><h2 id="快速使用🏆："><a href="#快速使用🏆：" class="headerlink" title="快速使用🏆："></a>快速使用🏆：</h2><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cn">go get github.com/spf13/viper<br></code></pre></td></tr></table></figure><p>使用：</p><p>先在main.go同级目录下，也就是项目目录下建立configs目录，并在其中创建<code>config.yaml</code>，写入以下内容：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">Database:</span><br><span class="hljs-symbol">  DBType:</span> mysql<br><span class="hljs-symbol">  Username:</span> root<br><span class="hljs-symbol">  Password:</span> <span class="hljs-number">123456</span><br><span class="hljs-symbol">  Host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">3306</span><br></code></pre></td></tr></table></figure><p>main.go:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;github.com/spf13/viper&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>viper.SetConfigName(<span class="hljs-string">&quot;config&quot;</span>)<br>viper.SetConfigType(<span class="hljs-string">&quot;yaml&quot;</span>)<br>viper.AddConfigPath(<span class="hljs-string">&quot;configs&quot;</span>)<br><span class="hljs-keyword">if</span> err := viper.ReadInConfig(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;error in read&quot;</span>)<br>&#125;<br>fmt.Println(viper.Get(<span class="hljs-string">&quot;Database.Host&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>很简单，无非就两部分：写入和读取，接下来按照这两部分我们讲讲更深入的用法</p></blockquote><h2 id="😍写入："><a href="#😍写入：" class="headerlink" title="😍写入："></a>😍写入：</h2><p>viper 支持在多个地方设置，使用下面的顺序依次读取：</p><ul><li>调用<code>Set</code>显示设置的；</li><li>命令行选项；</li><li>环境变量；</li><li>配置文件；</li><li>默认值。</li></ul><h3 id="viper-Set"><a href="#viper-Set" class="headerlink" title="viper.Set:"></a>viper.Set:</h3><p>Set的优先级是最高的，所以它可能被用来覆盖命令行参数，或者就单纯自己的应用逻辑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">viper.Set(<span class="hljs-string">&quot;redis.port&quot;</span>, <span class="hljs-number">5381</span>)<br></code></pre></td></tr></table></figure><h3 id="命令行参数："><a href="#命令行参数：" class="headerlink" title="命令行参数："></a>命令行参数：</h3><p>viper的命令行参数是搭配PFlag包一起用的，下面是例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> globalSource = pflag.String(<span class="hljs-string">&quot;global.source&quot;</span>, <span class="hljs-string">&quot;default(flag)&quot;</span>, <span class="hljs-string">&quot;identify the source of configuration&quot;</span>)<br><span class="hljs-keyword">var</span> serverAddress = pflag.String(<span class="hljs-string">&quot;server.address&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;server listen address, empty for all&quot;</span>)<br><span class="hljs-keyword">var</span> serverPort = pflag.Int(<span class="hljs-string">&quot;server.port&quot;</span>, <span class="hljs-number">8080</span>, <span class="hljs-string">&quot;server listen port&quot;</span><br><span class="hljs-comment">//Go中命令行参数绑定的写法，参数1为参数名称，参数2为默认值，参数3为输入提示</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">/* ... */</span><br>    pflag.Parse()  <span class="hljs-comment">//参数解析</span><br>    viper.BindPFlags(pflag.CommandLine) <span class="hljs-comment">//绑定到viper</span><br>    <span class="hljs-comment">/* ... */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>viper.BindPFlags()</code>自动绑定了所有命令行参数，如果只需要其中一部分，可以用viper.BingPflag()选择性绑定，如<code>viper.BindPFlag(&quot;global.source&quot;, pflag.Lookup(&quot;global.source&quot;))</code></p><h3 id="环境变量："><a href="#环境变量：" class="headerlink" title="环境变量："></a>环境变量：</h3><ul><li>AutomaticEnv()</li><li>BindEnv(string…) : error</li><li>SetEnvPrefix(string)</li><li>SetEnvKeyReplacer(*strings.Replacer)</li></ul><p>注意，环境变量是区分大小写的</p><p>首先说<code>AutomaticEnv()</code>和<code>BindEnv(string...)</code>，<code>AutomaticEnv()</code>较为简单，它的作用就是绑定所有的环境变量，eg：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 绑定环境变量</span><br>viper.AutomaticEnv()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 省略部分代码</span><br><br>fmt.Println(<span class="hljs-string">&quot;GOPATH: &quot;</span>, viper.Get(<span class="hljs-string">&quot;GOPATH&quot;</span>))<br>&#125;<br><span class="hljs-comment">//正常输出</span><br></code></pre></td></tr></table></figure><p>而<code>BindEnv</code>则是用于绑定特定的环境变量，它有两种输入参数的方式，当只输入一个参数时，则Key和要绑定的环境变量同名，如果输入的是两个参数，则第一个是Key，第二个是环境变量名，eg：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 绑定环境变量</span><br>viper.BindEnv(<span class="hljs-string">&quot;redis.port&quot;</span>)<br>viper.BindEnv(<span class="hljs-string">&quot;go.path&quot;</span>, <span class="hljs-string">&quot;GOPATH&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 省略部分代码</span><br>fmt.Println(<span class="hljs-string">&quot;go path: &quot;</span>, viper.Get(<span class="hljs-string">&quot;go.path&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>接着是<code>SetEnvPrefix</code>，用于设置前缀，他将会和<code>AutomaticEnv()</code>和<code>BindEnv</code>配套使用，当设置了前缀后，再调用这两个方法，后面使用<code>Get</code>的时候则会自动带上前缀，eg：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">SetEnvPrefix(<span class="hljs-string">&quot;spf&quot;</span>) <span class="hljs-comment">// 会自动转为大写</span><br>BindEnv(<span class="hljs-string">&quot;id&quot;</span>)<br><br>os.Setenv(<span class="hljs-string">&quot;SPF_ID&quot;</span>, <span class="hljs-string">&quot;13&quot;</span>)<br><br>id := Get(<span class="hljs-string">&quot;id&quot;</span>) <span class="hljs-comment">// 13</span><br></code></pre></td></tr></table></figure><p>最后是<code>SetEnvKeyReplacer</code>，这个算是一个辅助方法，用于对在调用<code>Get</code>的时候传入的key的符号进行替换，比如我们常用的是<code>Globar.Source</code>而环境变量里我们使用的是<code>Globar_Source</code>，这时就能用到了，eg：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">viper.AutomaticEnv()<br><br>viper.SetEnvPrefix(<span class="hljs-string">&quot;MYAPP&quot;</span>)<br><br>viper.SetEnvKeyReplacer(strings.NewReplacer(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;_&quot;</span>)<br>                        <br>fmt.Println(viper.Get(<span class="hljs-string">&quot;Globar.Source&quot;</span>))<br><span class="hljs-comment">//输出了 MYAPP_GLOBAL_SOURCE</span><br></code></pre></td></tr></table></figure><h3 id="配置文件（最常用）："><a href="#配置文件（最常用）：" class="headerlink" title="配置文件（最常用）："></a>配置文件（最常用）：</h3><p>正如快速使用里面提到的，步骤就是写好配置文件，再者就是<code>viper.SetConfigName(&quot;config&quot;)</code>，<code>viper.SetConfigType(&quot;yaml&quot;)</code>，<code>viper.AddConfigPath(&quot;configs&quot;)</code>，再<code>viper.ReadInConfig()</code>就可以读取了。</p><h3 id="默认值："><a href="#默认值：" class="headerlink" title="默认值："></a>默认值：</h3><p>设置默认值，可以用于备用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">viper.SetDefault(<span class="hljs-string">&quot;ContentDir&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="从io-Reader中读取"><a href="#从io-Reader中读取" class="headerlink" title="从io.Reader中读取:"></a>从io.Reader中读取:</h3><p>viper 支持从<code>io.Reader</code>中读取配置。这种形式很灵活，来源可以是文件，也可以是程序中生成的字符串，甚至可以从网络连接中读取的字节流</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package main<br><br><span class="hljs-keyword">import</span> (<br>&quot;bytes&quot;<br>&quot;fmt&quot;<br>&quot;log&quot;<br><br>&quot;github.com/spf13/viper&quot;<br>)<br><br>func main() &#123;<br>viper.SetConfigType(&quot;toml&quot;)<br>tomlConfig := []byte(`<br>app_name = &quot;awesome web&quot;<br><br># possible <span class="hljs-keyword">values</span>: <span class="hljs-keyword">DEBUG</span>, <span class="hljs-keyword">INFO</span>, <span class="hljs-built_in">WARNING</span>, ERROR, FATAL<br>log_level = &quot;DEBUG&quot;<br><br>[mysql]<br>ip = &quot;127.0.0.1&quot;<br>port = <span class="hljs-number">3306</span><br><span class="hljs-keyword">user</span> = &quot;root&quot;<br><span class="hljs-keyword">password</span> = <span class="hljs-number">123456</span><br><span class="hljs-keyword">database</span> = &quot;awesome&quot;<br>`)<br>err := viper.ReadConfig(bytes.NewBuffer(tomlConfig))<br><span class="hljs-keyword">if</span> err != nil &#123;<br><span class="hljs-keyword">log</span>.Fatal(&quot;read config failed: %v&quot;, err)<br>&#125;<br><br>fmt.Println(&quot;redis port: &quot;, viper.GetInt(&quot;redis.port&quot;))<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="🤪读取："><a href="#🤪读取：" class="headerlink" title="🤪读取："></a>🤪读取：</h2><h3 id="保存配置："><a href="#保存配置：" class="headerlink" title="保存配置："></a>保存配置：</h3><p>用于在配置发生更好后保存至本地，具体推荐使用以下两个方法：</p><ul><li><code>WriteConfigAs</code>：保存配置到指定路径下的文件，如果文件存在，则覆盖；</li><li><code>SafeWriteConfig</code>：与上面功能一样，但是如果配置文件存在，则不覆盖，会报错。</li></ul><h3 id="基本读取："><a href="#基本读取：" class="headerlink" title="基本读取："></a>基本读取：</h3><p>在 Viper 中，有几种根据值的类型获取值的方法。存在以下功能和方法：</p><ul><li>Get(key string) : interface{}</li><li>GetBool(key string) : bool</li><li>GetFloat64(key string) : float64</li><li>GetInt(key string) : int</li><li>GetIntSlice(key string) : []int</li><li>GetString(key string) : string</li><li>GetStringMap(key string) : map[string]interface{}</li><li>GetStringMapString(key string) : map[string]string</li><li>GetStringSlice(key string) : []string</li><li>GetTime(key string) : time.Time</li><li>GetDuration(key string) : time.Duration</li><li>IsSet(key string) : bool</li><li>AllSettings() : map[string]interface{}</li></ul><p>每个 Get 函数如果找不到值，它将返回零值。为了检查给定键是否存在，提供了 IsSet() 方法。</p><p><strong>访问套接键：</strong></p><p>访问器方法还接受深度嵌套键的格式化路径。例如，如果加载了以下JSON文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go">&#123;<br>    <span class="hljs-string">&quot;host&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;address&quot;</span>: <span class="hljs-string">&quot;localhost&quot;</span>,<br>        <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">5799</span><br>    &#125;,<br>    <span class="hljs-string">&quot;datastore&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;metric&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>,<br>            <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">3099</span><br>        &#125;,<br>        <span class="hljs-string">&quot;warehouse&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;198.0.0.1&quot;</span>,<br>            <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">2112</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Viper 可以通过传递「.」分隔键的路径来访问嵌套字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">GetString(<span class="hljs-string">&quot;datastore.metric.host&quot;</span>) <span class="hljs-comment">// (returns &quot;127.0.0.1&quot;)</span><br></code></pre></td></tr></table></figure><p>遵守上面建立的优先级规则；搜索路径将遍历其余配置注册表，直到找到为止。</p><p>例如，在给定此配置文件的情况下，datastore.metric.host 和 datastore.metric.port 均已定义（并且可以被覆盖）。如果另外在默认设置中定义了 datastore.metric.protocol，Viper 也会找到它。</p><p>但是，如果 datastore.metric 被直接赋值覆盖（通过 flag，环境变量，Set() 方法等），则 datastore.metric 的所有子键也都变为未定义状态，它们被较高的优先级配置遮蔽（shadowed）了。</p><p>Viper 可以使用路径中的数字访问数组索引。例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123;<br>    <span class="hljs-string">&quot;host&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;address&quot;</span>: <span class="hljs-string">&quot;localhost&quot;</span>,<br>        <span class="hljs-string">&quot;ports&quot;</span>: [<br>            <span class="hljs-number">5799</span>,<br>            <span class="hljs-number">6029</span><br>        ]<br>    &#125;<br>&#125;<br><br>GetInt(<span class="hljs-string">&quot;host.ports.1&quot;</span>) <span class="hljs-regexp">//</span> returns <span class="hljs-number">6029</span><br></code></pre></td></tr></table></figure><p>最后，如果存在与分隔的键路径匹配的键，则将返回其值。例如</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&#123;<br>    <span class="hljs-string">&quot;datastore.metric.host&quot;</span>: <span class="hljs-string">&quot;0.0.0.0&quot;</span>,<br>    <span class="hljs-string">&quot;datastore&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;metric&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>,<br>            <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">3099</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">GetString</span><span class="hljs-params">(<span class="hljs-string">&quot;datastore.metric.host&quot;</span>)</span></span> <span class="hljs-comment">// returns &quot;0.0.0.0&quot;</span><br></code></pre></td></tr></table></figure><h3 id="提取子树："><a href="#提取子树：" class="headerlink" title="提取子树："></a>提取子树：</h3><p>我们以下面的例子来讲提取子树。</p><p>应用程序可能出于不同的目的使用多个不同的缓存存储。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">cache:</span><br>  <span class="hljs-attr">cache1:</span><br>    <span class="hljs-attr">max-items:</span> <span class="hljs-number">100</span><br>    <span class="hljs-attr">item-size:</span> <span class="hljs-number">64</span><br>  <span class="hljs-attr">cache2:</span><br>    <span class="hljs-attr">max-items:</span> <span class="hljs-number">200</span><br>    <span class="hljs-attr">item-size:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>这时我们要得到其中一个cache的配置，我们定义了一个函数<code>NewCache()</code>，这时我们可以采用<code>NewCache(&quot;cache1&quot;)</code>直接传入名字的方式，再到函数里面根据名字”cache.cache1.max-items”的形式去创建，显然有点小乱，我们可以采用更优雅的方式。如下：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lisp">func NewCache(<span class="hljs-name">v</span> *Viper) *Cache &#123;<br>    return <span class="hljs-symbol">&amp;Cache</span>&#123;<br>        MaxItems: v.GetInt(<span class="hljs-string">&quot;max-items&quot;</span>),<br>        ItemSize: v.GetInt(<span class="hljs-string">&quot;item-size&quot;</span>),<br>    &#125;<br>&#125;<br><br>cache1Config <span class="hljs-symbol">:=</span> viper.Sub(<span class="hljs-string">&quot;cache.cache1&quot;</span>)<br>if cache1Config == <span class="hljs-literal">nil</span> &#123; // Sub returns <span class="hljs-literal">nil</span> if the key cannot be found<br>    panic(<span class="hljs-string">&quot;cache configuration not found&quot;</span>)<br>&#125;<br><br>cache1 <span class="hljs-symbol">:=</span> NewCache(<span class="hljs-name">cache1Config</span>)<br></code></pre></td></tr></table></figure><h3 id="反序列化："><a href="#反序列化：" class="headerlink" title="反序列化："></a>反序列化：</h3><p>viper 支持将配置<code>Unmarshal</code>到一个结构体中，为结构体中的对应字段赋值。例子如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-string">&quot;github.com/spf13/viper&quot;</span><br>)<br><span class="hljs-keyword">type</span> Database <span class="hljs-keyword">struct</span>&#123;<br>Dbtype <span class="hljs-type">string</span><br>Host <span class="hljs-type">string</span><br>Password <span class="hljs-type">string</span><br>Username <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>viper.SetConfigName(<span class="hljs-string">&quot;config&quot;</span>)<br>viper.SetConfigType(<span class="hljs-string">&quot;yaml&quot;</span>)<br>viper.AddConfigPath(<span class="hljs-string">&quot;configs&quot;</span>)<br><span class="hljs-keyword">if</span> err := viper.ReadInConfig(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;error in read&quot;</span>)<br>&#125;<br><span class="hljs-keyword">var</span> Data Database<br><span class="hljs-keyword">if</span> err:=viper.UnmarshalKey(<span class="hljs-string">&quot;Database&quot;</span>,&amp;Data);err!=<span class="hljs-literal">nil</span>&#123;<br>fmt.Println(err)<br>&#125;<br>fmt.Println(Data)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要解析 Key 本身包含「.」（默认键分隔符）的配置，必须更改分隔符：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go">v := viper.NewWithOptions(viper.KeyDelimiter(<span class="hljs-string">&quot;::&quot;</span>))<br><br>v.SetDefault(<span class="hljs-string">&quot;chart::values&quot;</span>, <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br>    <span class="hljs-string">&quot;ingress&quot;</span>: <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br>        <span class="hljs-string">&quot;annotations&quot;</span>: <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br>            <span class="hljs-string">&quot;traefik.frontend.rule.type&quot;</span>:                 <span class="hljs-string">&quot;PathPrefix&quot;</span>,<br>            <span class="hljs-string">&quot;traefik.ingress.kubernetes.io/ssl-redirect&quot;</span>: <span class="hljs-string">&quot;true&quot;</span>,<br>        &#125;,<br>    &#125;,<br>&#125;)<br><br><span class="hljs-keyword">type</span> config <span class="hljs-keyword">struct</span> &#123;<br>  Chart <span class="hljs-keyword">struct</span>&#123;<br>        Values <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> C config<br><br>v.Unmarshal(&amp;C)<br></code></pre></td></tr></table></figure><h3 id="监听文件修改："><a href="#监听文件修改：" class="headerlink" title="监听文件修改："></a>监听文件修改：</h3><p>viper 可以监听文件修改，热加载配置。因此不需要重启服务器，就能让配置生效。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sqf">package main<br><br>import (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-string">&quot;github.com/spf13/viper&quot;</span><br>)<br><br>func main() &#123;<br>viper.SetConfigName(<span class="hljs-string">&quot;config&quot;</span>)<br>viper.SetConfigType(<span class="hljs-string">&quot;toml&quot;</span>)<br>viper.AddConfigPath(<span class="hljs-string">&quot;.&quot;</span>)<br>err := viper.ReadInConfig()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">log</span>.Fatal(<span class="hljs-string">&quot;read config failed: %v&quot;</span>, err)<br>&#125;<br><br>viper.WatchConfig()<br><br>fmt.Println(<span class="hljs-string">&quot;redis port before sleep: &quot;</span>, viper.<span class="hljs-built_in">Get</span>(<span class="hljs-string">&quot;redis.port&quot;</span>))<br><span class="hljs-built_in">time</span>.<span class="hljs-built_in">Sleep</span>(<span class="hljs-built_in">time</span>.Second * <span class="hljs-number">10</span>)<br>fmt.Println(<span class="hljs-string">&quot;redis port after sleep: &quot;</span>, viper.<span class="hljs-built_in">Get</span>(<span class="hljs-string">&quot;redis.port&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>上面程序中，我们先打印<code>redis.port</code>的值，然后<code>Sleep</code> 10s。在这期间修改配置中<code>redis.port</code>的值，<code>Sleep</code>结束后再次打印。发现打印出修改后的值：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">redis port before sleep:</span>  <span class="hljs-number">7381</span><br><span class="hljs-attr">redis port after sleep:</span>  <span class="hljs-number">73810</span><br></code></pre></td></tr></table></figure><p>另外，还可以为配置修改增加一个回调：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cn">viper.OnConfigChange(func(e fsnotify.Event) &#123;<br>fmt.Printf(&quot;Config file:%s Op:%s\n&quot;, e.Name, e.Op)<br>&#125;)<br></code></pre></td></tr></table></figure><p>这样文件修改时会执行这个回调。</p><p>viper 使用<a href="https://link.zhihu.com/?target=https://github.com/fsnotify/fsnotify">fsnotify</a>这个库来实现监听文件修改的功能。</p><h2 id="Viper实例："><a href="#Viper实例：" class="headerlink" title="Viper实例："></a>Viper实例：</h2><p>Viper 可以开箱即用。无需配置或初始化，就可以使用 Viper。由于大多数应用程序都希望使用单个中央存储库进行配置，因此 viper 包提供了此功能。它类似于单例模式。</p><p>在上面的所有示例中，他们都以单例模式风格演示了使用 Viper 的使用方法</p><p>您还可以创建许多不同的 Viper 实例，供应用程序使用。每个都有其独特的配置和值集。每个都可以从不同的配置文件等读取。Viper 包支持的所有函数都镜像为 Viper 上的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">x := viper.New()<br>y := viper.New()<br><br>x.SetDefault(<span class="hljs-string">&quot;ContentDir&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>)<br>y.SetDefault(<span class="hljs-string">&quot;ContentDir&quot;</span>, <span class="hljs-string">&quot;foobar&quot;</span>)<br><br></code></pre></td></tr></table></figure><p>当使用多个 Viper 时，由用户管理不同的 Viper。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>Viper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Viper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>🤗️怎样写单元测试与如何判断slice中的一个元素</title>
    <link href="/2022/08/13/%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95/"/>
    <url>/2022/08/13/%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>Go中没有可以直接判断一个元素是否在slice中的函数，所以用于判断的方法有遍历，还有改进点的构建Map，用Sort包，那到底是Map好还是Sort包好呢，我们做个单元测试就知道了。</p><span id="more"></span><h1 id="🤗️怎样写单元测试与如何判断slice中的一个元素"><a href="#🤗️怎样写单元测试与如何判断slice中的一个元素" class="headerlink" title="🤗️怎样写单元测试与如何判断slice中的一个元素"></a>🤗️怎样写单元测试与如何判断slice中的一个元素</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5555r4z1xj21900u0n76.jpg"></p><h2 id="单元测试与性能测试"><a href="#单元测试与性能测试" class="headerlink" title="单元测试与性能测试"></a>单元测试与性能测试</h2><blockquote><p>这里我们主要用了Go的testing包。</p></blockquote><p><strong>白盒测试：</strong>测试代码和要测试的代码放在同一包中，测试代码可以读取到该包中的不可导出变量，所以我们在编写需要访问到不可导出变量、函数、常量的测试代码时就要用这种方法，同时这也是较为推荐的方法。</p><p><strong>黑盒测试：</strong>可以不放在同一个包中，但只能测试可导出的标示符。</p><blockquote><p>测试文件的规范要求：测试文件命名规范、函数名规范、变量名规范</p></blockquote><p>测试文件名规范：Go的测试文件名必须以_test.go结尾，因为Go就是利用这个去判断哪些是测试文件，哪些是正式文件的，我们在执行<code>go test</code>命令时，这些文件会给执行，而在构建程序时则会忽略这些文件。</p><p>函数名规范：测试函数必须使用Test&#x2F;Benchmark&#x2F;Example开头，例如TestXxx、BenchmarkXxx、ExampleXxx，Xxx通常是要测试的函数名。</p><p>变量名规范：Go没有对变量名有硬性的要求，但为了清晰的表达函数的实际输出和预期输出，可以将这两类输出命名为expected&#x2F;actual或者got&#x2F;want。</p><h3 id="🤔单元测试："><a href="#🤔单元测试：" class="headerlink" title="🤔单元测试："></a>🤔单元测试：</h3><p>单元测试的测试用例函数以Test开头，函数参数必须是<code>*tesing.T</code>，可以用该类型来记录错误或测试状态。</p><blockquote><p>至此我们可以得出一个总结，要写一个单元测试必要的规范，1.文件名以_test.go结尾，2.函数名以Test开头，3.函数参数为<code>testing.T</code></p></blockquote><p>我们可以调用 <code>testing.T</code> 的 <code>Error</code> 、<code>Errorf</code> 、<code>FailNow</code> 、<code>Fatal</code> 、<code>FatalIf</code> 方法，来说明测试不通过；调用 <code>Log</code> 、<code>Logf</code> 方法来记录测试信息。函数列表和相关描述如下表所示：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>t.Log, t.Logf</td><td>正常信息</td></tr><tr><td>t.Error, t.Errorf</td><td>测试失败信息</td></tr><tr><td>t.Fatal, t.Fatalf</td><td>致命错误，测试程序退出的信息</td></tr><tr><td>t.Fail</td><td>当前测试标记为失败</td></tr><tr><td>t.Failed</td><td>查看失败标记</td></tr><tr><td>t.FailNow</td><td>标记失败，并终止当前测试函数的执行。需要注意的是，我们只能在运行测试函数的Goroutine中调用t.FailNow方法，而不能在我们测试代码创建出的Goroutine中调用它</td></tr></tbody></table><p><strong>一个栗子🌰：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//math.go</span><br><br><span class="hljs-keyword">package</span> Test<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;math&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Abs</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>b := <span class="hljs-type">float64</span>(a)<br><span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(math.Abs(b))<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> Test<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAbs</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>got := Abs(<span class="hljs-number">-1</span>)<br><span class="hljs-keyword">if</span> got != <span class="hljs-number">1</span> &#123;<br>t.Error(<span class="hljs-string">&quot;fault&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>t.Log(<span class="hljs-string">&quot;right&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">终端执行命令</span><br><br>go test &quot;math.go&quot; &quot;math_test.go&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果想执行文件夹中的所有测试用例那就直接go <span class="hljs-built_in">test</span>即可</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">也可以用go <span class="hljs-built_in">test</span>的参数来完成执行指定的函数</span><br></code></pre></td></tr></table></figure><p>go test支持一下三个参数：</p><ul><li><p>-v，显示所有测试函数的运行细节：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">pengxj@PEngxJdeMacBook-Pro test % go test -v &quot;math.go&quot; &quot;math_test.go&quot; <br>=== RUN   TestAbs<br>    math_test.go:10: right<br>--- PASS: TestAbs (0.00s)<br>PASS<br>ok      command-line-arguments  0.612s<br></code></pre></td></tr></table></figure></li><li><p>-run &lt; regexp&gt;，指定要执行的测试函数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">pengxj@PEngxJdeMacBook-Pro test % go test -run &quot;TestAbs&quot;             <br>PASS<br>ok      test    0.608s<br></code></pre></td></tr></table></figure></li><li><p>-count N，指定执行测试函数的次数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">pengxj@PEngxJdeMacBook-Pro test % go test -v -run &quot;TestAbs&quot; -count=2<br>=== RUN   TestAbs<br>    math_test.go:10: right<br>--- PASS: TestAbs (0.00s)<br>=== RUN   TestAbs<br>    math_test.go:10: right<br>--- PASS: TestAbs (0.00s)<br>PASS<br>ok      test    0.087s<br></code></pre></td></tr></table></figure></li></ul><p><strong>多个测试用例：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAbs_2</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>tests:=[]<span class="hljs-keyword">struct</span>&#123;<br>x <span class="hljs-type">int</span><br>want <span class="hljs-type">int</span><br>&#125;&#123;<br>&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">-2</span>,<span class="hljs-number">2</span>&#125;,<br>&#123;<span class="hljs-number">-3</span>,<span class="hljs-number">3</span>&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> _,v:=<span class="hljs-keyword">range</span> tests&#123;<br>got:=Abs(v.x)<br><span class="hljs-keyword">if</span> got!=v.want&#123;<br>t.Error(<span class="hljs-string">&quot;fault&quot;</span>)<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>t.Log(<span class="hljs-string">&quot;right&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中，我们定义了一个结构体，并且给定了入参和希望得到的值，最后用循环测试每个用例</p><h3 id="自动生成单元测试🐮："><a href="#自动生成单元测试🐮：" class="headerlink" title="自动生成单元测试🐮："></a>自动生成单元测试🐮：</h3><p>通过上面的样例我们可以得出个大概的结论：我们编写的单元测试就是，自己设定参数和预期结果值，接着调用函数来看能不能达到预期，逻辑并不复杂，复杂的反而是上面提到的那几个规范。</p><p>所以大牛已经做出工具来了，优秀的生成测试代码的工具：<code>gotests</code>。下面我们讲下他的使用方法：</p><p><strong>第一步：下载gotests包：</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> -<span class="hljs-keyword">u</span> github.<span class="hljs-keyword">com</span>/cweill/gotests/...<br></code></pre></td></tr></table></figure><p><strong>第二步：执行gotests命令：</strong></p><p>gotests命令执行格式为：<code>gotests [options] [PATH] [FILE] ...</code>。gotests可以为<code>PATH</code>下的所有Go源码文件中的函数生成测试代码，也可以只为某个<code>FILE</code>中的函数生成测试代码。</p><p>常用参数：<code>-all:</code>为当前目录下的所有函数生成测试代码。<code>-w：</code>将生成的测试代码生成到指定文件中，而不是命令行窗口。<code>-only:</code>指定要单独生成单元测试的函数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">gotests -only &quot;Abs&quot; -w .<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># -only用于指定选定的要生成单元测试的函数</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># “.” 表示生成在该目录下</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 如果我们没有创建相应的 _test.go文件那他就会自动生成，如果有就会往里继续添加，当然前提是我们没在那个文件中已经写了Test文件，不然就不会生成了。</span></span><br></code></pre></td></tr></table></figure><p><strong>第三步，添加测试用例：</strong></p><p>生成完测试用例，你只需要添加需要测试的输入和预期的输出就可以了。</p><p>上面的命令执行后会出现下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> Test<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAbs</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">type</span> args <span class="hljs-keyword">struct</span> &#123;<br>a <span class="hljs-type">int</span><br>&#125;<br>tests := []<span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>args args<br>want <span class="hljs-type">int</span><br>&#125;&#123;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Add test cases.</span><br>&#125;<br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;<br>t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">if</span> got := Abs(tt.args.a); got != tt.want &#123;<br>t.Errorf(<span class="hljs-string">&quot;Abs() = %v, want %v&quot;</span>, got, tt.want)<br>&#125;<br>&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们要完成的就是上面的TODO部分，也就是添加参数和预期结果。<code>name</code> 表示这组样例的备注，<code>args</code>表示函数的入参， <code>want</code>表示想要得到的结果。例如下面这样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAbs</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">type</span> args <span class="hljs-keyword">struct</span> &#123;<br>a <span class="hljs-type">int</span><br>&#125;<br>tests := []<span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>args args<br>want <span class="hljs-type">int</span><br>&#125;&#123;<br>&#123;<br>name: <span class="hljs-string">&quot;test one&quot;</span>,<br>args: args&#123;<br>a: <span class="hljs-number">1</span>,<br>&#125;,<br>want: <span class="hljs-number">1</span>,<br>&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;<br>t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">if</span> got := Abs(tt.args.a); got != tt.want &#123;<br>t.Errorf(<span class="hljs-string">&quot;Abs() = %v, want %v&quot;</span>, got, tt.want)<br>&#125;<br>&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="性能测试："><a href="#性能测试：" class="headerlink" title="性能测试："></a>性能测试：</h2><p>性能测试的函数Benchmark开头，函数参数必须是<code>*tesing.B</code>,函数内我们使用<code>b.N</code>来作为循环次数，N会在运行时动态调整，下面将是我们用Map和Sort包来判断元素的方法，和我们为其编写的性能测试函数。总结一句话，性能测试和上面的单元测试差不多，都是在_test.go文件中，只是函数名以Benchmark开头和用了<code>*testing.B</code>参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 两种判断Slice中元素是否存在的方法：</span><br><br><span class="hljs-keyword">package</span> Test<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;sort&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makemap</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-keyword">struct</span>&#123;&#125; &#123;<br>tempMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> arr &#123;<br>tempMap[v] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br><span class="hljs-keyword">return</span> tempMap<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Findbymap</span><span class="hljs-params">(tempMap <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-keyword">struct</span>&#123;&#125;, n <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> _, ok := tempMap[n]; ok &#123;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Findbysort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> &#123;<br>sort.Ints(arr)<br><span class="hljs-keyword">if</span> pos := sort.SearchInts(arr, n); pos != <span class="hljs-built_in">len</span>(arr) &#123;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//性能测试代码</span><br><br><span class="hljs-keyword">package</span> Test<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> arr = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>, <span class="hljs-number">66</span>, <span class="hljs-number">77</span>, <span class="hljs-number">88</span>, <span class="hljs-number">23</span>, <span class="hljs-number">34</span>, <span class="hljs-number">45</span>, <span class="hljs-number">56</span>, <span class="hljs-number">67</span>, <span class="hljs-number">78</span>, <span class="hljs-number">89</span>&#125;<br><span class="hljs-keyword">var</span> n = <span class="hljs-number">3</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkBymap</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>tempMap := makemap(arr)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>Findbymap(tempMap, n)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkBysort</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>Findbysort(arr, n)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">文件指定支持正则表达式</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">指定目录下的所有Benchmark函数如下：</span><br>go test -bench=&quot;.*&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">当然也可以指定特定函数</span><br>go test -bench=&quot;BenchmarkBymap&quot;<br><br></code></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">pengxj@PEngxJdeMacBook-Pro test % go test -bench=&quot;.*&quot;<br>goos: darwin<br>goarch: arm64<br>pkg: test<br>BenchmarkBymap-8        243986680                4.892 ns/op<br>BenchmarkBysort-8       11873071                99.28 ns/op<br>PASS<br>ok      test    3.068s<br></code></pre></td></tr></table></figure><p>结果得知，在要多次查询的情况下，构建一个map的效率是非常高的。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>代码测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单元测试与性能测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>⛽常见排序算法与实现📣</title>
    <link href="/2022/08/09/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/08/09/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>学习完数据结构与算法的课已经有很长时间了，排序算法忘的七七八八，好好复习一下吧</p><p>面对这道高频面试题，一定得好好理解下。包括了导航流程和TCP连接</p><span id="more"></span><h1 id="⛽常见排序算法与实现📣"><a href="#⛽常见排序算法与实现📣" class="headerlink" title="⛽常见排序算法与实现📣"></a>⛽常见排序算法与实现📣</h1><h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><p>排序算法可以分为两大类：<strong>比较类排序</strong>和<strong>非比较类排序</strong></p><p><strong>比较类排序：</strong>通过比较来决定元素间的相对次序，由于其时间复杂度无法突破O(nlog<del>2</del>n)，因此也称为非线性时间比较类排序。</p><p><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 </p><p>当前工业界和面试时考察的比较多的都是比较类排序，所以这次我们重点来学习下比较类排序中常见的两类排序：<strong>初级排序</strong>和<strong>高级排序</strong></p><p><img src="https://pic.rmb.bdstatic.com/bjh/839422a30a824720938d3e4a35f2f5d1.png" alt="常见排序的时间复杂度"></p><p><strong>初级排序：</strong>平均时间复杂度为O(n^2^)的排序，这些的重要性相对不高，多以了解为主。</p><p><strong>高级排序</strong>：平均时间复杂度为O(nlog<del>2</del>n)的排序，在公司面试和使用这方面主要就是这几个，优先级是最高的，我们一定要理解他们的原理并且自己能够实现这类排序算法。</p><h2 id="初级排序："><a href="#初级排序：" class="headerlink" title="初级排序："></a>初级排序：</h2><blockquote><p>我们主要熟悉下选择排序、插入排序、冒泡排序</p></blockquote><h3 id="选择排序："><a href="#选择排序：" class="headerlink" title="选择排序："></a>选择排序：</h3><blockquote><p>平均时间复杂度：O(n^2^)</p><p>最优时间复杂度：O(n^2^)  因为每次都要完整地遍历一次无序数组</p><p>最差时间复杂度：O(n^2^) 一样的，每次都是要完整地遍历一次无序数组</p><p>空间复杂度：O(1)  不用开辟新数组</p></blockquote><p>一句话理解：在乱序数组中遍历，找到最小元素，放到有序数组的最后面，如此反复最后就能得到有序数组。步骤就是每次都遍历一遍无序数组，找到最小元素，然后与无序数组的第一个元素交换（原理上是放到有序数组的下一个元素，其实也就是无序数组的第一个元素）</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h543464jifg20mj06w7l2.gif" alt="选择排序"></p><p><strong>代码实现（Go）：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arr)<span class="hljs-number">-1</span>; i++ &#123; <span class="hljs-comment">//每次遍历无序数组的第一个元素的位置</span><br>min := arr[i]<br>pos := i<br>        <span class="hljs-comment">//找到最小元素</span><br><span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(arr); j++ &#123;<br><span class="hljs-keyword">if</span> arr[j] &lt; min &#123;<br>min = arr[j]<br>pos = j<br>&#125;<br>&#125;<br>        <span class="hljs-comment">//与无序数组的第一个元素交换</span><br> arr[i],arr[pos]=arr[pos],arr[i]<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插入排序："><a href="#插入排序：" class="headerlink" title="插入排序："></a>插入排序：</h3><blockquote><p>平均时间复杂度：O(n^2^)</p><p>最优时间复杂度：O(n)  数组为本身有序的情况</p><p>最差时间复杂度：O(n^2^) 逆序的情况，每次都要一次与前面有序数组完整的比较</p><p>空间复杂度：O(1)  不用开辟新数组</p></blockquote><p>一句话理解：将乱序数组中的元素插入到有序数组中。步骤是每次选取无序数组的第一个元素从有序数组的最后一个元素开始一一判断，找到位置后，腾出插入位置后插入。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5436dwi6zg20mj0e113f.gif" alt="插入排序"></p><p><strong>代码实现（Go）：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span>&#123;<br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(arr);i++&#123;  <span class="hljs-comment">// 这里每次的i为乱序数组的第一个元素的下标</span><br><span class="hljs-keyword">var</span>(<br>j <span class="hljs-type">int</span><br>temp=arr[i]  <span class="hljs-comment">//后面要移动元素腾出插入的空间，所以要先保存下来</span><br>)<br><span class="hljs-comment">//查找插入位置</span><br><span class="hljs-keyword">for</span> j=i<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--&#123;   <span class="hljs-comment">// 这里的j是每次的有序数组的最后一个元素的下标</span><br><span class="hljs-keyword">if</span> arr[i]&lt;arr[j]&#123; <br><span class="hljs-keyword">continue</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">break</span>  <span class="hljs-comment">//j+1就是要插入的位置了</span><br>&#125;<br>&#125;<br><span class="hljs-comment">//移动位置，腾出插入空间</span><br><span class="hljs-keyword">for</span> ;i&gt;j+<span class="hljs-number">1</span>;i--&#123;<br>arr[i]=arr[i<span class="hljs-number">-1</span>]<br>&#125;<br>arr[j+<span class="hljs-number">1</span>]=temp<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="冒泡排序："><a href="#冒泡排序：" class="headerlink" title="冒泡排序："></a>冒泡排序：</h3><blockquote><p>平均时间复杂度：O(n^2^)</p><p>最优时间复杂度：O(n^2^)  数组为本身有序的情况</p><p>最差时间复杂度：数组为逆序的状态</p><p>空间复杂度：O(1)  不用开辟新数组</p></blockquote><p>一句话理解：每进行一次整个数组（除去浮出水面的）两两交换，就一定会有至少一个当前剩余数组中的最大元素会浮出水面。步骤就是在无序中，不断重复的进行一趟两两比较交换，每次会浮出一个至多个元素，随着浮出元素的增多，每次比较的次数也相应减少。</p><p><strong>代码实现（Go）：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span>&#123;<br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(arr);i++&#123;<br><span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;<span class="hljs-built_in">len</span>(arr)-i;j++&#123;<br><span class="hljs-keyword">if</span> arr[j]&lt;arr[j<span class="hljs-number">-1</span>]&#123;<br>arr[j<span class="hljs-number">-1</span>],arr[j]=arr[j],arr[j<span class="hljs-number">-1</span>]<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高级排序："><a href="#高级排序：" class="headerlink" title="高级排序："></a>高级排序：</h2><h3 id="快速排序："><a href="#快速排序：" class="headerlink" title="快速排序："></a>快速排序：</h3><blockquote><p>平均时间复杂度：O(nlog<del>2</del>n)</p><p>最优时间复杂度：O(nlog<del>2</del>n)  选取的pivot可以，每次都能把数组分成等份的两份</p><p>最差时间复杂度：O(n^2^)选取的pivot不行，分出的数组的元素数量严重不均等</p><p>空间复杂度：O(1)  不用开辟新数组</p></blockquote><p>一句话理解，运用了分治的思想，每次我们都选取一个pivot，将原数组分成左半边数组和右半边数组，左子数组都小于pivot，右子数组都大于pivot，再递归处理这两个左右子数组。步骤就是，我们这里是为了方便选用了数组的最后一个元素为pivot，真实应用场景下可能会根据数据的大致情况选择相应的pivot来提高效率，counter的值理解为经过分类后小于pivot的左子数组的最后一个元素位置加1，所以我们遍历过程中遇到比pivot小的元素就都和counter交换，扩充左子数组，遍历完成后，counter位置始终代表左子数组的下一个位置，所以最后pivot直接与counter交换位置，即能得到分好类的左右子数组。再递归处理左右子数组。</p><p>再记一下自己疑惑的点（不知道为啥疑惑😓）</p><p><strong>剩下两个的情况是怎么结束的？</strong></p><ol><li><p>倒序的情况，按照惯例，pivot设为第二个元素，遍历完比它小的左子数组的下一位即为第一个元素的位置（没有比它小的元素，counter没变），交换后就正序了，进入下面的情况。</p></li><li><p>正序的情况，按照惯例，pivot设为第二个元素，遍历后只有一个元素比它小，比它小的左子数组的下一位即为第二个元素的位置，这时我们再递归处理这两个子数组，我们先看右子数组，我们的左边界会设为counter+1，有边界还是high没有变，而此时counter+1已经大于high了，所以就结束了，我们再看左子数组，此时就是剩余一个元素的情况了。</p></li><li><p>剩余一个元素的情况：判断后low等于high，结束</p></li></ol><p><strong>复杂度为什么O(nlog<del>2</del>n)：</strong>首先是前面的n，前面的n代表是每一层在做<code>partition</code>的时候都要处理“n”次，log<del>2</del>n代表调用栈有多高，最坏情况，调用栈的高度就为n，所以复杂度为O(n^2^)。</p><p><strong>代码实现（Go）：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>,low <span class="hljs-type">int</span>,high <span class="hljs-type">int</span>)</span></span>&#123;<br><span class="hljs-keyword">if</span> low&gt;=high&#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(arr[low:high+<span class="hljs-number">1</span>])<br>pivot:=partition(arr,low,high)<br>quicksort(arr,low,pivot<span class="hljs-number">-1</span>)<br>quicksort(arr,pivot+<span class="hljs-number">1</span>,high)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partition</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>,begin,end <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>&#123;<br>pivot,counter:=arr[end],begin<br><span class="hljs-keyword">for</span> i:=begin;i&lt;end;i++&#123;<br><span class="hljs-keyword">if</span> arr[i]&lt;pivot&#123;<br>fmt.Println(arr[i],arr[counter])<br>arr[i],arr[counter]=arr[counter],arr[i]<br>counter++<br>&#125;<br>&#125;<br>arr[counter],arr[end]=arr[end],arr[counter]<br><span class="hljs-keyword">return</span> counter<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="归并排序："><a href="#归并排序：" class="headerlink" title="归并排序："></a>归并排序：</h3><blockquote><p>平均时间复杂度：O(nlog<del>2</del>n)</p><p>最优时间复杂度：O(nlog<del>2</del>n)  归并排序每次都要分到最小，再合并，所以变化不大</p><p>最差时间复杂度：同上</p><p>空间复杂度：O(n)  需要开辟新数组</p></blockquote><p>一句话理解，先切割成n个子序列，最小为1，然后再合并子序列（归并），在合并的过程中会使这两个子序列合并成整体有序的子序列，不断将整体有序的子序列合并，并且合并过程夹有排序，最终就能得到有序的序列。步骤就是，可以理解为一个后序遍历，先把数组一直切分，“在根结点”合并，把左右子树中整体有序的子序列合并就能最终得到整体有序的序列</p><p><strong>复杂度为什么O(nlog<del>2</del>n)：</strong>先说后面的log<del>2</del>n，归并的调用栈就固定为log<del>2</del>n了，不会像快排那样有变化，而前面的n代表着就是在每一层合并的时候都要处理“n”次。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h543b37d25g20mj0e1qcv.gif" alt="归并排序"></p><p><strong>代码实现（Go）：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, low, high <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> low &gt;= high &#123;  大于的情况是越界了，等于的情况是不用再分了<br><span class="hljs-keyword">return</span><br>&#125;<br>mid := (low + high) &gt;&gt; <span class="hljs-number">1</span><br>fmt.Println(mid)<br>MergeSort(arr, low, mid)<br>MergeSort(arr, mid+<span class="hljs-number">1</span>, high)<br>Merge(arr, low, high, mid)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Merge</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, low, high, mid <span class="hljs-type">int</span>)</span></span> &#123;<br>left, right := low, mid+<span class="hljs-number">1</span><br>TempArr := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, high-low+<span class="hljs-number">1</span>)<br>k := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> left &lt;= mid &amp;&amp; right &lt;= high &#123;<br><span class="hljs-keyword">if</span> arr[left] &lt; arr[right] &#123;<br>TempArr[k] = arr[left]<br>k++<br>left++<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>TempArr[k] = arr[right]<br>k++<br>right++<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> left &lt;= mid &#123;<br>TempArr[k] = arr[left]<br>k++<br>left++<br>&#125;<br><span class="hljs-keyword">for</span> right &lt;= high &#123;<br>TempArr[k] = arr[right]<br>k++<br>right++<br>&#125;<br><span class="hljs-built_in">copy</span>(arr[low:high+<span class="hljs-number">1</span>], TempArr)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆排序："><a href="#堆排序：" class="headerlink" title="堆排序："></a>堆排序：</h3><blockquote><p>平均时间复杂度：O(nlog<del>2</del>n)</p><p>最优时间复杂度：O(nlog<del>2</del>n)  堆排序时间主要在维护堆上，和数组情况无关</p><p>最差时间复杂度：同上</p><p>空间复杂度：O(n)  需要开辟新数组</p></blockquote><p>一句话理解：用序列先维护一个堆(nlog<del>2</del>n)，再用堆弹出堆顶元素到新的数组中，完成排序。堆的维护我们常用语言自带的方法来实现，以Go为例就是实现接口的方法，它的底层实现里面默认弹出时使用的方法是堆顶与最后一个元素交换，弹出最后一个元素，再进行堆的维护，所以我们自己要实现的pop方法就是要弹出最后一个元素，Push方法也一样，默认放在最后一个元素，再进行堆的维护</p><p><strong>复杂度为什么O(nlog<del>2</del>n)：</strong>在维护堆时，堆的特性每次的插入和删除都需要log<del>2</del>n，而要插入n个元素，所以为O(nlog<del>2</del>n)</p><p><strong>代码实现（Go）：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myHeap []<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(heap *myHeap)</span></span>Len()<span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span>(<span class="hljs-built_in">len</span>(*heap))&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(heap *myHeap)</span></span>Less(i,j <span class="hljs-type">int</span>)<span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> (*heap)[i]&lt;(*heap)[j] &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(heap *myHeap)</span></span>Swap(i,j <span class="hljs-type">int</span>) &#123;(*heap)[i],(*heap)[j]=(*heap)[j],(*heap)[i]&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(heap *myHeap)</span></span>Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;*heap=<span class="hljs-built_in">append</span>(*heap,x.(<span class="hljs-type">int</span>))&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(heap *myHeap)</span></span>Pop()<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br><span class="hljs-keyword">var</span> x=(*heap)[<span class="hljs-built_in">len</span>(*heap)<span class="hljs-number">-1</span>] <br>*heap=(*heap)[<span class="hljs-number">0</span>:<span class="hljs-built_in">len</span>(*heap)<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>myheap:=&amp;myHeap&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>&#125;<br>a:=<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(*myheap))<br>heap.Init(myheap)<br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(a);i++&#123;<br>a[i]=heap.Pop(myheap).(<span class="hljs-type">int</span>)<br>&#125;<br>fmt.Println(a)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速排序与归并排序的比较："><a href="#快速排序与归并排序的比较：" class="headerlink" title="快速排序与归并排序的比较："></a>快速排序与归并排序的比较：</h3><p>快速排序和归并排序的平均时间复杂度都是O(nlog<del>2</del>n)，而快速排序的最坏情况是O(n^2^)，但快排还是优于归并，快排优于归并的地方在哪？</p><ol><li><p>快速排序中效率的主要来源之一是引用位置，在引用位置中，计算机硬件经过优化，因此访问彼此相邻的内存位置往往比访问分散在整个内存中的内存位置更快。quicksort中的分区步骤通常具有很好的局部性，因为它访问前面和后面附近的连续数组元素。因此，快速排序往往比其他排序算法（如heapsort）执行得更好，尽管它通常执行大致相同数量的比较和交换，因为在heapsort的情况下，访问更加分散。</p><p>也就是说，一个原因是计算机硬件经过优化，访问彼此相邻的内存位置往往比访问分散在整个内存中的内存位置更快，所以快速排序我们在划分数组的时候，元素都是相邻的，而归并排序在合并的时候是元素较为分散，所以在这一点上快排优于归并</p></li><li><p>另一个普遍都知道的原因就是快排我们可以直接在原数组上操作，而归并排序我们在合并的时候需要重新开辟数组（空间复杂度为O(n)），还要进行多次的赋值的操作，所以在这一点上让快排优于归并。</p></li></ol><p><strong>和堆排序的相比：</strong>在维护堆的时候，堆排里面有大量近乎无效的比较，因为被拿到堆顶的那个元素几乎肯定是很小的，而靠近堆顶的元素又几乎肯定是很大的，将一个很小的数和一个很大的数比较，结果几乎肯定是“小于”的，这就意味着问题的可能性只被排除掉了很小一部分。</p><p>所以堆排虽然和快排一样复杂度都是O(nlog<del>2</del>n)但堆排复杂度的常系数更大</p>]]></content>
    
    
    <categories>
      
      <category>站在巨人的肩膀上</category>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>🤯从输入URL到页面展示，这中间发生了什么？🤬</title>
    <link href="/2022/08/07/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%EF%BC%8C%E8%BF%99%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <url>/2022/08/07/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%EF%BC%8C%E8%BF%99%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<p>面对这道高频面试题，一定得好好理解下。包括了导航流程和TCP连接</p><span id="more"></span><h1 id="从输入URL到页面展示，这中间发生了什么"><a href="#从输入URL到页面展示，这中间发生了什么" class="headerlink" title="从输入URL到页面展示，这中间发生了什么?"></a>从输入URL到页面展示，这中间发生了什么?</h1><p><img src="https://static001.geekbang.org/resource/image/71/e3/714208d4e10499868688361130d1d2e3.jpg"></p><h2 id="三个进程："><a href="#三个进程：" class="headerlink" title="三个进程："></a>三个进程：</h2><p><strong>浏览器进程：</strong>主要负责用户的交互、子进程的控制和文件存储的服务</p><p><strong>网络进程</strong>：主要负责为浏览器进程和渲染进程提供下载功能</p><p><strong>渲染进程：</strong>对接受的javascript，css，html、图片等资源解析成可以显示和交互的界面</p><h2 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h2><ol><li>用户输入URL回车后，浏览器进程先判断输入的内容是否为搜索内容，是的话就会根据浏览器的默认搜索引擎，组成新的带有搜索内容的URL。如果输入的内容符合URL规则，那就会选用相应的协议，一般现在的网站都是HTTPS，组成新的URL。</li><li>浏览器进程会通过进程间通信（IPC），向网络进程发送URL请求，由网络进程真正进行URL请求。</li><li>获得URL后，网络进程不是直接就开始请求的步骤，而是先查找本地缓存是否缓存了该资源。如果有找到缓存资源则结束请求，直接把资源返回给浏览器进程。没有再进行接下来的步骤。</li><li>URL请求第一步是找目标服务器的地址和端口号，也就是域名解析，首先会在本地的域名解析缓存中查找是否有该域名的缓存记录，有则会直接使用该地址和端口号，本地缓存没有再会向DNS服务器发送请求，获得服务器地址和端口号。如果获取到的只有IP地址，则会使用默认的端口号，HTTP默认是80而HTTPS默认的是HTTPS。如果是HTTPS协议，这里还有一个步骤：建立TLS连接。</li><li>接下来就是使用IP地址与服务器进行TCP连接</li></ol><h3 id="TCP连接："><a href="#TCP连接：" class="headerlink" title="TCP连接："></a>TCP连接：</h3><p><img src="https://pic.rmb.bdstatic.com/bjh/d5169b6fc8b3fad501c31afb19f037ff.jpeg" alt="TCP结构"></p><h4 id="😊三次握手："><a href="#😊三次握手：" class="headerlink" title="😊三次握手："></a>😊三次握手：</h4><p><strong>第一次握手：</strong> 此次过程为TCP客户端发送一个TCP报文段，里面将首部的同步位SYN设为1，表明该报文段为连接请求报文段，并为序号字段（seq）设置一个值x，（这个序号会给消耗掉，即接下来的报文段要用x+1，因为TCP规定SYN设置为1后不可携带数据，但会消耗掉一个序号）作为TCP客户端所选择的初始序号，并进入同步已发送阶段。</p><p><strong>第二次握手：</strong>TCP服务器端接受到客户端发来请求连接报文段后，如果同意连接，会往客户端再发送一个TCP报文段，里面将首部的同步位SYN和确认位ACK都设为1，表明该报文段为连接请求确认报文段，并为序号字段（seq）设置一个值y，作为TCP服务器进程所选择的初始序号，确认号字段设为x+1，这是对TCP客户端所选择的初始序号的确认。同时进入同步己接受阶段</p><p><strong>第三次握手：</strong>TCP客户端接受到请求连接确认报文段后，会往服务器端再发送一次TCP报文段，里面将确认位ACK设为1，表明这是一个普通的TCP确认报文段，并将序号设置为x+1（TCP规定普通的确认报文段可以携带数据，如果这次报文段中有携带数据那这个序号将会给消耗掉，如果没有携带，那么下一次发送TCP请求时则还可以继续用这个x+1），确认号设置为y+1,这是对服务器的初始序号的确认。发送完成后，客户端进入连接已建立状态，服务器接收到确认报文段后也进入连接已建立状态。</p><p><strong>为什么要三次，两次不行吗？</strong></p><p>这是因为TCP为了保证连接的可靠性，始终认为网络层是不可靠的，如果是两次握手那TCP服务器端在发送完TCP请求连接确认报文段后就会进入连接已建立状态，这里就存在一种可能，在服务器端接收到请求连接报文段前，因为网络问题，客户端一直没接受到请求连接确认报文段已经发送了好几个请求连接报文段，而等到TCP服务器端接受到TCP请求连接报文段，TCP客户端接受到请求连接报文段，并完成了数据传输，四次挥手断开连接后，之前那些没能到达服务器端的TCP请求连接报文段又姗姗来迟到达了服务器端，这是我们如果我们采用的两次握手，服务器端就会进入连接已建立状态，而因为客户端已经认为这次连接已经完成了，那这个状态就会一直尬等着，没人传数据也没人告诉他断开，这样就导致占用了服务器端许多的资源。</p><h4 id="🤗四次挥手："><a href="#🤗四次挥手：" class="headerlink" title="🤗四次挥手："></a>🤗四次挥手：</h4><p>客户端和服务器端都可以发起断开连接，这里以客户端为例</p><p><strong>第一次挥手：</strong>此时客户端会发送一个TCP报文段，里面将终止位FIN和确认位ACK设置为1，表明该报文段为请求释放报文段，并将序号设置为u（u等于最后一次客户端发送到服务器端的数据的最后一个字节的序号加1，并且TCP规定即使该请求释放报文段不携带数据也会消耗一个序号），确认号设置为v(v等于客户端之前接受到的数据的最后一个字节的序号+1)，同时进入终止等待1状态</p><p><strong>第二次挥手：</strong>服务器端接受到连接释放字段后，再发送一个TCP报文段，里面将ACK设为1，表明该报文段为普通确认报文段，并将序号设置为v（与上面的v相等）确认号设置为u+1，并进入关闭等待状态。这时服务器端会通知应用层TCP客户端要断开与服务器端的连接，此时客户端到服务器端的这个方向的连接就释放了（由全双工变为半双工，客户端可以继续接受数据，但不可以发送数据了，这里别错误理解为不能发送任何东西了，只是不能依赖建立的通道可靠的发送数据，但是还是可以发送TCP报文段的），客户端接受到普通确认报文段后进入终止等待2状态。</p><p><strong>第三次挥手：</strong>等到应用层进程发送完数据后，它就会通知TCP服务器段进程关闭TCP连接，TCP服务端会再向客户端发送一个TCP报文段，里面将终止位FIN和确认位设置为1，表明该报文段为连接释放报文段，并将序号设置为w(w等于后来服务器端往客户端发送的剩余的数据的最后一个字节的序号+1)，确认号设置为u+1(对一次挥手的报文段的再次确认)，同时进入最后确认状态。</p><p><strong>第四次挥手：</strong>客户端收到连接释放字段后，再向服务器端发送一个TCP报文段，里面将确认位ACK设为1,表明该报文段为普通确认报文段，并将序号设置为u+1，确认号设为w+1，服务器端接受到该确认报文段后进入关闭状态，而客户端进入时间等待状态，只有等2MSL（Maximum Segment Lifetime，最长报文寿命）后进入关闭状态。</p><p><strong>为什么要等待：</strong>还是一样，TCP始终认为网络层是不可靠的，第四次挥手发送的TCP报文段可能因为某种原因未能到达服务器端，而服务器端没接受到客户端的确认报文字段就会发起超时重传连接释放字段，而这时客户端已经关闭了，服务器端不可能再接受到确认报文字段，会一直进行超时重传，一直处于最后确认状态，而无法进入关闭状态。而且经过了这个2MSL时间，就可以使本次连接的所有字段都消失，保证下一次连接不会收到旧的字段。</p><ol start="6"><li>TCP连接建立后，浏览器就会构建请求行和请求头等信息，并把和该域名相关的Cookie等数据附加到请求头中，然后向服务器发送构建好的请求信息。</li><li>服务器接受到消息后，就根据请求信息生成响应信息（包括响应行，响应头和响应体等信息），并发送回客户端。</li><li>网络进程接受到响应信息后就开始解析响应头信息，首先是判断状态码是否3xx，是否为重定向，如果是的话就读取响应头的Location字段中的地址信息，然后再发起HTTP或HTTPS请求，一切由从头开始了。</li><li>处理了跳转信息后，接下来就是处理响应数据类型，URL请求有时可能请求的是一个下载类型，也可能是一个正常的HTML界面，这时浏览器就会根据响应头中的Content-Type来处理请求，如果Content-Type为下载类型那就将它交给浏览器的下载管理器，而该URL的导航到此就结束了。但如果是HTML，那就会继续下面的导航流程。接下来就是通知浏览器进程开始<strong>准备渲染</strong>。</li><li>浏览器进程收到通知后，Chrome的方案是如果当前浏览器下已经有同一站点（同一域名，同一协议）的渲染进程，那就会复用其渲染进程，否则则是创建一个新的渲染进程，渲染进程准备好之后还不能进入文档解析阶段，因为此时的文档数据还在网络进程中，并没有提交给渲染进程。</li><li>提交文档阶段，提交响应信息中的响应体部分，<strong>提交文档</strong>的命令由浏览器进程发出，渲染进程接收到通知后，会和网络进程建立传输数据的“管道”，等到文档全部提交后，渲染进程会给浏览器进程发送<strong>确认提交</strong>的信息。</li><li>浏览器接受到<strong>确认提交</strong>的消息后，就会<strong>更新浏览器界面状态</strong>，包括了安全状态，地址栏的URL、前进后退的历史状态，并更新web界面。</li><li>之后就是渲染进程了，一旦渲染进程结束，就会往浏览器进程发送信息，收到信息后，浏览器就会停止标签图标上加载动画</li></ol>]]></content>
    
    
    <categories>
      
      <category>站在巨人的肩膀上</category>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>😃搞定Docker--进阶使用</title>
    <link href="/2022/07/30/%E6%90%9E%E5%AE%9ADocker--%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/30/%E6%90%9E%E5%AE%9ADocker--%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="😃搞定Docker–进阶使用"><a href="#😃搞定Docker–进阶使用" class="headerlink" title="😃搞定Docker–进阶使用"></a>😃搞定Docker–进阶使用</h1><p>在快速入门学习完后，我们开始来学习些真实工作场景下，需要了解学习的技术。</p><span id="more"></span><p>在快速入门那一节我们使用的镜像都是从公共的docker仓库拉取的，而对于一些真实使用的场景，我们常常需要将整个项目的环境都配置到一个镜像中，给使用者一个开箱即用的体验。这里就需要镜像构建的技术。通常有以下两种方式：</p><ul><li><code>docker commit</code>：从已有容器创建一个新的镜像。</li><li><code>docker build</code>：配合 Dockerfile 文件创建镜像。</li></ul><h2 id="Commit命令创建镜像："><a href="#Commit命令创建镜像：" class="headerlink" title="Commit命令创建镜像："></a>Commit命令创建镜像：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker commit [OPTIONS] 容器名 [创建后的镜像名[:TAG]]<br></code></pre></td></tr></table></figure><p> <strong>参数说明：</strong></p><ul><li><strong>-a</strong>：镜像作者</li><li><strong>-m</strong>：提交时的说明</li><li><strong>-p</strong>：在容器commit时，将容器暂停</li><li>TAG虽然是可选，但强烈建议还是加上比较好</li></ul><h3 id="一个栗子💭"><a href="#一个栗子💭" class="headerlink" title="一个栗子💭"></a>一个栗子💭</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.先拉取一个镜像<br>docker pull centos:7<br>2.创建一个容器<br>docker run -di --name centos centos:7<br>3.进入容器<br>docker <span class="hljs-built_in">exec</span> -it centos bash<br>4.配置Go环境，和mysql到里面（docker <span class="hljs-built_in">cp</span> 拷贝、解压）<br>5.创建镜像<br>docker commit -a <span class="hljs-string">&quot;PEngxJ&quot;</span> -m <span class="hljs-string">&quot;Go and mysql&quot;</span> centos mycentos:7<br>6.根据自己的镜像创建容器<br>docker run -di --name mycentos mycentos:7 <br><br></code></pre></td></tr></table></figure><h2 id="Dockerfile方式："><a href="#Dockerfile方式：" class="headerlink" title="Dockerfile方式："></a>Dockerfile方式：</h2><blockquote><p>总体来说就是把上面一个个的步骤写到一个Dockerfile文件中，然后运行这个文件，它就会自动帮我们完成所有步骤，然后创建相应的容器。</p></blockquote><p>在使用该方式前，我们得先学一学Dockerfile的常用命令</p><h3 id="FROM："><a href="#FROM：" class="headerlink" title="FROM："></a>FROM：</h3><p><strong>指定该镜像是基于哪个镜像构建的</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">eg:<br>FROM centos:7<br></code></pre></td></tr></table></figure><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN:"></a>RUN:</h3><p><strong>执行后面跟着的命令行命令</strong>,有以下两种格式：</p><p>shell格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> &lt;命令行命令&gt;</span><br><span class="hljs-comment">#&lt;命令行命令&gt;和在终端上的命令一样</span><br>eg:<br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;RUN&#x27;</span> &gt; /usr/local/run.text</span><br></code></pre></td></tr></table></figure><p>exec格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">&quot;可执行文件&quot;</span>,<span class="hljs-string">&quot;参数1&quot;</span>,<span class="hljs-string">&quot;参数2&quot;</span>]</span><br>eg：<br><span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">&quot;./main.go&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>]</span><br><span class="hljs-comment">#相当于 RUN ./main.go hello world</span><br></code></pre></td></tr></table></figure><p>**注意:**Dockerfile的指令每执行一次都会在docker上新建一层（之前镜像分层的概念），所以过多无意义的层必会导致生成的镜像的膨胀。所以常采用以下方式：</p><p>不用：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos<br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y install wget</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> wget -O redis.tar.gz <span class="hljs-string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span></span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> tar -xvf redis.tar.gz</span><br></code></pre></td></tr></table></figure><p>而用：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos<br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y install wget \</span><br><span class="language-bash">    &amp;&amp; wget -O redis.tar.gz <span class="hljs-string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span><br><span class="language-bash">    &amp;&amp; tar -xvf redis.tar.gz</span><br></code></pre></td></tr></table></figure><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY:"></a>COPY:</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> [--<span class="hljs-built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;...  &lt;目标路径&gt;</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> [--<span class="hljs-built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [<span class="hljs-string">&quot;&lt;源路径1&gt;&quot;</span>,...  <span class="hljs-string">&quot;&lt;目标路径&gt;&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>[–chown&#x3D;&lt;user&gt;:&lt;group&gt;]：可选参数，用户改变复制到容器内文件的拥有者和属组</p><p>**&lt;源路径&gt;**：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> hom* /mydir/</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> hom?.txt /mydir/</span><br></code></pre></td></tr></table></figure><p>**&lt;目标路径&gt;**：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。</p><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD:"></a>ADD:</h3><p>ADD 指令和 COPY 的使用格类似（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下：</p><p>区别：ADD命令，如果复制的内容是压缩包的话，则它会自动解压，当然这样也带来一个不好的地方就是它不能用来复制压缩包</p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD:"></a>CMD:</h3><p>和RUN一样用与执行命令，不过他们各自的执行时间不同。RUN在<code>docker build</code>的时候执行，而CMD是在<code>docker run</code>时执行的。</p><p>介于这点它常用于为启动的容器指定默认的启动程序，如果想让容器一直运行着那就必须得让这个程序在<strong>前台运行</strong>，不然根据docker的规则当命令运行结束后docker就退出了。</p><p><strong>注意：</strong></p><ol><li>CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</li></ol><p>eg：<code>docker run --name nginx -P nginx echo &#39;hello&#39;</code>如果是这样的话，那就会使Dockerfile中CMD的失效。</p><ol start="2"><li>如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。</li></ol><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="language-bash"> &lt;shell 命令&gt; </span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;可执行文件或命令&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...] </span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...]  <span class="hljs-comment"># 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</span></span><br></code></pre></td></tr></table></figure><p>推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。</p><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT:"></a>ENTRYPOINT:</h3><p>和上面CMD类型，在<code>docker run</code>时执行命令，但不同的是它不会被<code>docker run</code>跟着的参数中的命令所覆盖，而是把这些“命令”做为参数给ENTRYPOINT设置的命令使用。</p><p>当然, 如果运行 docker run 时使用了 –entrypoint 选项，将覆盖 ENTRYPOINT 指令指定的程序。</p><p><strong>优点</strong>：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。（ENTRYPOINT设置定参后，后面我们可以在docker run时自己指定变参，可以看后面例子）</p><p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;executeable&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...]</span><br></code></pre></td></tr></table></figure><p>示例：</p><p>假设已通过 Dockerfile 构建了 nginx:test 镜像：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> nginx<br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;nginx&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>] <span class="hljs-comment"># 定参</span></span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/etc/nginx/nginx.conf&quot;</span>] <span class="hljs-comment"># 变参 </span></span><br></code></pre></td></tr></table></figure><p>1、不传参运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run  nginx:<span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><p>容器内会默认运行以下命令，启动主进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx -c /etc/nginx/nginx.conf<br></code></pre></td></tr></table></figure><p>2、传参运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run nginx:<span class="hljs-built_in">test</span> <span class="hljs-string">&quot;/etc/nginx/new.conf&quot;</span></span><br></code></pre></td></tr></table></figure><p>容器内执行以下命令，启动主进程(&#x2F;etc&#x2F;nginx&#x2F;new.conf:假设容器内已有此文件)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx -c /etc/nginx/new.conf<br></code></pre></td></tr></table></figure><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV:"></a>ENV:</h3><p>设置环境变量</p><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> &lt;key&gt; &lt;value&gt;<br><span class="hljs-keyword">ENV</span> &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...<br></code></pre></td></tr></table></figure><h3 id="LABLE"><a href="#LABLE" class="headerlink" title="LABLE:"></a>LABLE:</h3><p>LABEL 指令用来给镜像添加一些元数据（metadata），以键值对的形式，语法格式如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">LABEL</span><span class="language-bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span><br></code></pre></td></tr></table></figure><p>eg:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">LABEL</span><span class="language-bash"> image.authors=<span class="hljs-string">&quot;runoob&quot;</span></span><br></code></pre></td></tr></table></figure><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE:"></a>EXPOSE:</h3><p>仅仅是声明端口并不会打开</p><p>作用：</p><ul><li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。（在docker run时 -p）</li><li>在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</li></ul><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">EXPOSE</span> &lt;端口<span class="hljs-number">1</span>&gt; [&lt;端口<span class="hljs-number">2</span>&gt;...]<br></code></pre></td></tr></table></figure><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR:"></a>WORKDIR:</h3><p>指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。如果不存在，docker会自动创建。</p><p>作用：</p><p>WORKDIR指令为Dockerfile中在其下面的任何RUN、CMD、ENTRYPOINT、COPY和ADD指令设置工作目录。</p><p><strong>怎么理解工作目录：</strong></p><p>在上面的RUN我们说过，每次的RUN都会在docker上新建一层，所以就会导致后面的命令不知道前面的命令的情况。举个例子：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">cd</span> /app</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello&quot;</span> &gt; world.txt</span><br></code></pre></td></tr></table></figure><p>这里我们构键完后会发现在目录&#x2F;app下找不到world.txt，而会在一个其它的地方找到这个东西，这就是上面所说的，因为下一个<code>RUN</code>根本不会在<code>/app</code>目录下。</p><p>这里我们就要用到<strong>WORKDIR</strong>了：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello&quot;</span> &gt; world.txt</span><br></code></pre></td></tr></table></figure><p>如果你的 <code>WORKDIR</code> 指令使用的相对路径，那么所切换的路径与之前的 <code>WORKDIR</code> 有关：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /a</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> b</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> c</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">pwd</span></span><br></code></pre></td></tr></table></figure><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME:"></a>VOLUME:</h3><p>定义&#x3D;&#x3D;匿名&#x3D;&#x3D;数据卷</p><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">VOLUME</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;容器路径1&gt;&quot;</span>, <span class="hljs-string">&quot;&lt;容器路径2&gt;&quot;</span>...]</span><br><span class="hljs-keyword">VOLUME</span><span class="language-bash"> &lt;容器路径&gt;</span><br></code></pre></td></tr></table></figure><p>不过我们一般通过在<code>docker run</code>时添加<code>-v</code>参数来指定挂载目录</p><h3 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build:"></a>docker build:</h3><p>常用的参数：</p><ul><li><code>-t</code>：镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</li><li><code>-f</code>：指定要使用的Dockerfile路径；</li></ul><h3 id="一个栗子🤖："><a href="#一个栗子🤖：" class="headerlink" title="一个栗子🤖："></a>一个栗子🤖：</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos:<span class="hljs-number">7</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> go1.18.4.linux-amd64.tar.gz /usr/local/go</span><br>&amp;&amp; Goweb /usr/home/<br><span class="hljs-keyword">ENV</span> PATH=$PATH:/usr/local/go/bin <br><span class="hljs-keyword">LABEL</span><span class="language-bash"> author=<span class="hljs-string">&quot;PEngxJ&quot;</span></span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /usr/home/</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> go run /usr/home/Goweb/main.go</span><br></code></pre></td></tr></table></figure><h2 id="镜像迁移："><a href="#镜像迁移：" class="headerlink" title="镜像迁移："></a>镜像迁移：</h2><h3 id="备份与恢复的方式："><a href="#备份与恢复的方式：" class="headerlink" title="备份与恢复的方式："></a>备份与恢复的方式：</h3><p><strong>备份：</strong></p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker save <span class="hljs-selector-attr">[OPTIONS]</span> IMAGE <span class="hljs-selector-attr">[IMAGE...]</span><br></code></pre></td></tr></table></figure><ul><li>-o :输出到的文件</li></ul><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker save -o myubuntu.tar ubuntu:v3<br></code></pre></td></tr></table></figure><p><strong>恢复：</strong></p><p>语法:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">docker <span class="hljs-keyword">load</span> [<span class="hljs-keyword">OPTIONS</span>]<br></code></pre></td></tr></table></figure><ul><li>-i : 指定导入的文件，代替 STDIN。</li><li>-q : 精简输出信息。</li></ul><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker load -i myubuntu.tar<br></code></pre></td></tr></table></figure><h3 id="上传至私人与共有的方式："><a href="#上传至私人与共有的方式：" class="headerlink" title="上传至私人与共有的方式："></a>上传至私人与共有的方式：</h3><p>得先注册一个在dockerhub上的号。然后使用<code>docker login</code>登录，<code>docker logout</code>退出。</p><h4 id="公共仓库："><a href="#公共仓库：" class="headerlink" title="公共仓库："></a>公共仓库：</h4><p><strong>上传：</strong></p><ol><li><p>docker tag : 标记本地镜像。</p><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker tag IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> tag hello-world:latest peng7066/test-hello-world:<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li><li><p>docker push：上传镜像。</p><p>语法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker push NAME[:TAG]<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> push peng7066/test-hello-world:<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li></ol><p><strong>拉取：</strong></p><ol><li>docker pull：拉取镜像</li></ol><h4 id="私有仓库："><a href="#私有仓库：" class="headerlink" title="私有仓库："></a>私有仓库：</h4><p><strong>配置私有仓库认证：</strong></p><ol><li><p>生成自签名证书：</p><ol><li><p>创建证书目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p /usr/local/registry/certs<br></code></pre></td></tr></table></figure></li><li><p>生成自签名证书命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl req -newkey rsa:2048 -nodes -sha256 -keyout /usr/local/registry/domain.key -x509 -days 365 -out /usr/local/registry/certs/domain.crt<br></code></pre></td></tr></table></figure><ul><li><code>openssl req</code>：创建证书签名请求等功能；</li><li><code>-newkey</code>：创建CSR证书签名文件和RSA私钥文件；</li><li><code>rsa:2048</code>：指定创建的RSA私钥长度为2048；</li><li><code>-nodes</code>：对私钥不进行加密；</li><li><code>-sha256</code>：使用SHA256算法</li><li><code>-keyout</code>：创建的私钥文件名称及位置</li><li><code>-x509</code>：自签发证书格式</li><li><code>-days</code>：证书有效期</li><li><code>-out</code>：指定CSR输出文件名称及位置</li></ul><p>通过openssl 先生成自签名证书，运行命令后需要填写一些证书信息，里面最关键的部分是：<code>Common Name (eg,your name or your server&#39;s hostname) []:81.70.10.115</code>，这里注意填写的要是自己服务器的地址。</p></li></ol></li><li><p>生成鉴权密码文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建存储鉴权密码文件的目录</span><br>mkdir -p /usr/local/registry/auth<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果没有htpasswd 功能需要安装 htpasswd</span><br>yum install -y httpd<br><span class="hljs-meta prompt_">#</span><span class="language-bash">创建用户和密码</span><br>htpasswd -Bbn root 1234 &gt; /usr/local/registry/auth/htpasswd<br></code></pre></td></tr></table></figure><blockquote><p>htpasswd 是 apache http 的基本认证文件，使用htpasswd 命令可以生成用户及密码文件</p></blockquote></li><li><p>拉取镜像后修改配置文件</p><p>修改配置文件<code>daemon.json</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/docker/daemon.json<br></code></pre></td></tr></table></figure><p>添加以下字段，指明我们的私有镜像仓库的地址</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-string">&quot;insecure-registries&quot;</span>: [<span class="hljs-string">&quot;81.70.10.115:5000&quot;</span>]<br></code></pre></td></tr></table></figure></li><li><p>创建私有仓库容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -di --name registry -p 5000:5000 \<br>-v /mydata/docker_registry:/var/lib/registry \<br>-v /usr/local/registry/certs:/certs \<br>-v /usr/local/registry/auth:/auth \<br>-e &quot;REGISTRY_AUTH=htpasswd&quot; \<br>-e &quot;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&quot; \<br>-e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \<br>-e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt \<br>-e REGISTRY_HTTP_TLE_KEY=/certs/domain.key \<br>registry<br></code></pre></td></tr></table></figure></li><li><p>登录</p><p>这时要指定仓库的地址</p><p><code>docker login 81.70.10.115:5000</code></p><p>然后就可以正常地<code>docker push</code>了</p><p>退出时也要指定仓库的地址</p><p><code>docker logout 81.70.10.115:5000</code></p></li></ol><h2 id="使用自定义网络："><a href="#使用自定义网络：" class="headerlink" title="使用自定义网络："></a>使用自定义网络：</h2><blockquote><p>默认的docker网络模式有三种：bridge，host，none</p><p>自定义的网络就是bridge的改进版，我们可以通过容器的名称直接来通讯，而不是每次启动都会改变的ip地址</p></blockquote><table><thead><tr><th>网络模式</th><th>简介</th></tr></thead><tbody><tr><td>Bridge</td><td>在这个模式中，docker daemon(守护进程)创建了一个以太网桥<code>docker0</code>，新建的容器会自动桥接到这个接口，<strong>具体流程是：</strong>守护进程会创建一对对等虚拟设备接口，将其中一端设为容器的<code>eth0</code>接口，一端保存在宿主机的命名空间中。容器创建时默认使用该模式。它分配ip的规则是根据容器的启动顺序递增分配的，就会出现上面说的情况，ip地址会变动。</td></tr><tr><td>Host</td><td>容器将不会虚拟出自己的网卡，配置自己的ip等。<strong>而是直接使用宿主机的ip和端口</strong></td></tr><tr><td>none</td><td>容器有独立的Network namespace,但并没有进行任何网络设置</td></tr></tbody></table><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5unw810twj20ol0dtdh8.jpg" alt="bridge"></p><h3 id="创建网络："><a href="#创建网络：" class="headerlink" title="创建网络："></a>创建网络：</h3><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker network create [OPTIONS] 网络名称<br></code></pre></td></tr></table></figure><p>重要参数：</p><ul><li><code>-d</code>：定义网络的驱动程序，默认为bridge</li></ul><h3 id="使用自定义网络：-1"><a href="#使用自定义网络：-1" class="headerlink" title="使用自定义网络："></a>使用自定义网络：</h3><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --net 网络名称 镜像名称<br></code></pre></td></tr></table></figure><h3 id="其它"><a href="#其它" class="headerlink" title="其它:"></a>其它:</h3><p><strong>断开：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">docker network disconnect <br></code></pre></td></tr></table></figure><blockquote><p>还有个集群的部分，未完待续。。。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>打怪升级</category>
      
      <category>搞定docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>🎮redis入门--简单命令</title>
    <link href="/2022/07/28/redis%E5%85%A5%E9%97%A8--%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/07/28/redis%E5%85%A5%E9%97%A8--%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>之前学过一段时间的redis，但碍于囫囵吞枣，而且没做总结，后来又没怎么用，所以忘的七七八八了，这次要整体好好的学一学redis，首先从简单命令开始。</p><span id="more"></span><h1 id="⛽redis入门–简单命令🙂"><a href="#⛽redis入门–简单命令🙂" class="headerlink" title="⛽redis入门–简单命令🙂"></a>⛽redis入门–简单命令🙂</h1><h2 id="五种数据类型："><a href="#五种数据类型：" class="headerlink" title="五种数据类型："></a>五种数据类型：</h2><h3 id="键命令："><a href="#键命令：" class="headerlink" title="键命令："></a>键命令：</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/keys-del.html">DEL key</a></td><td>删除键</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-dump.html">DUMP key</a></td><td>序列化键对应的值</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-exists.html">EXISTS key</a></td><td>判断键是否存在</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-expire.html">EXPIRE key</a> seconds</td><td>设置键的过期时间</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-expireat.html">EXPIREAT key timestamp</a></td><td>设置键在具体的一个时间过期，参数是时间戳的形式</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-pexpire.html">PEXPIRE key milliseconds</a></td><td>设置键的过期时间，参数以毫秒为单位</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-pexpireat.html">PEXPIREAT key milliseconds-timestamp</a></td><td>设置键在具体的一个时间过期，参数是毫秒时间戳的形式</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-keys.html">KEYS pattern</a></td><td>匹配符合的KEY</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-move.html">MOVE key db</a></td><td>将键移到其它的数据库</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-persist.html">PERSIST key</a></td><td>将KEY的过期时间去掉，永久保存</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-pttl.html">PTTL key</a></td><td>返回Key的有效时间，以毫秒为单位</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-ttl.html">TTL key</a></td><td>同上，以秒为单位</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-randomkey.html">RANDOMKEY</a></td><td>随机返回一个Key</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-rename.html">RENAME key newkey</a></td><td>重命名，如果newkey已经存在，则会覆盖</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-renamenx.html">RENAMENX key newkey</a></td><td>重命名，不过只有newkey不存在时才会成功</td></tr><tr><td>[SCAN cursor <a href="https://www.runoob.com/redis/keys-scan.html">MATCH pattern] [COUNT count]</a></td><td>遍历键，每次返回一个</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-type.html">TYPE key</a></td><td>返回Key的类型</td></tr></tbody></table><h3 id="String-字符串-："><a href="#String-字符串-：" class="headerlink" title="String(字符串)："></a>String(字符串)：</h3><ul><li>string是redis中最基本的数据类型，一个key对应一个value。</li><li>string 类型是二进制安全的。意思是它可以存储任何数据，比如jpg图片和序列化后的对象。</li><li>最多可以存储512MB</li></ul><h4 id="增："><a href="#增：" class="headerlink" title="增："></a>增：</h4><table><thead><tr><th>增</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/strings-set.html">SET key value</a></td><td>设置指定KEY的值，KEY不存在则是添加，存在则是修改覆盖</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-mset.html">MSET key value key value </a></td><td>同时设置多个值</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-setbit.html">SETBIT key offset value</a></td><td>设置key上一个位的值（0或1）</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-setex.html">SETEX key seconds value</a></td><td>设置一个值，并设置过期时间</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-psetex.html">PSETEX key milliseconds value</a></td><td>设置一个值，并设置过期时间，时间的单位毫秒</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-setnx.html">SETNX key value</a></td><td>当KEY还未被使用时，在这个key上设一个值</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-msetnx.html">MSETNX key value key value </a></td><td>同时设置多个值，只有每个KEY都未被使用时成功执行</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-incr.html">INCR key</a></td><td>为数值加1</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-incrby.html">INCRBY key increment</a></td><td>为数值加上increment</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-incrbyfloat.html">INCRBYFLOAT key increment</a></td><td>将 key 所储存的值加上给定的浮点增量值（increment）</td></tr></tbody></table><h4 id="删："><a href="#删：" class="headerlink" title="删："></a>删：</h4><table><thead><tr><th>删</th><th>-</th></tr></thead><tbody><tr><td>DEL KEY</td><td>删查一个键</td></tr><tr><td>借鉴上面的过期</td><td></td></tr></tbody></table><h4 id="查："><a href="#查：" class="headerlink" title="查："></a>查：</h4><table><thead><tr><th>查</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/strings-get.html">GET key</a></td><td>获取key对应的值</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-mget.html">MGET key1 key2</a></td><td>获取多个key对应的值</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-getrange.html">GETRANGE key start end</a></td><td>获取key值对应区间的子字符串</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-getbit.html">GETBIT key offset</a></td><td>获取key上一个位的值</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-strlen.html">STRLEN key</a></td><td>获取key对应的值的长度</td></tr></tbody></table><h4 id="改："><a href="#改：" class="headerlink" title="改："></a>改：</h4><table><thead><tr><th>改</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/strings-setrange.html">SETRANGE key offset value</a></td><td>用value值从offset开始覆盖写</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-incr.html">INCR key</a></td><td>为数值加1</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-incrby.html">INCRBY key increment</a></td><td>为数值加上increment</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-incrbyfloat.html">INCRBYFLOAT key increment</a></td><td>将 key 所储存的值加上给定的浮点增量值（increment）</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-decr.html">DECR key</a></td><td>为数值减1</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-decrby.html">DECRBY key decrement</a></td><td>为数值减decremen</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-append.html">APPEND key value</a></td><td>如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。</td></tr></tbody></table><h3 id="Hash-哈希-："><a href="#Hash-哈希-：" class="headerlink" title="Hash(哈希)："></a>Hash(哈希)：</h3><h4 id="增：-1"><a href="#增：-1" class="headerlink" title="增："></a>增：</h4><table><thead><tr><th>增</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/hashes-hset.html">HSET key field value</a></td><td>设置key上一个键值对</td></tr><tr><td><a href="https://www.runoob.com/redis/hashes-hmset.html">HMSET key field1 value1 field2 value2 </a></td><td>设置key上的多个键值对</td></tr><tr><td><a href="https://www.runoob.com/redis/hashes-hsetnx.html">HSETNX key field value</a></td><td>当key上的field字段还未设置时，添加该键值对</td></tr></tbody></table><h4 id="删：-1"><a href="#删：-1" class="headerlink" title="删："></a>删：</h4><table><thead><tr><th>删</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/hashes-hdel.html">HDEL key field1 field2</a></td><td>删除一个或多个key中的字段</td></tr></tbody></table><h4 id="查：-1"><a href="#查：-1" class="headerlink" title="查："></a>查：</h4><table><thead><tr><th>查</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/hashes-hget.html">HGET key field</a></td><td>获取key中的字段field的值</td></tr><tr><td><a href="https://www.runoob.com/redis/hashes-hmget.html">HMGET key field1 field2</a></td><td>获取key中多个字段field的值</td></tr><tr><td><a href="https://www.runoob.com/redis/hashes-hgetall.html">HGETALL key</a></td><td>获取在哈希表中指定 key 的所有字段和值</td></tr><tr><td><a href="https://www.runoob.com/redis/hashes-hkeys.html">HKEYS key</a></td><td>获取所有哈希表中的字段</td></tr><tr><td><a href="https://www.runoob.com/redis/hashes-hvals.html">HVALS key</a></td><td>获取哈希表中所有值</td></tr><tr><td><a href="https://www.runoob.com/redis/hashes-hlen.html">HLEN key</a></td><td>获取哈希表中字段的数量</td></tr><tr><td>[HSCAN key cursor <a href="https://www.runoob.com/redis/hashes-hscan.html">MATCH pattern] [COUNT count]</a></td><td>迭代哈希表中的键值对。pattern是对应field的</td></tr></tbody></table><h4 id="改：-1"><a href="#改：-1" class="headerlink" title="改："></a>改：</h4><table><thead><tr><th>改</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/hashes-hincrby.html">HINCRBY key field increment</a></td><td>为哈希表 key 中的指定字段的整数值加上增量 increment</td></tr><tr><td><a href="https://www.runoob.com/redis/hashes-hincrbyfloat.html">HINCRBYFLOAT key field increment</a></td><td>为哈希表 key 中的指定字段的浮点数值加上增量 increment</td></tr></tbody></table><h3 id="List-列表-："><a href="#List-列表-：" class="headerlink" title="List(列表)："></a>List(列表)：</h3><h4 id="增：-2"><a href="#增：-2" class="headerlink" title="增："></a>增：</h4><table><thead><tr><th>增</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/lists-lpush.html">LPUSH key value1 value2</a></td><td>往队头插入多个值</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-lpushx.html">LPUSHX key value</a></td><td>将一个值插入到已存在的列表头部</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-rpush.html">RPUSH key value1 value2</a></td><td>在列表尾部添加一个或多个值</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-rpushx.html">RPUSHX key value</a></td><td>为已存在的列表添加值</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-linsert.html">LINSERT key BEFORE|AFTER pivot value</a></td><td>在列表中与pivot相等的元素前或者后插入元素</td></tr></tbody></table><h4 id="删：-2"><a href="#删：-2" class="headerlink" title="删："></a>删：</h4><table><thead><tr><th>删</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/lists-lpop.html">LPOP key</a></td><td>移出并获取列表的第一个元素</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-rpop.html">RPOP key</a></td><td>移除列表的最后一个元素，返回值为移除的元素</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-blpop.html">BLPOP key1 key2 timeout</a></td><td>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-brpop.html">BRPOP key1 key2  timeout</a></td><td>同上，不过是移除最后一个元素</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-rpoplpush.html">RPOPLPUSH source destination</a></td><td>移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-brpoplpush.html">BRPOPLPUSH source destination timeout</a></td><td>从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-lrem.html">LREM key count value</a></td><td>移除列表中与value相等的，count绝对值个元素，count大于0表示从对头开始的count个元素，count小于0表示从队尾开始的count个元素，count&#x3D;0则是删除全部相等的</td></tr></tbody></table><h4 id="查：-2"><a href="#查：-2" class="headerlink" title="查："></a>查：</h4><table><thead><tr><th>查</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/lists-lindex.html">LINDEX key index</a></td><td>通过索引获取列表中的元素</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-llen.html">LLEN key</a></td><td>获取列表长度</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-lrange.html">LRANGE key start stop</a></td><td>获取列表指定范围内的元素</td></tr></tbody></table><h4 id="改：-2"><a href="#改：-2" class="headerlink" title="改："></a>改：</h4><table><thead><tr><th>改</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/lists-lset.html">LSET key index value</a></td><td>通过索引设置列表元素的值</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-ltrim.html">LTRIM key start stop</a></td><td>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</td></tr></tbody></table><h3 id="Set-集合-："><a href="#Set-集合-：" class="headerlink" title="Set(集合)："></a>Set(集合)：</h3><h4 id="增：-3"><a href="#增：-3" class="headerlink" title="增："></a>增：</h4><table><thead><tr><th>增</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/sets-sadd.html">SADD key member1 member2</a></td><td>向集合添加一个或多个成员</td></tr></tbody></table><h4 id="删：-3"><a href="#删：-3" class="headerlink" title="删："></a>删：</h4><table><thead><tr><th>删</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/sets-srem.html">SREM key member1 member2</a></td><td>移除集合中一个或多个成员</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-spop.html">SPOP key</a></td><td>移除并返回集合中的一个随机元素</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-smove.html">SMOVE source destination member</a></td><td>将 member 元素从 source 集合移动到 destination 集合</td></tr></tbody></table><h4 id="查：-3"><a href="#查：-3" class="headerlink" title="查："></a>查：</h4><table><thead><tr><th>查</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/sets-scard.html">SCARD key</a></td><td>获取集合的成员数</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-sdiff.html">SDIFF key1 key2</a></td><td>返回第一个集合与其他集合之间的差异</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-sdiffstore.html">SDIFFSTORE destination key1 key2</a></td><td>返回给定所有集合的差集并存储在 destination 中</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-sinter.html">SINTER key1 key2</a></td><td>返回给定所有集合的交集</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-sinterstore.html">SINTERSTORE destination key1 key2</a></td><td>返回给定所有集合的交集并存储在 destination 中</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-sunion.html">SUNION key1 key2</a></td><td>返回所有给定集合的并集</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-sunionstore.html">SUNIONSTORE destination key1 key2</a></td><td>所有给定集合的并集存储在 destination 集合中</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-sismember.html">SISMEMBER key member</a></td><td>判断 member 元素是否是集合 key 的成员</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-smembers.html">SMEMBERS key</a></td><td>返回集合中的所有成员</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-srandmember.html">SRANDMEMBER key count</a></td><td>返回集合中一个或多个随机数</td></tr><tr><td>[SSCAN key cursor <a href="https://www.runoob.com/redis/sets-sscan.html">MATCH pattern] [COUNT count]</a></td><td>迭代集合中的元素</td></tr></tbody></table><h3 id="zset-sorted-set-有序集合-："><a href="#zset-sorted-set-有序集合-：" class="headerlink" title="zset(sorted set:有序集合)："></a>zset(sorted set:有序集合)：</h3><h4 id="增：-4"><a href="#增：-4" class="headerlink" title="增："></a>增：</h4><table><thead><tr><th>增</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zadd.html">ZADD key score1 member1 score2 member2</a></td><td>向有序集合添加一个或多个成员，或者更新已存在成员的分数</td></tr></tbody></table><h4 id="删：-4"><a href="#删：-4" class="headerlink" title="删："></a>删：</h4><table><thead><tr><th>删</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zrem.html">ZREM key member member </a></td><td>移除有序集合中的一个或多个成员</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zremrangebylex.html">ZREMRANGEBYLEX key min max</a></td><td>移除有序集合中给定的字典区间的所有成员</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zremrangebyrank.html">ZREMRANGEBYRANK key start stop</a></td><td>移除有序集合中给定的排名区间的所有成员</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zremrangebyscore.html">ZREMRANGEBYSCORE key min max</a></td><td>移除有序集合中给定的分数区间的所有成员</td></tr></tbody></table><h4 id="查：-4"><a href="#查：-4" class="headerlink" title="查："></a>查：</h4><table><thead><tr><th>查</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zcard.html">ZCARD key</a></td><td>获取有序集合的成员数</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zcount.html">ZCOUNT key min max</a></td><td>计算在有序集合中指定区间分数的成员数</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zlexcount.html">ZLEXCOUNT key min max</a></td><td>在有序集合中计算指定字典区间内成员数量</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zrange.html">ZRANGE key start stop WITHSCORES</a></td><td>通过索引区间返回有序集合指定区间内的成员</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zrevrange.html">ZREVRANGE key start stop WITHSCORES</a></td><td>返回有序集中指定区间内的成员，通过索引，分数从高到低</td></tr><tr><td>[ZRANGEBYSCORE key min max <a href="https://www.runoob.com/redis/sorted-sets-zrangebyscore.html">WITHSCORES] [LIMIT offset count]</a></td><td>通过分数返回有序集合指定区间内的成员</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zrevrangebyscore.html">ZREVRANGEBYSCORE key max min WITHSCORES</a></td><td>返回有序集中指定分数区间内的成员，分数从高到低排序</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zrangebylex.html">ZRANGEBYLEX key min max LIMIT offset count</a></td><td>通过字典区间返回有序集合的成员</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zinterstore.html">ZINTERSTORE destination numkeys key key </a></td><td>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 destination 中</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zunionstore.html">ZUNIONSTORE destination numkeys key key</a></td><td>计算给定的一个或多个有序集的并集，并存储在新的 key 中</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zrank.html">ZRANK key member</a></td><td>返回有序集合中指定成员的索引</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zrevrank.html">ZREVRANK key member</a></td><td>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zscore.html">ZSCORE key member</a></td><td>返回有序集中，成员的分数值</td></tr><tr><td>[ZSCAN key cursor <a href="https://www.runoob.com/redis/sorted-sets-zscan.html">MATCH pattern] [COUNT count]</a></td><td>迭代有序集合中的元素（包括元素成员和元素分值）</td></tr></tbody></table><h4 id="改：-3"><a href="#改：-3" class="headerlink" title="改："></a>改：</h4><table><thead><tr><th>改</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zincrby.html">ZINCRBY key increment member</a></td><td>有序集合中对指定成员的分数加上增量 increment</td></tr></tbody></table><h2 id="基数统计："><a href="#基数统计：" class="headerlink" title="基数统计："></a>基数统计：</h2><blockquote><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p><p>什么是基数?</p><p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p></blockquote><table><thead><tr><th>-</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/hyperloglog-pfadd.html">PFADD key element element</a></td><td>添加指定元素到 HyperLogLog 中</td></tr><tr><td><a href="https://www.runoob.com/redis/hyperloglog-pfcount.html">PFCOUNT key key</a></td><td>返回给定 HyperLogLog 的基数值，如果多个 HyperLogLog 则返回基数估值之和。</td></tr><tr><td><a href="https://www.runoob.com/redis/hyperloglog-pfmerge.html">PFMERGE destkey sourcekey sourcekey </a></td><td>将多个 HyperLogLog 合并为一个 HyperLogLog</td></tr></tbody></table><h2 id="发布订阅："><a href="#发布订阅：" class="headerlink" title="发布订阅："></a>发布订阅：</h2><blockquote><p>Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p></blockquote><table><thead><tr><th>-</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/pub-sub-subscribe.html">SUBSCRIBE channel channel </a></td><td>订阅给定的一个或多个频道的信息。</td></tr><tr><td><a href="https://www.runoob.com/redis/pub-sub-psubscribe.html">PSUBSCRIBE pattern pattern</a></td><td>订阅一个或多个符合给定模式的频道</td></tr><tr><td>[PUNSUBSCRIBE <a href="https://www.runoob.com/redis/pub-sub-punsubscribe.html">pattern [pattern …]]</a></td><td>退订所有给定模式的频道</td></tr><tr><td><a href="https://www.runoob.com/redis/pub-sub-publish.html">PUBLISH channel message</a></td><td>将信息发送到指定的频道</td></tr><tr><td>[UNSUBSCRIBE <a href="https://www.runoob.com/redis/pub-sub-unsubscribe.html">channel [channel …]]</a></td><td>指退订给定的频道</td></tr><tr><td><a href="https://www.runoob.com/redis/pub-sub-pubsub.html">PUBSUB channels pattern</a></td><td>Pattern 有则返回跟pattern相关的，没有则返回全部</td></tr></tbody></table><h2 id="事务："><a href="#事务：" class="headerlink" title="事务："></a>事务：</h2><blockquote><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p><p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p></blockquote><table><thead><tr><th>-</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/transactions-multi.html">MULTI</a></td><td>标记一个事务块的开始。</td></tr><tr><td><a href="https://www.runoob.com/redis/transactions-exec.html">EXEC</a></td><td>执行所有事务块内的命令。</td></tr><tr><td><a href="https://www.runoob.com/redis/transactions-discard.html">DISCARD</a></td><td>取消事务，放弃执行事务块内的所有命令。</td></tr><tr><td><a href="https://www.runoob.com/redis/transactions-watch.html">WATCH key key</a></td><td>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</td></tr><tr><td><a href="https://www.runoob.com/redis/transactions-unwatch.html">UNWATCH</a></td><td>取消 WATCH 命令对所有 key 的监视。</td></tr></tbody></table><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><blockquote><p>Redis Stream 是 Redis 5.0 版本新增加的数据结构。</p><p>Redis Stream 主要用于消息队列（MQ，Message Queue），Redis 本身是有一个 Redis 发布订阅 (pub&#x2F;sub) 来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。</p><p>简单来说发布订阅 (pub&#x2F;sub) 可以分发消息，但无法记录历史消息。</p><p>而 Redis Stream 提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</p></blockquote><table><thead><tr><th>-</th><th>-</th></tr></thead><tbody><tr><td>XADD key ID field value [field value …]</td><td><strong>key</strong> ：队列名称，如果不存在就创建 <strong>ID</strong> ：消息 id，我们使用 * 表示由 redis 生成，可以自定义，但是要自己保证递增性。 <strong>field value</strong> ： 记录。</td></tr><tr><td>XTRIM key MAXLEN</td><td><strong>key</strong> ：队列名称 <strong>MAXLEN</strong> ：长度</td></tr><tr><td>XDEL key ID [ID …]</td><td><strong>key</strong>：队列名称 <strong>ID</strong> ：消息 ID</td></tr><tr><td>XLEN key</td><td>使用 XLEN 获取流包含的元素数量，即消息长度</td></tr><tr><td>XRANGE key start end [COUNT count]</td><td><strong>key</strong> ：队列名 <strong>start</strong> ：开始值， <strong>-</strong> 表示最小值 <strong>end</strong> ：结束值， <strong>+</strong> 表示最大值 <strong>count</strong> ：数量</td></tr><tr><td>XREVRANGE key end start [COUNT count]</td><td><strong>key</strong> ：队列名 <strong>end</strong> ：结束值， <strong>+</strong> 表示最大值 <strong>start</strong> ：开始值， <strong>-</strong> 表示最小值 <strong>count</strong> ：数量</td></tr><tr><td>XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key …] id [id …]</td><td><strong>count</strong> ：数量 <strong>milliseconds</strong> ：可选，阻塞毫秒数，没有设置就是非阻塞模式 <strong>key</strong> ：队列名 <strong>id</strong> ：消息 ID</td></tr><tr><td>XGROUP [CRETE KEY groupname id-or-$]</td><td><strong>key</strong> ：队列名称，如果不存在就创建 <strong>groupname</strong> ：组名。 <strong>$</strong> ： 表示从尾部开始消费，只接受新消息，当前 Stream 消息会全部忽略。</td></tr><tr><td>XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key …] ID [ID …]</td><td><strong>group</strong> ：消费组名 <strong>consumer</strong> ：消费者名。 <strong>count</strong> ： 读取数量。 <strong>milliseconds</strong> ： 阻塞毫秒数。 <strong>key</strong> ： 队列名。 <strong>ID</strong> ： 消息 ID。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>打怪升级</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>⚒认证与授权--cookie|session|token|JWT</title>
    <link href="/2022/07/27/%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/"/>
    <url>/2022/07/27/%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<p>用户认证与授权是一个系统最基本的功能，下面我们一起了解下常见的解决方案的特性与他们相互间的差别，最后是JWT在Go上的使用案例。</p><span id="more"></span><h1 id="😀认证与授权："><a href="#😀认证与授权：" class="headerlink" title="😀认证与授权："></a>😀认证与授权：</h1><blockquote><p>常见的解决方案有cookie、session、token</p><p>在知乎上看到有人用了一个很秒的例子来描述这三个东西👍：在学校或公司，入学入职的那一天，会录入你的身份、账户信息，然后给你发个卡，今后在园区内，你的门禁、打卡、消费都只需要这张卡。</p></blockquote><h2 id="😁Cookie："><a href="#😁Cookie：" class="headerlink" title="😁Cookie："></a>😁Cookie：</h2><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>保存在客户端</li><li>不可跨域，每个Cookie会被绑定在单一域名下，无法在别的域名下使用</li></ul><h3 id="属性（1-⑥）："><a href="#属性（1-⑥）：" class="headerlink" title="属性（1+⑥）："></a>属性（1+⑥）：</h3><ul><li><p><strong>键值对</strong>：在Cookie中设置自定义的值，eg：<code>id=&quot;123456&quot;</code></p></li><li><p><strong>Cookie的域：</strong>在响应首部的Set-Cookie添加domain属性，来控制哪些站点能看到这个Cookie。eg：<code>Set-Cookie: name=&quot;Peng&quot;;domain=&quot;m.zhuanzhuan.58.com&quot;</code>，如果用户访问的是m.zhuanzhuan.58.com，或者m.zhuanzhuan.58.com&#x2F;user 则都可以，而如果是<a href="http://www.aaa.com(非zhuanzhuan.58.com)就不会看到这个cookie./">www.aaa.com(非zhuanzhuan.58.com)就不会看到这个Cookie。</a></p></li><li><p><strong>Cookie的路径Path：</strong>通过添加Path属性可以在特定的路径（这个属性设置的Url和带有这个前缀的Url路径都是有效的）下获得Cookie。</p></li><li><p><strong>Secure：</strong>设置了属性Secure，<code>Set-Cookie: name=&quot;Peng&quot;;domain=&quot;m.zhuanzhuan.58.com&quot;;Secure</code>，则这个Cookie只有在https协议加密的情况下才会发送给客户端</p></li><li><p>**HTTP only:**设置该属性后，则无法通过JS脚本来获得Cookie。</p></li><li><p><strong>Expires：</strong>设置Cookie的过期时间，GMT格式，到达该时间后Cookie会自动失效。</p></li><li><p><strong>max-age：</strong>在HTTP1.1中定义的，优先级高于Expires，表示Cookie的有效期，单位为秒，当值为正数时表示再过去n秒后该Cookie失效，当值为负数时，表示该Cookie为临时Cookie，在浏览器退出后该Cookie则失效，如果值为0则表示取消该Cookie。默认为-1。</p></li></ul><h3 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h3><p><img src="https://pic.rmb.bdstatic.com/bjh/9005b6a0f0e19e96d433046bbf434448.png"></p><ol><li>用户输入用户名，密码（或其它认证方式）到服务器。</li><li>服务器认证成功后，就会利用Set-cookie的头部字段，将Cookie返回给客户端。</li><li>客户端下一次发起请求时，请求首部则会带上这个Cookie</li><li>服务器通过客户端发来的Cookie，便能知道发出该请求的用户，并决定是否通过</li></ol><h2 id="Session-😜"><a href="#Session-😜" class="headerlink" title="Session:😜"></a>Session:😜</h2><blockquote><p>对应于Session就是，其实你的卡上只存了一个id（可能是你的学号），刷的时候物业系统就会去查你的信息、账户，再决定“这个门你能不能进”“这个鸡腿去哪个账户扣钱”</p></blockquote><h3 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h3><ul><li>有重要信息（用户信息，Session状态等）的Session保存在服务器中，而会生成一个SessionId给客户端保存。</li><li>一般基于Cookie实现。</li></ul><h3 id="过程：-1"><a href="#过程：-1" class="headerlink" title="过程："></a>过程：</h3><p><img src="https://pic3.zhimg.com/80/v2-18bd4826103a35c3ef4d99742ad1bd12_1440w.jpg"></p><ol><li>用户输入用户名，密码（或其它认证方式）到服务器。</li><li>服务器认证成功后，在服务器端生成一个Session，保存在文件或者内存或缓存中，然后返回给客户端一个SessionId，SessionId会被客户端保存在Cookie上。</li><li>客户端下一次发起请求时，会自动带上Cookie，Cookie中会携带SessionId。</li><li>服务器接受到Cookie后，检查SessionId的有效性后，决定是否通过。</li></ol><h2 id="😋Token："><a href="#😋Token：" class="headerlink" title="😋Token："></a>😋Token：</h2><blockquote><p>对应于Token就是，在比较早之前，在没有校园卡技术以前，我们都靠学生证。门卫小哥直接对照我和学生证上的脸，确认学生证有效期、年纪等信息，就可以放行了。</p></blockquote><h3 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h3><ul><li>服务器不用再存储信息，减少服务器的压力。</li><li>Token保存在客户端，服务器只需检验Token的有效性</li></ul><h3 id="过程：-2"><a href="#过程：-2" class="headerlink" title="过程："></a>过程：</h3><p><img src="https://pic2.zhimg.com/80/v2-45c53c27a611d78c489a25f3496c7625_1440w.jpg"></p><ol><li>用户输入用户名，密码（或其它认证方式）到服务器。</li><li>服务器认证成功后，在服务器端生成一个Token，这里展示的是通过Cookie传回token,token里面包括了基本的用户信息。</li><li>客户端保存Token后，下次请求时会带上Token</li><li>服务器检验Token的有效性后，决定是否通过。</li></ol><p><strong>考虑到编码，防篡改等问题我们直接讲Token的一个实践JWT（Json Web Token）</strong></p><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT:"></a>JWT:</h2><p><img src="https://pic.rmb.bdstatic.com/bjh/f5b29a28f7c421c77022122c1d291c6c.png" alt="image-20220722172608892"></p><center>一个完整的JWT的结构</center><h3 id="特点：-3"><a href="#特点：-3" class="headerlink" title="特点："></a>特点：</h3><ul><li>继承上面Token的优势，进一步地改善了编码，防篡改的问题。</li></ul><h3 id="三大组成："><a href="#三大组成：" class="headerlink" title="三大组成："></a>三大组成：</h3><p><strong>Header：</strong></p><p>Header主要保存了这个JWT的元数据，主要就是两个部分:<code>alg</code>和<code>typ</code>，<code>alg</code>属性表示签名的算法(algorithm),默认是HMAC SHA256 简写为HS256，<code>typ</code>表示Token的类型，JWT则为JWT。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;alg&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;HS256&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;typ&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;JWT&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>Payload：</strong></p><p>Payload则是存放数据的地方，JWT规定了7个官方字段，供选用。</p><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul><p>我们也可以自己加入一些私有字段。</p><p><strong>这里要注意的是：</strong>虽说我们后面有签名的环节，但那只是为了防止篡改，上面两个部分我们采用的base64UrlEncode编码方法是可以通过防编码出来的，所以重要数据不能放在Payload中。</p><p><strong>Signature:</strong></p><p>在上面Token的部分你可能就有察觉到，我们这次是将用户的信息放在Token里面保存到Cookie中的，这里就存在我们的Token信息被读取，被人用来伪装的可能性，所以就加了签名这一步骤，服务器自己保存了一把密钥，这样就算别人窃取了信息，也无法进行签名，进行伪装。</p><p><strong>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户</strong>。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">HMACSHA256</span>(<br>  base64UrlEncode(header) + &quot;.&quot; +<br>  <span class="hljs-built_in">base64UrlEncode</span>(payload),<br>  secret)<br></code></pre></td></tr></table></figure><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（<code>.</code>）分隔，就可以返回给用户。</p><h3 id="过程：-3"><a href="#过程：-3" class="headerlink" title="过程："></a>过程：</h3><ol><li>用户输入用户名，密码（或其它认证方式）到服务器。</li><li>服务器认证成功后，生成一个JWT，返回给客户端，客户端将会保存JWT。</li><li>客户端下一次发起请求时会带上JWT</li><li>服务器用自己的私钥解析客户端发送过来的JWT，决定是否通过</li></ol><h2 id="JWT在Go中的使用案例："><a href="#JWT在Go中的使用案例：" class="headerlink" title="JWT在Go中的使用案例："></a>JWT在Go中的使用案例：</h2><p>首先go get 一下✨</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> get github.com/dgrijalva/jwt-<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><h3 id="获取JWT："><a href="#获取JWT：" class="headerlink" title="获取JWT："></a>获取JWT：</h3><p>根据前面的讲解，我们已经了解到JWT的数据结构，它就是由两个编码过的json文件加一个签名组成。那我们要做的就是拼装这三个部分。</p><p><strong>Header：</strong></p><p>这个部分包含两个字段，这两个字段都不用我们填，会由你选择的签名算法自动填写好。</p><p><strong>Payload：</strong>（获得Token对象）</p><p>首先我们看下<code>jwt.StandardClaims</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">type</span> StandardClaims <span class="hljs-keyword">struct</span> &#123;<br>Audience  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;aud,omitempty&quot;`</span><br>ExpiresAt <span class="hljs-type">int64</span>  <span class="hljs-string">`json:&quot;exp,omitempty&quot;`</span><br>Id        <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;jti,omitempty&quot;`</span><br>IssuedAt  <span class="hljs-type">int64</span>  <span class="hljs-string">`json:&quot;iat,omitempty&quot;`</span><br>Issuer    <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;iss,omitempty&quot;`</span><br>NotBefore <span class="hljs-type">int64</span>  <span class="hljs-string">`json:&quot;nbf,omitempty&quot;`</span><br>Subject   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;sub,omitempty&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这就是我们上面所说的官方提供的几个可选的字段，在Go中我们使用常用的方法–结构体组合来实现添加我们想要的字段，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Claims <span class="hljs-keyword">struct</span> &#123;<br>UserId <span class="hljs-type">int64</span><br>jwt.StandardClaims<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们把这些字段填充完整，就可以得到Token了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">claims := &amp;Claims&#123;<br>    UserId: user.UserInfoId,<br>    StandardClaims: jwt.StandardClaims&#123;<br>        ExpiresAt: expirationTime.<span class="hljs-built_in">Unix</span>(),<br>        IssuedAt:  time.<span class="hljs-built_in">Now</span>().<span class="hljs-built_in">Unix</span>(),<br>        Issuer:    <span class="hljs-string">&quot;douyin_pro_131&quot;</span>,<br>        Subject:   <span class="hljs-string">&quot;L_B__&quot;</span>,<br>    &#125;&#125;<br>token := jwt.<span class="hljs-built_in">NewWithClaims</span>(jwt.SigningMethodHS256, claims)<br><br></code></pre></td></tr></table></figure><p><strong>Signature:</strong></p><p>上面获得Token对象后，调用<code>jwt.SignedString()</code>，并传入自己服务器保存的密钥（一个 <code>byte[]</code>），就会自动完成Signature部分的编写和对上面三个部分分别进行base64url编码，再整合成一个最终的字符串返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">jwtKey:=[]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;我的密钥&quot;</span>)<br>tokenString,err:=token.SignedString(jwtKey)<br></code></pre></td></tr></table></figure><h3 id="验证JWT："><a href="#验证JWT：" class="headerlink" title="验证JWT："></a>验证JWT：</h3><p>以常用的Web框架Gin为例，我们会把这个部分放到中间件那里使用。</p><p>解析Token：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParseToken</span><span class="hljs-params">(tokenString <span class="hljs-type">string</span>)</span></span> (*MyClaims, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 验证token是否是我们自己签发的</span><br>token, err := jwt.ParseWithClaims(tokenString, &amp;MyClaims&#123;&#125;, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(token *jwt.Token)</span></span> (i <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> jwtKey, <span class="hljs-literal">nil</span><br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> claims, ok := token.Claims.(*MyClaims); ok &amp;&amp; token.Valid &#123; <span class="hljs-comment">// 校验token</span><br><span class="hljs-keyword">return</span> claims, <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;invalid token&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>用于中间件中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">JWTAuthMiddleware</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">// 客户端携带Token有三种方式 1.放在请求头 2.放在请求体 3.放在URI</span><br><span class="hljs-comment">// 这里假设Token放在Header的Authorization中，并使用Bearer开头</span><br><span class="hljs-comment">// 这里的具体实现方式要依据你的实际业务情况决定</span><br>authHeader := c.Query(<span class="hljs-string">&quot;token&quot;</span>)<br>fmt.Println(authHeader)<br><span class="hljs-keyword">if</span> authHeader == <span class="hljs-string">&quot;&quot;</span> &#123;<br>authHeader = c.PostForm(<span class="hljs-string">&quot;token&quot;</span>)<br>fmt.Println(authHeader)<br>&#125;<br><br><span class="hljs-keyword">if</span> authHeader == <span class="hljs-string">&quot; &quot;</span> &#123;<br>c.JSON(http.StatusOK, service.UserResponse&#123;<br>Response: service.Response&#123;StatusCode: <span class="hljs-number">1</span>&#125;,<br>&#125;)<br>c.Abort()<br><span class="hljs-keyword">return</span><br>&#125;<br><br>mc, err := app.ParseToken(authHeader)  <span class="hljs-comment">//就是调用上面的ParseToken</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>c.JSON(http.StatusOK, service.UserResponse&#123;<br>Response: service.Response&#123;StatusCode: <span class="hljs-number">1</span>&#125;,<br>&#125;)<br>c.Abort()<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(mc.UserId)<br><span class="hljs-comment">// 将当前请求的username信息保存到请求的上下文c上</span><br>c.Set(<span class="hljs-string">&quot;user_id&quot;</span>, mc.UserId)<br>c.Next() <span class="hljs-comment">// 后续的处理函数可以用过c.Get(&quot;user_id&quot;)来获取当前请求的用户信息</span><br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="JWT的一些问题："><a href="#JWT的一些问题：" class="headerlink" title="JWT的一些问题："></a>JWT的一些问题：</h3><ol><li><p>JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p></li><li><p>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p></li><li><p>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>常用中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>认证与授权</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搞定Docker--快速入门</title>
    <link href="/2022/07/19/Docker%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/19/Docker%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="🎉Docker🎉"><a href="#🎉Docker🎉" class="headerlink" title="🎉Docker🎉"></a>🎉Docker🎉</h1><p>之前老是听别人讲docker部署的各种优点，但之前单单就感觉确实挺好的，没去深入学习，这段时间有空所以打算把这把利器给捡起来！</p><span id="more"></span><blockquote><p>容器：操作系统级别的虚拟化技术。</p></blockquote><p>简史：前面是dotCloud，用了linux的容器化技术，中途发现活不下去了，就变成开源的了，活了之后就改名为docker了，后面为了进一步优化，投入了Go的怀抱，用了Go构建的引擎。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros">复习一点新虚拟机配网络的知识：<br><br>vim /etc/sysconfig/network-scripts/ifcfg-ens32 (32,也可能是33)<br><br>修改的参数：<br><span class="hljs-attribute">BOOTPROTO</span>=dhcp  (使用动态IP还是静态IP，dhcp改为static 动态改为静态)<br><span class="hljs-attribute">ONBOOT</span>=<span class="hljs-literal">no</span> (<span class="hljs-literal">no</span>改为<span class="hljs-literal">yes</span> 开机自启)<br><span class="hljs-attribute">IPADDR</span>=192.168.91.100 (IP地址，从VMware的虚拟网络设置里看)<br><span class="hljs-attribute">NETMASK</span>=255.255.255.0 (子网掩码)<br><span class="hljs-attribute">GATEWAY</span>=192.168.91.2 (网关，默认就是 IP地址 .2 )<br><span class="hljs-attribute">DNS1</span>=192.168.91.2 (自己的网关)<br><span class="hljs-attribute">DNS2</span>=144.144.144.44 (中国移动，联通 通用的 144.144.144.144)<br><span class="hljs-attribute">DNS3</span>=8.8.8.8(全球通用的,Google的)<br><br></code></pre></td></tr></table></figure><h2 id="🎖安装："><a href="#🎖安装：" class="headerlink" title="🎖安装："></a>🎖安装：</h2><ol><li><p><code>sudo yum install -y yum-utils </code>: 安装yum-utils这个包，我们才可以用它里面的工具:<code>yum-config-manager</code>来指定下载源</p></li><li><p><code>sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code>：设置为阿里的下载源</p></li><li><p><code> sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</code>  docker-ce ：docker引擎社区版、docker-ce-cli：docker引擎命令行界面 containerd.io：守护进程</p></li><li><p><code>docker -v</code>：查看版本，看是否成功。</p></li><li><p><code>docker run hello-world</code>:测试能否正常使用</p></li><li><p>配置镜像加速：1.<code>vim /etc/docker/daemon.json</code> </p><ol start="2"><li><p>添加到里面</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>启用配置、重启docker</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nsis">sudo <span class="hljs-params">system</span>ctl daemon-reload<br>sudo <span class="hljs-params">system</span>ctl restart docker<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="😱Docker-架构及工作原理："><a href="#😱Docker-架构及工作原理：" class="headerlink" title="😱Docker 架构及工作原理："></a>😱Docker 架构及工作原理：</h2><p>三个东西:</p><ul><li>Client：<strong>宿主机</strong>的命令行界面</li><li>Docker_Host：Docker引擎<ul><li>Docker daemon：<strong>守护进程</strong>，就像一个中枢一样，Client的命令发到这里，并由它来进行相应的操作，比如从远程仓库（Registry）拉取镜像，将拉取的镜像生成容器</li><li>images：镜像（模板，类似语言中的一个类）</li><li>Containers：容器 （真正工作的玩意，类似用上面的类创建的一个对象）</li></ul></li><li>Registry：远程仓库</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5un93x8qfj20hz0a4q3x.jpg"></p><h3 id="Client客户端："><a href="#Client客户端：" class="headerlink" title="Client客户端："></a>Client客户端：</h3><h3 id="镜像分层："><a href="#镜像分层：" class="headerlink" title="镜像分层："></a>镜像分层：</h3><p><img src="http://i2.51cto.com/images/blog/201711/27/462718f3cd35608c20481b33b09db020.jpg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="Docker镜像的内部结构(四)"></p><p>在使用docker后，我们会拉取很多很多的镜像到本地，为了防止拉取的镜像互相间存在冗余的数据（比如Nginx和Redis都需要安装C++环境，如果拉取镜像的时候都拉取了一个，这部分相同的C++环境就是冗余的数据了，更深入些，每个镜像依赖的最基础的Linux环境也会成为冗余数据的一部分)，所以Docker采用了镜像分层的技术，也就是将最基础的Linux环境做为Base镜像，后面最终我们所使用的镜像（Nginx、Redis等等）都是在这个Base镜像的基础上，堆上一层层其它的镜像构成的，如果不同的镜像有利用到相同的部分，则不会重复拉取，而是直接复用。</p><h3 id="Volume-数据卷："><a href="#Volume-数据卷：" class="headerlink" title="Volume 数据卷："></a>Volume 数据卷：</h3><p>使容器与宿主机建立映射关系，把容器里的数据映射到宿主机上，在创建容器的时候可以指定数据卷，如果不指定，则数据还是只保存在容器中。</p><h3 id="Registry"><a href="#Registry" class="headerlink" title="Registry:"></a>Registry:</h3><p><a href="hub.docker.com">官方镜像仓库</a> 需要联网，而且上传后别人也能看到</p><p>所以docker 提供了 registry 镜像，可供我们在局域网内搭建仓库，也可以设置身份认证等等</p><h2 id="💘Docker-常用命令："><a href="#💘Docker-常用命令：" class="headerlink" title="💘Docker 常用命令："></a>💘Docker 常用命令：</h2><h3 id="镜像相关命令："><a href="#镜像相关命令：" class="headerlink" title="镜像相关命令："></a>镜像相关命令：</h3><h4 id="1-查看镜像："><a href="#1-查看镜像：" class="headerlink" title="1.查看镜像："></a>1.查看镜像：</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">docker images<br><br></code></pre></td></tr></table></figure><ul><li><code>Repository</code>:仓库名称</li></ul><h4 id="2-搜索镜像："><a href="#2-搜索镜像：" class="headerlink" title="2.搜索镜像："></a>2.搜索镜像：</h4><p>如果需要从网络中查找需要的镜像，可以通过以下命令查看是否存在</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">docker search 镜像名<br></code></pre></td></tr></table></figure><h4 id="3-拉取镜像："><a href="#3-拉取镜像：" class="headerlink" title="3.拉取镜像："></a>3.拉取镜像：</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http">docker pull 镜像名<br><br>也可以指定标签：docker pull redis:5 (例子)<br></code></pre></td></tr></table></figure><h4 id="4-删除镜像："><a href="#4-删除镜像：" class="headerlink" title="4.删除镜像："></a>4.删除镜像：</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">docker rmi 镜像名<br>也可以指定标签：docker rmi redis:5 (例子)<br></code></pre></td></tr></table></figure><h3 id="容器命令："><a href="#容器命令：" class="headerlink" title="容器命令："></a>容器命令：</h3><h4 id="1-查看命令："><a href="#1-查看命令：" class="headerlink" title="1.查看命令："></a>1.查看命令：</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http">docker ps  查看运行的容器<br>docker ps -a 查看所有的容器<br>docker ps -l 查看最后创建的容器<br>docker ps -l -n 最后几个容器<br>docker ps -f status:exited  过滤查询<br>不知道怎么操作就可以加 --help来获得帮助<br></code></pre></td></tr></table></figure><h4 id="2-创建与启动："><a href="#2-创建与启动：" class="headerlink" title="2.创建与启动："></a>2.创建与启动：</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs http">docker run 镜像名  创建容器<br>参数：<br>--name: 指定创建的容器名<br>-p:指定端口  （宿主机端口：容器端口）<br>-P：自动指定<br>-i: 运行容器<br>-t:表示容器启动后会进入其命令行界面<br>-v:可以指定目录映射关系，可以用多个-v 映射多个目录<br>-it：启动并进入，有些容器创建后不会进入，就可以这样启动后并进入<br></code></pre></td></tr></table></figure><h4 id="3-守护进程进入"><a href="#3-守护进程进入" class="headerlink" title="3.守护进程进入"></a>3.守护进程进入</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">docker run -di 镜像名<br>docker exec -it [自己取的镜像名，容器ID]  进入容器<br></code></pre></td></tr></table></figure><h4 id="4-停止启动容器"><a href="#4-停止启动容器" class="headerlink" title="4.停止启动容器"></a>4.停止启动容器</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">docker stop 容器名<br>docker start 容器名<br></code></pre></td></tr></table></figure><h4 id="5-文件拷贝："><a href="#5-文件拷贝：" class="headerlink" title="5.文件拷贝："></a>5.文件拷贝：</h4><p>可以把宿主机的拷贝到容器，也可以把容器的拷贝到宿主机</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">docker cp 需要拷贝的文件或目录 容器名称:容器目录<br>docker cp 容器名称:容器目录或文件 拷贝到宿的主机的位置<br></code></pre></td></tr></table></figure><h4 id="6-目录挂载："><a href="#6-目录挂载：" class="headerlink" title="6.目录挂载："></a>6.目录挂载：</h4><p>如果不挂载，当容器被删除后，数据也就被删除了，挂载后，宿主机的数据则还在</p><ol><li><p>指定目录挂载：<code>docker run -di -v 宿主机位置:容器目录 镜像名称</code>，docker会自动创建相应的容器目录，如果没在创建容器时挂载，后面想挂载可以通过修改配置文件来实现。</p><p><code>docker inspect 容器名 </code>可以查看所有的详细信息。</p></li><li><p>匿名挂载：<code>docker run -di -v 容器目录 镜像名称</code>,匿名挂载我们不用指定宿主机的位置，统一会被放到 <code>/var/lib/docker/volumes</code> 中，它会自动生成一个随机名称的目录，如果匿名挂载过多时，可以通过<code>docker inspect 容器名</code>来查看被挂载时随机生成的名字。</p></li><li><p>具名挂载：<code>docker run -di -v 宿主机中的目录名字:容器目录 镜像名称</code>,和上面一样会被放到<code>/var/lib/docker/volumes</code>中，不过这次可以指定名字</p></li><li><p>设置权限（只读&#x2F;读写，有时我们不希望容器在内部操作，就只允许宿主机操作，就可以挂只读），<code>docker run -di -v 容器目录:ro/rw 镜像名称</code> 只读&#x2F;读写</p></li><li><p>继承：<code>--volumes-from 被继承的容器名:ro/rw</code>，可以继承之前容器挂载的目录</p></li><li><p>查看容器ip地址：<code>docker inspect 容器名称</code></p></li><li><p>删除容器：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">docker rm 容器名称|容器ID<br>docker rm 容器名称|容器ID 容器名称|容器ID 容器名称|容器ID<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>打怪升级</category>
      
      <category>搞定docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The First Blog</title>
    <link href="/2022/06/28/The-First-Blog/"/>
    <url>/2022/06/28/The-First-Blog/</url>
    
    <content type="html"><![CDATA[<h1 id="😍全军出击🎉"><a href="#😍全军出击🎉" class="headerlink" title="😍全军出击🎉"></a>😍全军出击🎉</h1><h2 id="革命尚未成功，还需继续努力🎖"><a href="#革命尚未成功，还需继续努力🎖" class="headerlink" title="革命尚未成功，还需继续努力🎖"></a>革命尚未成功，还需继续努力🎖</h2>]]></content>
    
    
    <categories>
      
      <category>陈词滥调</category>
      
      <category>第一篇博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FirstBlog</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
