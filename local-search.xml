<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>🖥️如何选屏幕？</title>
    <link href="/2022/10/29/%E5%A6%82%E4%BD%95%E9%80%89%E5%B1%8F%E5%B9%95%EF%BC%9F/"/>
    <url>/2022/10/29/%E5%A6%82%E4%BD%95%E9%80%89%E5%B1%8F%E5%B9%95%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="🖥️如何选屏幕？"><a href="#🖥️如何选屏幕？" class="headerlink" title="🖥️如何选屏幕？"></a>🖥️如何选屏幕？</h1><blockquote><p>一块好的屏幕，可以让我们的体验提高很多档次，但是现在市面上的显示器都太鱼龙混杂了，在不做点功课的情况下要选一块好屏幕还是挺难的。</p><p>按照先看评测的科普做了这样一篇笔记。</p></blockquote><h2 id="尺寸大还是分辨率高："><a href="#尺寸大还是分辨率高：" class="headerlink" title="尺寸大还是分辨率高："></a>尺寸大还是分辨率高：</h2><h3 id="预算有限的情况下优先尺寸还是分辨率："><a href="#预算有限的情况下优先尺寸还是分辨率：" class="headerlink" title="预算有限的情况下优先尺寸还是分辨率："></a>预算有限的情况下优先尺寸还是分辨率：</h3><ol><li><p>尺寸大显示范围肯定大些，但在相同分辨率下，其实他们显示的内容是一样的，图标和文字只是等比放大，总结：<strong>只有尺寸增加的同时，物理像素也相应增加，也就是分辨率也提高，才能显示更多的内容。</strong></p><p>这里有一个注意的点是：有可能分辨率较高，而尺寸不够大，如果按照正常分辨率显示来显示内容，那内容就会显地太小，所以系统就会默认地为文字和内容等比放大，这样虽然显示的内容没有之前多，但是高分辨率还是有优势的，也就是它能显示地更细捏些。何为细腻：</p><p><img src="https://img.tucang.cc/api/image/show/f7f11f6b5535f16136f0d8f85206c912"></p></li></ol><h3 id="细腻："><a href="#细腻：" class="headerlink" title="细腻："></a>细腻：</h3><p>上面我们提到了细腻一词。<strong>一款好的屏幕就是应该让我们在合适的区域下看不到像素点</strong>，</p><p>常见分辨率下得离多远才能不看到像素点如下图，<strong>越远越不好</strong></p><p><img src="https://img.tucang.cc/api/image/show/08655f02ea7112d0b19e515ecd29bb3b"></p><p>下面是相应的分辨率下会超出舒适范围界限（一般人不会离屏幕超过75cm）的尺寸（也就是如果要买这个分辨率，那这些尺寸就不合适了，因为在正常使用下能看到屏幕像素点）：</p><ul><li><p><strong>1080P:</strong>  24、27、32的都超出了，但是要注意从上图可以看出，24寸和27寸的舒适范围界线其实差不多，但是却多了很大的范围，所以1080P，24和27, 27会更值些</p></li><li><p><strong>2K</strong>：24和27刚好可以卡在舒适范围内</p></li><li><p><strong>4K：</strong>即使是32寸也能保证在舒适范围内</p></li></ul><h2 id="屏幕贵还贵在哪？"><a href="#屏幕贵还贵在哪？" class="headerlink" title="屏幕贵还贵在哪？"></a>屏幕贵还贵在哪？</h2><blockquote><p>要看屏幕贵在哪就看那些贵的屏幕在吹什么？</p><p>总结就是6点：亮度、对比度、可视角度、色深、色准以及HDR或者更亲民的低蓝光</p></blockquote><h3 id="亮度（nit）、对比度（-xxx-1）："><a href="#亮度（nit）、对比度（-xxx-1）：" class="headerlink" title="亮度（nit）、对比度（ xxx :1）："></a>亮度（nit）、对比度（ xxx :1）：</h3><p>这里就有两个坑了，对于亮度，有些屏幕标称有多少多少nit，但真实却没有。</p><p>200nit的概念：把屏幕放在窗户边可能就看不清了。</p><p>对于对比度：低对比度，看起来就像屏幕蒙上了一层灰</p><p><strong>问题出在了哪？ **  驱动板，更细点说是HDMI插口。当我们用HDMI插口时，驱动板就会告诉电脑「我是台电视」，识别成电视会有什么问题呢，我们简单的知道就是为了防止电视信号在传输转换过程中后出现白燥点所以会给砍掉一些信号，再通过拉伸去补全，这样造成的直接结果就是亮度和对比度不准了。解决办法其实加一个DP口就解决了，因为DP协议定制的比较晚，所以不用去考虑兼容电视，也就不会出现上述问题。</strong>不过，有一些好的厂商，驱动写的较好，即使用HDMI也没问题**</p><h3 id="五彩斑斓的白："><a href="#五彩斑斓的白：" class="headerlink" title="五彩斑斓的白："></a>五彩斑斓的白：</h3><p>不好的显示器对白会出现不同的奇怪现象：有的发白、有的发黄、有的发蓝</p><ol><li><p>显示器得调下色温模式</p></li><li><p>即使调到最标准的色温模式，但是其实调完后的真实色温还是和设置的参数色温不一样</p><p>原因是：<strong>背光模组</strong></p><p>面板厂商，背光模组一般是和液晶面板打包一起出售的，也就是原厂背光，这些采用原厂背光的显示器一般就没问题，而有一些低价显示器的厂商为了降低成本，只会用前面的液晶面板，后面的背光模组买自其它的第三方，也就是组装背光，所以这种显示器就较大可能出现白得不平衡的情况。</p></li></ol><h3 id="可视角度："><a href="#可视角度：" class="headerlink" title="可视角度："></a>可视角度：</h3><p>厂家都会标称 178°，但是其实不同机型在偏转的角度下在对比度下降（人眼感知明显）、白色偏差和色彩劣化这几个方面都会有点不同。（白色偏差和色彩劣化要控制在1以内较好）</p><p>但是一般这些参数不会在页面直接看到。所以一般是<strong>先认准IPS，然后再看怎么搞到上面这几个参数。</strong></p><h3 id="闪烁："><a href="#闪烁：" class="headerlink" title="闪烁："></a>闪烁：</h3><blockquote><p>商品页面里还会经常提到另一个词 「bit」</p><p>bit的多少就像我们水彩笔套装里水彩笔颜色的多少</p></blockquote><p><img src="https://img.tucang.cc/api/image/show/40e485f15cb11d85b1bd919f9ab75aed"></p><p>如果用这些色彩笔画彩虹，那么在不同颜色之间的过渡就是「色阶」</p><p>如果颜色更多，也就是bit更好，那么这道彩虹的色阶就更不明显。</p><p><img src="https://img.tucang.cc/api/image/show/d9f5cc235e54c72f3a0a24f234d657f8"></p><p>但是其实在市面的屏幕真实情况没有上面那张图那么明显。原因是这些6bit的显示器通过了一种算法实现了近似8bit的显示效果。而正因为这样，对于我们用户可能遇到的情况就是观察到闪烁现象。所以咱们尽量别买6bit的。<strong>但是这里又有一个坑，也就是上面说的，可以通过算法来将6bit升级到8bit，所以厂家都把这些假8bit标为6bit</strong>，</p><p><strong>所以真正的8bit显示器现在只能都宣传为10bit</strong></p><h3 id="低蓝光"><a href="#低蓝光" class="headerlink" title="低蓝光"></a>低蓝光</h3><p>实际就是将蓝光的光谱降低了，但蓝光降低了，屏幕就会发黄</p><p>而且，其实所有的显示器都能做到这一点，所以不用纠结一个显示器有没有低蓝光。</p><h3 id="色准："><a href="#色准：" class="headerlink" title="色准："></a><strong>色准：</strong></h3><p>真实的颜色和标准颜色的偏移值会用ΔE表示，如果想买色准较好的那肯定是ΔE越小越好</p><h3 id="广色域："><a href="#广色域：" class="headerlink" title="广色域："></a>广色域：</h3><p>看显示面积对SRGB的覆盖率即可。</p><p>但是行业发展到今天，现在的屏幕对SRGB一般都是超覆盖的，</p><p><img src="https://img.tucang.cc/api/image/show/8e43a3d5f8ced2a90c2cb019ecb16778"></p><p>所以这些过饱和的显示器需要对这些超过sRGB的色域进行「限缩」。</p><p>也就是这样</p><p><img src="https://img.tucang.cc/api/image/show/046925815431b446e8f06e21e4b084d9"></p><p>所以看显示器广色域好不好，就是看他有没有色域限缩，没有色域限缩就会过饱和，就会不准，然后有色域收缩还不行，还要看它的限缩后保留的好不好，去掉了太多就与完整的色域差太多了。</p>]]></content>
    
    
    <categories>
      
      <category>陈词滥调</category>
      
      <category>如何选一块屏幕</category>
      
    </categories>
    
    
    <tags>
      
      <tag>选屏幕</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>🏓打造Go的武器--Gin🏓</title>
    <link href="/2022/10/17/%E6%89%93%E9%80%A0Go%E7%9A%84%E6%AD%A6%E5%99%A8--Gin/"/>
    <url>/2022/10/17/%E6%89%93%E9%80%A0Go%E7%9A%84%E6%AD%A6%E5%99%A8--Gin/</url>
    
    <content type="html"><![CDATA[<p>Gin是Go中效率非常高的一个WEB框架，并且它的路由分组、中间件等提供了很高的易用性和灵活性，让我们一起一探究竟吧。</p><span id="more"></span><h1 id="🏓打造Go的武器–Gin🏓"><a href="#🏓打造Go的武器–Gin🏓" class="headerlink" title="🏓打造Go的武器–Gin🏓"></a>🏓打造Go的武器–Gin🏓</h1><p><img src="https://img.tucang.cc/api/image/show/2094cb91c9988d03efa9643dd39f89b6"></p><h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><blockquote><p>Gin 是一个用 Go编写的 Web 框架。 它具有类似martini的API，但性能要好得多，多亏了 <a href="https://github.com/julienschmidt/httprouter">httprouter</a>。速度提高了 40 倍。它的特性如下：</p></blockquote><p><strong>快速</strong></p><p>基于 Radix 树（基数树，或称压缩前缀树）的路由，小内存占用。没有反射。<strong>可预测的 API 性能</strong>。</p><p><strong>支持中间件</strong></p><p>传入的 HTTP 请求可以由一系列中间件和最终操作来处理。 例如：Logger，Authorization，GZIP，最终操作 DB。</p><p><strong>Crash 处理</strong></p><p>Gin 可以 catch 一个发生在 HTTP 请求中的 panic 并 recover 它。这样，你的服务器将始终可用。例如，你可以向 Sentry 报告这个 panic！</p><p><strong>JSON 验证</strong></p><p>Gin 可以解析并验证请求的 JSON，例如检查所需值的存在。</p><p><strong>路由组</strong></p><p>更好地组织路由。是否需要授权，不同的 API 版本…… 此外，这些组可以无限制地嵌套而不会降低性能。</p><p><strong>错误管理</strong></p><p>Gin 提供了一种方便的方法来收集 HTTP 请求期间发生的所有错误。最终，中间件可以将它们写入日志文件，数据库并通过网络发送。</p><p><strong>内置渲染</strong></p><p>Gin 为 JSON，XML 和 HTML 渲染提供了易于使用的 API。</p><p><strong>可扩展性</strong></p><p>新建一个中间件非常简单。</p><blockquote><p>本篇文章介绍了一些常用的方法，更为全面的example可以看官方的example<a href="https://github.com/gin-gonic/gin#api-examples">Gin Api Example</a></p></blockquote><h2 id="目录结构："><a href="#目录结构：" class="headerlink" title="目录结构："></a>目录结构：</h2><p>按照我们其他的同类型教程这里就是快速使用了，但是这里我觉得得再加目录结构这一项内容，在使用框架构建应用之前定好我们的目录结构可以保证我们后面整个程序的易维护性、易读性和可拓展性。</p><p>一个好的目录结构至少要满足以下几个要求：</p><ul><li><strong>命名清晰</strong>：目录命名要清晰、简洁，不要太长，也不要太短，目录名要能清晰地表达出该目录实现的功能，并且目录名最好用单数。一方面是因为单数足以说明这个目录的功能，另一方面可以统一规范，避免单复混用的情况。</li><li><strong>功能明确</strong>：一个目录所要实现的功能应该是明确的、并且在整个项目目录中具有很高的辨识度。也就是说，当需要新增一个功能时，我们能够非常清楚地知道把这个功能放在哪个目录下。</li><li><strong>全面性</strong>：目录结构应该尽可能全面地包含研发过程中需要的功能，例如文档、脚本、源码管理、API 实现、工具、第三方包、测试、编译产物等。</li><li><strong>可预测性</strong>：项目规模一定是从小到大的，所以一个好的目录结构应该能够在项目变大时，仍然保持之前的目录结构。</li><li><strong>可扩展性</strong>：每个目录下存放了同类的功能，在项目变大时，这些目录应该可以存放更多同类功能。</li></ul><p>一个 Go 项目包含 3 大部分：Go 应用 、项目管理和文档。所以，我们的项目目录也可以分为这 3 大类。同时，Go 应用又贯穿开发阶段、测试阶段和部署阶段，相应的应用类的目录，又可以按开发流程分为更小的子类。我们这里主要是先讲Go应用这一模块，后面有机会再专门出文章讲讲另外两类。</p><p>我们先大致看一下建议的目录长啥样：</p><p><img src="https://img.tucang.cc/api/image/show/08eb7e0392cff4af2566e7fb1f465ebc"></p><ol><li>&#x2F;web</li></ol><p>前端代码存放目录，主要用来存放Web静态资源，服务端模板和单页应用（SPAs）。</p><ol start="2"><li>&#x2F;cmd</li></ol><p>一个项目有很多组件，可以把组件 main 函数所在的文件夹统一放在<code>/cmd</code> 目录下，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> cmd/</span><br>gendocs  geniamdocs  genman  genswaggertypedocs  genyaml  iam-apiserver  iam-authz-server  iamctl  iam-pump<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> cmd/iam-apiserver/</span><br>apiserver.go<br></code></pre></td></tr></table></figure><p>每个组件的目录名应该跟你期望的可执行文件名是一致的。这里要保证 <code>/cmd/&lt;组件名&gt;</code> 目录下不要存放太多的代码，如果你认为代码可以导入并在其他项目中使用，那么它应该位于 &#x2F;pkg 目录中。如果代码不是可重用的，或者你不希望其他人重用它，请将该代码放到 &#x2F;internal 目录中。</p><ol start="3"><li>&#x2F;internal</li></ol><p>存放<strong>私有应用</strong>和库代码。如果一些代码，你不希望在其他应用和库中被导入，可以将这部分代码放在<code>/internal</code> 目录下。</p><p>&#x2F;internal 目录大概分为 3 类子目录：</p><ul><li>&#x2F;internal&#x2F;pkg：内部共享包存放的目录。</li><li>&#x2F;internal&#x2F;authzserver、&#x2F;internal&#x2F;apiserver、&#x2F;internal&#x2F;pump、&#x2F;internal&#x2F;apiserver：应用目录，里面包含应用程序的实现代码。</li><li>&#x2F;internal&#x2F;iamctl：对于一些大型项目，可能还会需要一个客户端工具。</li></ul><p>在每个应用程序内部，也会有一些目录结构，这些目录结构主要根据功能来划分：</p><p>我们以一个处理路由逻辑的目录为例，吸取点经验</p><ul><li>&#x2F;internal&#x2F;apiserver&#x2F;api&#x2F;v1：HTTP API 接口的具体实现，主要用来做 HTTP 请求的解包、参数校验、业务逻辑处理、返回。注意这里的业务逻辑处理应该是轻量级的，如果业务逻辑比较复杂，代码量比较多，建议放到 &#x2F;internal&#x2F;apiserver&#x2F;service 目录下。该源码文件主要用来串流程。</li><li>&#x2F;internal&#x2F;apiserver&#x2F;options：应用的 command flag。</li><li>&#x2F;internal&#x2F;apiserver&#x2F;config：根据命令行参数创建应用配置。</li><li>&#x2F;internal&#x2F;apiserver&#x2F;service：存放应用复杂业务处理代码。</li><li>&#x2F;internal&#x2F;apiserver&#x2F;store&#x2F;mysql：一个应用可能要持久化的存储一些数据，这里主要存放跟数据库交互的代码，比如 Create、Update、Delete、Get、List 等。</li></ul><p>&#x2F;internal&#x2F;pkg 目录存放项目内可共享的包，通常可以包含如下目录：</p><ul><li>&#x2F;internal&#x2F;pkg&#x2F;code：项目业务 Code 码。</li><li>&#x2F;internal&#x2F;pkg&#x2F;validation：一些通用的验证函数。</li><li>&#x2F;internal&#x2F;pkg&#x2F;middleware：HTTP 处理链。</li></ul><ol start="4"><li>&#x2F;pkg</li></ol><p>&#x2F;pkg 目录是 Go 语言项目中非常常见的目录，我们几乎能够在所有知名的开源项目（非框架）中找到它的身影，例如 Kubernetes、Prometheus、Moby、Knative 等。</p><p>该目录中存放可以被外部应用使用的代码库，其他项目可以直接通过 import 导入这里的代码。所以，我们在将代码库放入该目录时一定要慎重。</p><ol start="5"><li>&#x2F;vendor</li></ol><p>项目依赖，可通过 go mod vendor 创建。需要注意的是，如果是一个 Go 库，不要提交 vendor 依赖包。</p><ol start="6"><li>&#x2F;third_party</li></ol><p>外部帮助工具，分支代码或其他第三方应用（例如Swagger UI）</p><ol start="7"><li>&#x2F;test</li></ol><p>用于存放其他外部测试应用和测试数据。&#x2F;test 目录的构建方式比较灵活：对于大的项目，有一个数据子目录是有意义的。例如，如果需要 Go 忽略该目录中的内容，可以使用&#x2F;test&#x2F;data 或&#x2F;test&#x2F;testdata 目录。</p><p>需要注意的是，<strong>Go 也会忽略以“.”或 “_” 开头的目录或文件。</strong>这样在命名测试数据目录方面，可以具有更大的灵活性。</p><ol start="8"><li>&#x2F;configs</li></ol><p>这个目录用来配置文件模板或默认配置。这里有一点要注意，配置中不能携带敏感信息，这些敏感信息，我们可以用占位符来替代，例如：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">apiVersion:</span> v1    <br><span class="hljs-symbol">user:</span>    <br><span class="hljs-symbol">  username:</span> $<span class="hljs-punctuation">&#123;</span>CONFIG_USER_USERNAME<span class="hljs-punctuation">&#125;</span> <span class="hljs-meta"># iam 用户名    </span><br><span class="hljs-symbol">  password:</span> $<span class="hljs-punctuation">&#123;</span>CONFIG_USER_PASSWORD<span class="hljs-punctuation">&#125;</span> <span class="hljs-meta"># iam 密码</span><br></code></pre></td></tr></table></figure><ol start="9"><li>&#x2F;deployments</li></ol><p>用来存放 Iaas、PaaS 系统和容器编排部署配置和模板（Docker-Compose，Kubernetes&#x2F;Helm，Mesos，Terraform，Bosh）。在一些项目，特别是用 Kubernetes 部署的项目中，这个目录可能命名为 deploy。</p><ol start="10"><li>&#x2F;init</li></ol><p>存放初始化系统（systemd，upstart，sysv）和进程管理配置文件（runit，supervisord）</p><h2 id="快速使用："><a href="#快速使用：" class="headerlink" title="快速使用："></a>快速使用：</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-comment">// 导入gin包</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><br><span class="hljs-comment">// 入口函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 初始化一个http服务对象</span><br>r := gin.Default()<br>  <span class="hljs-comment">// 设置运行模式</span><br>  gin.SetMode(<span class="hljs-string">&quot;debug&quot;</span>)<br>    <span class="hljs-comment">// 设置一个get请求的路由，url为/ping, 处理函数（或者叫控制器函数）是一个闭包函数。</span><br>r.GET(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>    <span class="hljs-comment">// 通过请求上下文对象Context, 直接往客户端返回一个json</span><br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;pong&quot;</span>,<br>&#125;)<br>&#125;)<br><br>r.Run() <span class="hljs-comment">// 监听并在 0.0.0.0:8080 上启动服务</span><br>&#125;<br></code></pre></td></tr></table></figure><p>就是这么高效，跟Go自身的http一样，几行代码就可以开启一个WEB服务。</p><p><strong>Gin框架运行模式</strong></p><p>为方便调试，Gin 框架在运行的时候默认是debug模式，在控制台默认会打印出很多调试日志，上线的时候我们需要关闭debug模式，改为release模式。</p><ol><li><p>通过环境变量设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export GIN_MODE=release<br></code></pre></td></tr></table></figure></li><li><p>通过代码设置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">在main函数，初始化gin框架的时候执行下面代码<br><span class="hljs-comment">// 设置 release模式</span><br>gin.SetMode(<span class="hljs-string">&quot;debug&quot;</span>)<br><span class="hljs-comment">// 或者 设置debug模式</span><br>gin.SetMode(<span class="hljs-string">&quot;release&quot;</span>)<br><span class="hljs-comment">// 或者 设置test模式</span><br>gin.SetMode(<span class="hljs-string">&quot;test&quot;</span>)<br></code></pre></td></tr></table></figure></li></ol><h2 id="路由："><a href="#路由：" class="headerlink" title="路由："></a>路由：</h2><p>一条路由规则由三部分组成：</p><ul><li>http请求方法</li><li>url路径</li><li>一个或多个控制器函数</li></ul><ol><li><p>请求方法有 <strong>GET, POST, PUT, PATCH, DELETE</strong> 和 <strong>OPTIONS</strong>，还有<strong>Any</strong>，可匹配以上任意类型的请求。常用的http请求方法有下面4种:GET、POST、PUT、DELETE。</p></li><li><p>url路径：</p><p>url路径有三种写法：静态url路径、带路径参数的url路径、带星号（*）模糊匹配参数的url路径</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 例子<span class="hljs-number">1</span>， 静态Url路径, 即不带任何参数的url路径<br><span class="hljs-regexp">/users/</span>center<br><span class="hljs-regexp">/user/</span><span class="hljs-number">111</span><br><span class="hljs-regexp">/food/</span><span class="hljs-number">12</span><br><br><span class="hljs-regexp">//</span> 例子<span class="hljs-number">2</span>，带路径参数的url路径，url路径上面带有参数,参数由冒号（:）跟着一个字符串定义。<br><span class="hljs-regexp">//</span> 路径参数值可以是数值，也可以是字符串<br><br><span class="hljs-regexp">//</span>定义参数:id， 可以匹配<span class="hljs-regexp">/user/</span><span class="hljs-number">1</span>, <span class="hljs-regexp">/user/</span><span class="hljs-number">899</span> <span class="hljs-regexp">/user/</span>xiaoli 这类Url路径<br><span class="hljs-regexp">/user/</span>:id<br><br><span class="hljs-regexp">//</span>定义参数:id， 可以匹配<span class="hljs-regexp">/food/</span><span class="hljs-number">2</span>, <span class="hljs-regexp">/food/</span><span class="hljs-number">100</span> <span class="hljs-regexp">/food/</span>apple 这类Url路径<br><span class="hljs-regexp">/food/</span>:id<br><br><span class="hljs-regexp">//</span>定义参数:type和:page， 可以匹配<span class="hljs-regexp">/foods/</span><span class="hljs-number">2</span><span class="hljs-regexp">/1, /</span>food<span class="hljs-regexp">/100/</span><span class="hljs-number">25</span> <span class="hljs-regexp">/food/</span>apple/<span class="hljs-number">30</span> 这类Url路径<br><span class="hljs-regexp">/foods/</span>:type/:page<br><br><span class="hljs-regexp">//</span> 例子<span class="hljs-number">3</span>. 带星号（*）模糊匹配参数的url路径<br><span class="hljs-regexp">//</span> 星号代表匹配任意路径的意思, 必须在*号后面指定一个参数名，后面可以通过这个参数获取*号匹配的内容。<br><br><span class="hljs-regexp">//</span>以<span class="hljs-regexp">/foods/</span> 开头的所有路径都匹配<br><span class="hljs-regexp">//</span>匹配：<span class="hljs-regexp">/foods/</span><span class="hljs-number">1</span>， <span class="hljs-regexp">/foods/</span><span class="hljs-number">200</span>, <span class="hljs-regexp">/foods/</span><span class="hljs-number">1</span><span class="hljs-regexp">/20, /</span>foods<span class="hljs-regexp">/apple/</span><span class="hljs-number">1</span> <br><span class="hljs-regexp">/foods/</span>*path<br><br><span class="hljs-regexp">//</span>可以通过path参数获取*号匹配的内容。<br></code></pre></td></tr></table></figure></li><li><p>控制器函数定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HandlerFunc</span><span class="hljs-params">(c *gin.Context)</span></span>  <span class="hljs-comment">//即入参为(*gin.Context)</span><br></code></pre></td></tr></table></figure></li><li><p>路由定义例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//实例化gin实例对象。</span><br>r := gin.Default()<br><br><span class="hljs-comment">//定义post请求, url路径为：/users, 绑定saveUser控制器函数</span><br>r.POST(<span class="hljs-string">&quot;/users&quot;</span>, saveUser)<br><br><span class="hljs-comment">//定义get请求，url路径为：/users/:id  （:id是参数，例如: /users/10, 会匹配这个url模式），绑定getUser控制器函数</span><br>r.GET(<span class="hljs-string">&quot;/users/:id&quot;</span>, getUser)<br><br><span class="hljs-comment">//定义put请求</span><br>r.PUT(<span class="hljs-string">&quot;/users/:id&quot;</span>, updateUser)<br><br><span class="hljs-comment">//定义delete请求</span><br>r.DELETE(<span class="hljs-string">&quot;/users/:id&quot;</span>, deleteUser)<br><br><br><span class="hljs-comment">//控制器函数实现</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">saveUser</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>    ...忽略实现...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getUser</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>    ...忽略实现...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">updateUser</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>    ...忽略实现...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteUser</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>    ...忽略实现...<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="分组路由："><a href="#分组路由：" class="headerlink" title="分组路由："></a>分组路由：</h3><p>在做api开发的时候，如果要支持多个api版本，我们可以通过分组路由来实现api版本处理，或者当一个中间件只想对一部分路径使用时（比如需要鉴权的api与不需要鉴权的api），可以这样灵活使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>router := gin.Default()<br><br><span class="hljs-comment">// 创建v1组</span><br>v1 := router.Group(<span class="hljs-string">&quot;/v1&quot;</span>)<br>&#123;<br>                <span class="hljs-comment">// 在v1这个分组下，注册路由</span><br>v1.POST(<span class="hljs-string">&quot;/login&quot;</span>, loginEndpoint)<br>v1.POST(<span class="hljs-string">&quot;/submit&quot;</span>, submitEndpoint)<br>v1.POST(<span class="hljs-string">&quot;/read&quot;</span>, readEndpoint)<br>&#125;<br><br><span class="hljs-comment">// 创建v2组</span><br>v2 := router.Group(<span class="hljs-string">&quot;/v2&quot;</span>)<br>&#123;<br>                <span class="hljs-comment">// 在v2这个分组下，注册路由</span><br>v2.POST(<span class="hljs-string">&quot;/login&quot;</span>, loginEndpoint)<br>v2.POST(<span class="hljs-string">&quot;/submit&quot;</span>, submitEndpoint)<br>v2.POST(<span class="hljs-string">&quot;/read&quot;</span>, readEndpoint)<br>&#125;<br><br>router.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在项目中规范使用："><a href="#在项目中规范使用：" class="headerlink" title="在项目中规范使用："></a>在项目中规范使用：</h3><p>该部分结合上面的目录结构，对路由初始化，api接口接入，路由处理函数的存放位置做一个小结。</p><p>以我的演示项目为例</p><p><img src="https://img.tucang.cc/api/image/show/4a63dbc05142724a27e302748f13cd4d"></p><ol><li><p>路由初始化：</p><p>我们将路由初始化的函数放在router目录下的router.go中，里面主要就是完成获取一个gin.engine，一些参数的设置，和注册路由（调用同目录下的router_xx.go中的函数）。然后将这个初始化后的engine返回给main.go，在main.go新建http.Server的实例，并把engine绑定到它的handler中，然后启动服务</p></li><li><p>api接口接入: 由router.go在初始化路由时调用同目录下的router_xx.go中的函数，这样分类的原因是后面可能还会接入不同类型的接口，方便管理，例如router_api则是负责api方面的路由接入，它主要是进行api路径下的不同功能的路由处理函数的注册，而路由函数又存在internel&#x2F;api中。</p></li><li><p>在internel&#x2F;api中我们根据项目中不同的模块（例如admin，管理员模块）来创建相应的目录，然后再在这些相应目录下写路由处理函数，并且每个功能的文件名为func_xxx.go，方便观看，而且每个目录下也有一个handler.go，它主要就是提供给api接口绑定路由处理方法的接口。</p></li></ol><h2 id="处理请求参数："><a href="#处理请求参数：" class="headerlink" title="处理请求参数："></a>处理请求参数：</h2><h3 id="获取Get-请求参数"><a href="#获取Get-请求参数" class="headerlink" title="获取Get 请求参数"></a>获取Get 请求参数</h3><p>Get请求url例子：*&#x2F;path?id&#x3D;1234&amp;name&#x3D;Manu&amp;value&#x3D;*111</p><p>获取Get请求参数的常用函数：</p><ul><li><strong>func</strong> (c *Context) <strong>Query</strong>(key string) string</li><li><strong>func</strong> (c *Context) <strong>DefaultQuery</strong>(key, defaultValue string) string</li><li><strong>func</strong> (c *Context) <strong>GetQuery</strong>(key string) (string, bool)</li></ul><p>例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Handler</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">//获取name参数, 通过Query获取的参数值是String类型。</span><br>name := c.Query(<span class="hljs-string">&quot;name&quot;</span>)<br><br>        <span class="hljs-comment">//获取name参数, 跟Query函数的区别是，可以通过第二个参数设置默认值。</span><br>  name := c.DefaultQuery(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;tizi365&quot;</span>)<br><br><span class="hljs-comment">//获取id参数, 通过GetQuery获取的参数值也是String类型, </span><br><span class="hljs-comment">// 区别是GetQuery返回两个参数，第一个是参数值，第二个参数是参数是否存在的bool值，可以用来判断参数是否存在。</span><br>id, ok := c.GetQuery(<span class="hljs-string">&quot;id&quot;</span>)<br>        <span class="hljs-keyword">if</span> !ok &#123;<br>   <span class="hljs-comment">// 参数不存在</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>提示：GetQuery函数，判断参数是否存在的逻辑是，参数值为空，参数也算存在，只有没有提交参数，才算参数不存在。</p></blockquote><h3 id="获取Post请求参数"><a href="#获取Post请求参数" class="headerlink" title="获取Post请求参数"></a>获取Post请求参数</h3><p>获取Post请求参数的常用函数：</p><ul><li><strong>func</strong> (c *Context) <strong>PostForm</strong>(key string) string</li><li><strong>func</strong> (c *Context) <strong>DefaultPostForm</strong>(key, defaultValue string) string</li><li><strong>func</strong> (c *Context) <strong>GetPostForm</strong>(key string) (string, bool)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Handler</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">//获取name参数, 通过PostForm获取的参数值是String类型。</span><br>name := c.PostForm(<span class="hljs-string">&quot;name&quot;</span>)<br><br><span class="hljs-comment">// 跟PostForm的区别是可以通过第二个参数设置参数默认值</span><br>name := c.DefaultPostForm(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;tizi365&quot;</span>)<br><br><span class="hljs-comment">//获取id参数, 通过GetPostForm获取的参数值也是String类型,</span><br><span class="hljs-comment">// 区别是GetPostForm返回两个参数，第一个是参数值，第二个参数是参数是否存在的bool值，可以用来判断参数是否存在。</span><br>id, ok := c.GetPostForm(<span class="hljs-string">&quot;id&quot;</span>)<br><span class="hljs-keyword">if</span> !ok &#123;<br>    <span class="hljs-comment">// 参数不存在</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取URL路径参数"><a href="#获取URL路径参数" class="headerlink" title="获取URL路径参数"></a>获取URL路径参数</h3><p>获取URL路径参数，指的是获取 <em><strong>&#x2F;user&#x2F;:id</strong></em> 这类型路由绑定的参数，这个例子绑定了一个参数id。</p><p>获取url路径参数常用函数：</p><ul><li><strong>func</strong> (c *Context) <strong>Param</strong>(key string) string</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">r := gin.Default()<br><br>r.GET(<span class="hljs-string">&quot;/user/:id&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">// 获取url参数id</span><br>id := c.Param(<span class="hljs-string">&quot;id&quot;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="将请求参数绑定到struct对象"><a href="#将请求参数绑定到struct对象" class="headerlink" title="将请求参数绑定到struct对象"></a>将请求参数绑定到struct对象</h3><p>前面获取参数的方式都是一个个参数的读取，比较麻烦，Gin框架支持将请求参数自动绑定到一个struct对象，这种方式支持Get&#x2F;Post请求，也支持http请求body内容为json&#x2F;xml&#x2F;yaml&#x2F;toml格式的参数。Gin中的绑定办法可以分为两类：<code>Must Bind</code>和<code>Should Bind</code>。</p><ul><li>Must Bind: 相应的方法有： <code>Bind</code>, <code>BindJSON</code>, <code>BindXML</code>, <code>BindQuery</code>, <code>BindYAML</code>, <code>BindHeader</code>, <code>BindTOML</code>，这种方法的底层调用的是<code>MustBindWith</code>，一旦绑定出现错误则该请求会被中断，并且响应信息的状态码会被设为400，响应头<code>Content-Type</code>被设为<code>text/plain; charset=utf-8</code>，这里有注意一点是，它已经是设置好了响应头信息了，它将会发出警告，所以如果希望更好地控制行为，请考虑使用ShouldBind等效方法。</li><li>Should Bind：相应的方法有：<code>ShouldBind</code>, <code>ShouldBindJSON</code>, <code>ShouldBindXML</code>, <code>ShouldBindQuery</code>, <code>ShouldBindYAML</code>, <code>ShouldBindHeader</code>, <code>ShouldBindTOML</code>,这种方法的底层调用的是<code>ShouldBindWith</code>,如果出现了绑定错误那么错误信息(error)会返回，然后由我们自定义如何解决error，并且返回相关信息。</li></ul><blockquote><p>使用<code>Bind</code>类型方法而非<code>类似BingJSON</code>等时，Gin试图根据Content-Type标头推断活页夹。所以如果您确定要绑定什么，您可以使用<code>MustBindWith</code>或<code>ShouldBindWith</code>。</p><p>您还可以指定特定字段是必需的。如果字段装饰有<code>binding:&quot;required&quot;</code>并且绑定时值为空，则将返回错误。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// User 结构体定义</span><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>  Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot; form:&quot;name&quot;`</span><br>  Email <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;email&quot; form:&quot;email&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过定义struct字段的标签，定义请求参数和struct字段的关系。</p><p><strong>struct标签说明：</strong></p><table><thead><tr><th align="left">标签</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">json:”name”</td><td align="left">数据格式为json格式，并且json字段名为name</td></tr><tr><td align="left">form:”name”</td><td align="left">表单参数名为name</td></tr></tbody></table><p>下面看下控制器代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">r.POST(<span class="hljs-string">&quot;/user/:id&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>   <span class="hljs-comment">// 初始化user struct</span><br>   u := User&#123;&#125;<br>   <span class="hljs-comment">// 通过ShouldBind函数，将请求参数绑定到struct对象， 处理json请求代码是一样的。</span><br>   <span class="hljs-comment">// 如果是post请求则根据Content-Type判断，接收的是json数据，还是普通的http请求参数</span><br>   <span class="hljs-keyword">if</span> c.ShouldBind(&amp;u) == <span class="hljs-literal">nil</span> &#123;<br>     <span class="hljs-comment">// 绑定成功， 打印请求参数</span><br>     log.Println(u.Name)<br>     log.Println(u.Email)<br><br>    &#125;<br>    <span class="hljs-comment">// http 请求返回一个字符串 </span><br>    c.String(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;Success&quot;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="获取客户ip"><a href="#获取客户ip" class="headerlink" title="获取客户ip"></a>获取客户ip</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">r := gin.Default()<br><br>r.GET(<span class="hljs-string">&quot;/ip&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">// 获取用户IP</span><br>ip := c.ClientIP()<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="处理请求结果"><a href="#处理请求结果" class="headerlink" title="处理请求结果"></a>处理请求结果</h2><h3 id="以字符串方式响应请求"><a href="#以字符串方式响应请求" class="headerlink" title="以字符串方式响应请求"></a>以字符串方式响应请求</h3><p>函数定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> String(code <span class="hljs-type">int</span>, format <span class="hljs-type">string</span>, values ...<span class="hljs-keyword">interface</span>&#123;&#125;)<br></code></pre></td></tr></table></figure><p>参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">code</td><td align="left">http状态码</td></tr><tr><td align="left">format</td><td align="left">返回结果，支持类似Sprintf函数一样的字符串格式定义，例如,%d 代表插入整数，%s代表插入字符串</td></tr><tr><td align="left">values</td><td align="left">任意个format参数定义的字符串格式参数</td></tr></tbody></table><p>例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Handler</span><span class="hljs-params">(c *gin.Context)</span></span>  &#123;<br><span class="hljs-comment">// 例子1：</span><br>c.String(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;欢迎访问tizi360.com!&quot;</span>)<br><br><span class="hljs-comment">// 例子2： 这里定义了两个字符串参数（两个%s），后面传入的两个字符串参数将会替换对应的%s</span><br>c.String(<span class="hljs-number">200</span>,<span class="hljs-string">&quot;欢迎访问%s, 你是%s&quot;</span>, <span class="hljs-string">&quot;tizi360.com!&quot;</span>,<span class="hljs-string">&quot;最靓的仔！&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="以json格式响应请求"><a href="#以json格式响应请求" class="headerlink" title="以json格式响应请求"></a>以json格式响应请求</h3><p>我们开发api接口的时候常用的格式就是json，下面是返回json格式数据的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// User 定义</span><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>  Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span> <span class="hljs-comment">// 通过json标签定义struct字段转换成json字段的名字。</span><br>  Email <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;email&quot;`</span><br>&#125;<br><br><span class="hljs-comment">// Handler 控制器</span><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>  <span class="hljs-comment">//初始化user对象</span><br>  u := &amp;User&#123;<br>    Name:  <span class="hljs-string">&quot;tizi365&quot;</span>,<br>    Email: <span class="hljs-string">&quot;tizi@tizi365.com&quot;</span>,<br>  &#125;<br>  <span class="hljs-comment">//返回json数据</span><br>  <span class="hljs-comment">//返回结果：&#123;&quot;name&quot;:&quot;tizi365&quot;, &quot;email&quot;:&quot;tizi@tizi365.com&quot;&#125;</span><br>  c.JSON(<span class="hljs-number">200</span>, u)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="以xml格式响应请求"><a href="#以xml格式响应请求" class="headerlink" title="以xml格式响应请求"></a>以xml格式响应请求</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// User 定义, 默认struct的名字就是xml的根节点名字，这里转换成xml后根节点的名字为User.</span><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>  Name  <span class="hljs-type">string</span> <span class="hljs-string">`xml:&quot;name&quot;`</span> <span class="hljs-comment">// 通过xml标签定义struct字段转换成xml字段的名字。</span><br>  Email <span class="hljs-type">string</span> <span class="hljs-string">`xml:&quot;email&quot;`</span><br>&#125;<br><br><span class="hljs-comment">// Handler 控制器</span><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>  <span class="hljs-comment">//初始化user对象</span><br>  u := &amp;User&#123;<br>    Name:  <span class="hljs-string">&quot;GoPro&quot;</span>,<br>    Email: <span class="hljs-string">&quot;578491040@qq.com&quot;</span>,<br>  &#125;<br>  <span class="hljs-comment">//返回xml数据</span><br>  <span class="hljs-comment">//返回结果：</span><br>  <span class="hljs-comment">//  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br>  <span class="hljs-comment">//  &lt;User&gt;&lt;name&gt;tizi365&lt;/name&gt;&lt;email&gt;tizi@tizi365.com&lt;/email&gt;&lt;/User&gt;</span><br>  c.XML(<span class="hljs-number">200</span>, u)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="以文件格式响应请求"><a href="#以文件格式响应请求" class="headerlink" title="以文件格式响应请求"></a>以文件格式响应请求</h3><p>面介绍gin框架如何直接返回一个文件，可以用来做文件下载。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">例子<span class="hljs-number">1</span>：<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>  <span class="hljs-comment">//通过File函数，直接返回本地文件，参数为本地文件地址。</span><br>  <span class="hljs-comment">//函数说明：c.File(&quot;文件路径&quot;)</span><br>  c.File(<span class="hljs-string">&quot;/var/www/1.jpg&quot;</span>)<br>&#125;<br><br>例子<span class="hljs-number">2</span>：<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>  <span class="hljs-comment">//通过FileAttachment函数，返回本地文件，类似File函数，区别是可以指定下载的文件名。</span><br>  <span class="hljs-comment">//函数说明: c.FileAttachment(&quot;文件路径&quot;, &quot;下载的文件名&quot;)</span><br>  c.FileAttachment(<span class="hljs-string">&quot;/var/www/1.jpg&quot;</span>, <span class="hljs-string">&quot;1.jpg&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="设置http响应头（设置Header）"><a href="#设置http响应头（设置Header）" class="headerlink" title="设置http响应头（设置Header）"></a>设置http响应头（设置Header）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>  <span class="hljs-comment">//设置http响应 header, key/value方式，支持设置多个header</span><br>  c.Header(<span class="hljs-string">&quot;site&quot;</span>,<span class="hljs-string">&quot;GoPro&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="设置404页面、重定向："><a href="#设置404页面、重定向：" class="headerlink" title="设置404页面、重定向："></a>设置404页面、重定向：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">r.NoRoute(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        c.String(http.StatusNotFound, <span class="hljs-string">&quot;404 not found2222&quot;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>重定向：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">c.Redirect(http.StatusMovedPermanently, <span class="hljs-string">&quot;opengxj.github.io&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="处理静态文件："><a href="#处理静态文件：" class="headerlink" title="处理静态文件："></a>处理静态文件：</h2><p>如果项目中包含js、css、jpg之类的静态文件，怎么访问访问静态文件？两种方法：</p><ol><li>绑定本地目录到相应路由下</li><li>绑定本地文件到相应路由下</li></ol><p>下面例子介绍如何处理访问静态资源文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>router := gin.Default()<br>        <span class="hljs-comment">// 设置静态资源文件目录，并且绑定一个Url前缀</span><br>        <span class="hljs-comment">// 静态资源文件目录：/var/GoPro/assets</span><br>        <span class="hljs-comment">// /assets是访问静态资源的url前缀</span><br>        <span class="hljs-comment">// 例如：</span><br>        <span class="hljs-comment">//   /assets/images/1.jpg 这个url文件，存储在/var/GoPro/assets/images/1.jpg</span><br>router.Static(<span class="hljs-string">&quot;/assets&quot;</span>, <span class="hljs-string">&quot;/var/GoPro/assets/&quot;</span>)<br><br>        <span class="hljs-comment">// 为单个静态资源文件，绑定url</span><br>        <span class="hljs-comment">// 这里的意思就是将/favicon.ico这个url，绑定到./resources/favicon.ico这个文件</span><br>router.StaticFile(<span class="hljs-string">&quot;/favicon.ico&quot;</span>, <span class="hljs-string">&quot;./resources/favicon.ico&quot;</span>)<br><br><span class="hljs-comment">// Listen and serve on 0.0.0.0:8080</span><br>router.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>提示：设置&#x2F;favicon.ico这个url，其实就是为网站设置图标，浏览器默认会将这个url作为网站默认图标。</p></blockquote><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="上传单个文件："><a href="#上传单个文件：" class="headerlink" title="上传单个文件："></a>上传单个文件：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  router := gin.Default()<br>  <span class="hljs-comment">// Set a lower memory limit for multipart forms (default is 32 MiB)</span><br>  router.MaxMultipartMemory = <span class="hljs-number">8</span> &lt;&lt; <span class="hljs-number">20</span>  <span class="hljs-comment">// 8 MiB</span><br>  router.POST(<span class="hljs-string">&quot;/upload&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>    <span class="hljs-comment">// Single file</span><br>    file, _ := c.FormFile(<span class="hljs-string">&quot;file&quot;</span>)<br>    log.Println(file.Filename)<br><br>    <span class="hljs-comment">// Upload the file to specific dst.</span><br>    c.SaveUploadedFile(file, dst)<br><br>    c.String(http.StatusOK, fmt.Sprintf(<span class="hljs-string">&quot;&#x27;%s&#x27; uploaded!&quot;</span>, file.Filename))<br>  &#125;)<br>  router.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>不太正确的实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">file, _ := c.FormFile(<span class="hljs-string">&quot;file&quot;</span>)<br>c.SaveUploadedFile(file, file.Filename)<br></code></pre></td></tr></table></figure><p>区别是我们这里的<code>SaveUploadedFile</code>的第二个参数。Gin文档是这样说的，<strong>我们不能信任用户给的file.Filename</strong></p><p>因为如果是这种情况下的话，我们发起一个以下的请求：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -X POST -F &#x27;file=@main.go; filename=../main.go&#x27; http://127.0.0.1:8080/upload<br></code></pre></td></tr></table></figure><p>这个模拟的是用户上传的文件名前包含了<code>../</code>然后，您会发现上传的文件位于父目录下（因为文件名前面为..&#x2F;），这样可是很危险的。</p><p>所以建议是这样做：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">file, _ := c.FormFile(<span class="hljs-string">&quot;file&quot;</span>)<br>filename := filepath.Base(file.Filename)<br>c.SaveUploadedFile(file, filename)<br></code></pre></td></tr></table></figure><p><strong>参考html</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://localhost:8080/upload&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span><br>          上传文件:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span> &gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="上传多个文件："><a href="#上传多个文件：" class="headerlink" title="上传多个文件："></a>上传多个文件：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  router := gin.Default()<br>  <span class="hljs-comment">// Set a lower memory limit for multipart forms (default is 32 MiB)</span><br>  router.MaxMultipartMemory = <span class="hljs-number">8</span> &lt;&lt; <span class="hljs-number">20</span>  <span class="hljs-comment">// 8 MiB</span><br>  router.POST(<span class="hljs-string">&quot;/upload&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>    <span class="hljs-comment">// Multipart form</span><br>    form, _ := c.MultipartForm()<br>    files := form.File[<span class="hljs-string">&quot;upload[]&quot;</span>]<br><br>    <span class="hljs-keyword">for</span> _, file := <span class="hljs-keyword">range</span> files &#123;<br>      log.Println(file.Filename)<br><br>      <span class="hljs-comment">// Upload the file to specific dst.</span><br>      c.SaveUploadedFile(file, dst)<br>    &#125;<br>    c.String(http.StatusOK, fmt.Sprintf(<span class="hljs-string">&quot;%d files uploaded!&quot;</span>, <span class="hljs-built_in">len</span>(files)))<br>  &#125;)<br>  router.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>参考html:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://localhost:8000/upload&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span><br>          上传文件:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;files&quot;</span> <span class="hljs-attr">multiple</span>=<span class="hljs-string">&quot;multiple&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="日志文件："><a href="#日志文件：" class="headerlink" title="日志文件："></a>日志文件：</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;io&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    gin.DisableConsoleColor()<br><br>    <span class="hljs-comment">// Logging to a file.</span><br>    f, _ := os.Create(<span class="hljs-string">&quot;gin.log&quot;</span>)<br>    gin.DefaultWriter = io.MultiWriter(f)<br><br>    <span class="hljs-comment">// 如果需要同时将日志写入文件和控制台，请使用以下代码。</span><br>    <span class="hljs-comment">// gin.DefaultWriter = io.MultiWriter(f, os.Stdout)</span><br>    r := gin.Default()<br>    r.GET(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        c.String(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;pong&quot;</span>)<br>    &#125;)<br>    r.Run()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="中间件："><a href="#中间件：" class="headerlink" title="中间件："></a>中间件：</h2><p>在Gin框架中，<strong>中间件</strong>（Middleware）指的是可以拦截<strong>http请求-响应</strong>生命周期的特殊函数，在请求-响应生命周期中可以注册多个中间件，每个中间件执行不同的功能，一个中间执行完再轮到下一个中间件执行。</p><p><strong>中间件的常见应用场景如下：</strong></p><ul><li>请求限速</li><li>api接口签名处理</li><li>权限校验</li><li>统一错误处理</li></ul><p>Gin支持设置全局中间件和针对路由分组设置中间件，设置全局中间件意思就是会拦截所有请求，针对分组路由设置中间件，意思就是仅对这个分组下的路由起作用。</p><h3 id="全局中间件："><a href="#全局中间件：" class="headerlink" title="全局中间件："></a>全局中间件：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//定义中间件</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Logger</span><span class="hljs-params">()</span></span> gin.HandlerFunc &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>    t := time.Now()<br><br>    <span class="hljs-comment">// Set example variable</span><br>    c.Set(<span class="hljs-string">&quot;example&quot;</span>, <span class="hljs-string">&quot;12345&quot;</span>)<br><br>    <span class="hljs-comment">// before request</span><br><br>    c.Next()<br><br>    <span class="hljs-comment">// after request</span><br>    latency := time.Since(t)<br>    log.Print(latency)<br><br>    <span class="hljs-comment">// access the status we are sending</span><br>    status := c.Writer.Status()<br>    log.Println(status)<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  r := gin.New()<br>  <span class="hljs-comment">//绑定中间件</span><br>  r.Use(Logger())<br><br>  r.GET(<span class="hljs-string">&quot;/test&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>    example := c.MustGet(<span class="hljs-string">&quot;example&quot;</span>).(<span class="hljs-type">string</span>)<br><br>    <span class="hljs-comment">// it would print: &quot;12345&quot;</span><br>    log.Println(example)<br>  &#125;)<br><br>  <span class="hljs-comment">// Listen and serve on 0.0.0.0:8080</span><br>  r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Next"><a href="#Next" class="headerlink" title="Next():"></a>Next():</h3><p>调用下一个中间件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-comment">// 定义中间</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MiddleWare</span><span class="hljs-params">()</span></span> gin.HandlerFunc &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        t := time.Now()<br>        fmt.Println(<span class="hljs-string">&quot;中间件开始执行了&quot;</span>)<br>        <span class="hljs-comment">// 设置变量到Context的key中，可以通过Get()取</span><br>        c.Set(<span class="hljs-string">&quot;request&quot;</span>, <span class="hljs-string">&quot;中间件&quot;</span>)<br>        <span class="hljs-comment">// 调用下一个中间件，或者控制器处理函数，具体得看注册了多少个中间件。</span><br>        c.Next()<br>        <span class="hljs-comment">// 中间件执行完后续的一些事情</span><br>        status := c.Writer.Status()<br>        fmt.Println(<span class="hljs-string">&quot;中间件执行完毕&quot;</span>, status)<br>        t2 := time.Since(t)<br>        fmt.Println(<span class="hljs-string">&quot;time:&quot;</span>, t2)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 1.创建路由</span><br>    <span class="hljs-comment">// 默认使用了2个中间件Logger(), Recovery()</span><br>    r := gin.Default()<br>    <span class="hljs-comment">// 注册中间件</span><br>    r.Use(MiddleWare())<br>    <span class="hljs-comment">// &#123;&#125;为了代码规范</span><br>    &#123;<br>        r.GET(<span class="hljs-string">&quot;/ce&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>            <span class="hljs-comment">// 取值</span><br>            req, _ := c.Get(<span class="hljs-string">&quot;request&quot;</span>)<br>            fmt.Println(<span class="hljs-string">&quot;request:&quot;</span>, req)<br>            <span class="hljs-comment">// 页面接收</span><br>            c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<span class="hljs-string">&quot;request&quot;</span>: req&#125;)<br>        &#125;)<br><br>    &#125;<br>    r.Run()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="局部中间件"><a href="#局部中间件" class="headerlink" title="局部中间件:"></a>局部中间件:</h3><p>将中间件直接绑定在路由函数上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-comment">// 定义中间</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MiddleWare</span><span class="hljs-params">()</span></span> gin.HandlerFunc &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        t := time.Now()<br>        fmt.Println(<span class="hljs-string">&quot;中间件开始执行了&quot;</span>)<br>        <span class="hljs-comment">// 设置变量到Context的key中，可以通过Get()取</span><br>        c.Set(<span class="hljs-string">&quot;request&quot;</span>, <span class="hljs-string">&quot;中间件&quot;</span>)<br>        <span class="hljs-comment">// 执行函数</span><br>        c.Next()<br>        <span class="hljs-comment">// 中间件执行完后续的一些事情</span><br>        status := c.Writer.Status()<br>        fmt.Println(<span class="hljs-string">&quot;中间件执行完毕&quot;</span>, status)<br>        t2 := time.Since(t)<br>        fmt.Println(<span class="hljs-string">&quot;time:&quot;</span>, t2)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 1.创建路由</span><br>    <span class="hljs-comment">// 默认使用了2个中间件Logger(), Recovery()</span><br>    r := gin.Default()<br>    <span class="hljs-comment">//局部中间键使用</span><br>    r.GET(<span class="hljs-string">&quot;/ce&quot;</span>, MiddleWare(), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>        <span class="hljs-comment">// 取值</span><br>        req, _ := c.Get(<span class="hljs-string">&quot;request&quot;</span>)<br>        fmt.Println(<span class="hljs-string">&quot;request:&quot;</span>, req)<br>        <span class="hljs-comment">// 页面接收</span><br>        c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<span class="hljs-string">&quot;request&quot;</span>: req&#125;)<br>    &#125;)<br>    r.Run()<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>Gin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Gin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>🥖Mysql--数据页结构</title>
    <link href="/2022/10/16/Mysql--%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/"/>
    <url>/2022/10/16/Mysql--%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>我们一直说记录放在页中，页是内存和磁盘交换数据的基本单位，那这个页到底长啥样呢？它主要又七部分组成，File Header、Page Header 、Infimum+supermum、User Records、Free Space、Page Directory和File Trailer，我们一起一趟究竟！</p><span id="more"></span><h1 id="🥖Mysql–数据页结构"><a href="#🥖Mysql–数据页结构" class="headerlink" title="🥖Mysql–数据页结构"></a>🥖Mysql–数据页结构</h1><p><img src="https://img.tucang.cc/api/image/show/153b32c36a29871ee1918228eb7f6895"></p><h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><blockquote><p>我们在前面的文章中已经提到了：Innodb中页做为内存和磁盘数据交换的基本单位，人们为了达到不同的目的设置了多种不同的页，比如存放表空间头部信息的页，存放Insert Buffer信息的页，存放 INODE 信息的页，存放 undo 日志信息的页等等等等，这些奇奇怪怪的页先放放，我们本次的重点是存放数据的页，也就是索引页，我们暂且称它为数据页</p></blockquote><p>数据页代表的这块 16KB 大小的存储空间可以被划分为多个部分，不同部分有不同的功能，各个部分如图所示:</p><p><img src="https://img.tucang.cc/api/image/show/8a98c31425f03ab225976c83839c27e9"></p><p><strong>不用急，我们等下会一个个的搞懂他们的含义。</strong></p><h2 id="记录在页中的存储："><a href="#记录在页中的存储：" class="headerlink" title="记录在页中的存储："></a>记录在页中的存储：</h2><p>在页的7个组成部分中，我们自己存储的记录会按照我们指定的 行格式 存储到 User Records 部分。但是在一开 始生成页的时候，其实并没有 User Records 这个部分，每当我们插入一条记录，都会从 Free Space 部分，也就 是尚未使用的存储空间中申请一个记录大小的空间划分到 User Records 部分，当 Free Space 部分的空间全部被 User Records 部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了。</p><p>为了更好的管理在 User Records 中的这些记录， InnoDB 可费了一番力气呢，在哪费力气了呢?不就是把记录按照指定的行格式一条一条摆在 User Records 部分么?其实这话还得从记录行格式的 记录头信息中说起。（前面说行格式留下的坑将在这里填上～～）</p><h3 id="记录头信息："><a href="#记录头信息：" class="headerlink" title="记录头信息："></a>记录头信息：</h3><p>为了故事的顺利发展，我们先创建一个表:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> page_demo(<br><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> c1 <span class="hljs-type">INT</span>,<br><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> c2 <span class="hljs-type">INT</span>,<br><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     c3 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10000</span>),<br><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>     <span class="hljs-keyword">PRIMARY</span> KEY (c1)<br><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> ) CHARSET<span class="hljs-operator">=</span>ascii ROW_FORMAT<span class="hljs-operator">=</span>Compact;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.03</span> sec)<br></code></pre></td></tr></table></figure><p>这个新创建的 page_demo 表有3个列，其中 c1 和 c2 列是用来存储整数的， c3 列是用来存储字符串的。需要注 意的是，我们把 <strong>c1</strong> 列指定为主键，所以在具体的行格式中InnoDB就没必要为我们去创建那个所谓的 <strong>row_id</strong> 隐藏列了。而且我们为这个表指定了 ascii 字符集以及 Compact 的行格式。所以这个表中记录的行格式示意图就是 这样的:</p><p><img src="https://img.tucang.cc/api/image/show/4f625f40c710a6da91776299a775fe39"></p><p>下面我们开始揭开每个部分的面纱～</p><p>我们先往表中插入几行数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> page_demo <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;aaaa&#x27;</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">200</span>, <span class="hljs-string">&#x27;bbbb&#x27;</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">300</span>, <span class="hljs-string">&#x27;cccc&#x27;</span>),(<span class="hljs-number">4</span>, <span class="hljs-number">400</span>, <span class="hljs-string">&#x27;dddd&#x27;</span>);<br>Query OK, <span class="hljs-number">4</span> <span class="hljs-keyword">rows</span> affected (<span class="hljs-number">0.00</span> sec)<br>Records: <span class="hljs-number">4</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>因为此刻的重点是记录头信息，所以我们省去了几个部分，下面是这几条记录在页中目前的格式</p><p><img src="https://img.tucang.cc/api/image/show/56636e0ce89a0e4ad76e5a89c49c8dc6"></p><p>好了，正式开始。</p><p><strong>delete_mask</strong></p><p>别看上面几条记录中间还有空隙，真实数据在页中是紧碍着摆放的，删来删去的，其他的记录调整空间是挺麻烦的，所以就用<strong>这个属性标记着当前记录是否被删除</strong>，占用1个二进制位，值为 0 的时候代表记录并没有被删除，为 1 的时候代表记录被删除掉了。所有被删除掉的记 录都会组成一个所谓的<strong>垃圾链表</strong>，在这个链表中的记录占用的空间称之为所谓的<strong>可重用空间</strong>，之后如果有 新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。</p><p><strong>min_rec_mask</strong></p><p><strong>标记是否为B+树一层中非叶子节点的最小记录</strong>，1则是,0则不是，后面讲索引的时候就能明白了。</p><p><strong>n_owned</strong></p><p>这个待会讲Page directory时说，先放一放</p><p><strong>heap_no</strong></p><p><strong>这个属性表示当前记录在本页中的位置</strong>，从图中可以看出来，我们插入的4条记录在本 页 中的位置分别是: 2、3、4、5 。是不是少了点啥?是的，怎么不见 heap_no 值为 0 和 1 的记录呢?</p><p>那是因为Innodb为我们预设了两行记录：最小记录（0）和最大记录（1）（<strong>比较记录的大小就是比较 主键 的大小</strong>）。</p><p><strong>record_type</strong></p><p>这个属性表示当前记录的类型，一共有4种类型的记录， 0 表示普通记录， 1表示B+树非叶节点记录，2表示最小记录，3表示最大记录。</p><p><strong>next_record</strong></p><p>这玩意儿非常重要，它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。假如第一条录的next_record 值为 32 ，意味着从第一条记录的真实数据的地址处向后找 32 个字节便是下一条记录的真实数据所在的位置（这里的下一条记录可不是按插入顺序的下一条记录，而是根据主键排序后的下一条记录）。还记得上面的最小最大记录吗，Innodb规定不管你怎么插入数据，这两个人的含义是雷打不动的，也就是规定最小记录加上next_record必须是第一条记录，最后一条记录加上next_record必须是最大记录，这就让这些记录像一个链表一样，按照主键值的大小从最小记录串到最大记录。就像这样</p><p><img src="https://img.tucang.cc/api/image/show/8958a8c03f0e17d9807b0b03ed8b8728"></p><p>结合前面的delete_mask，如果此时删除第二条记录会发生什么？相信你很容易就能猜到，也就是</p><ol><li>第二条记录的delete_mask变为1，next_record变为0</li><li>第1条记录的 next_record 指向了第3条记录。</li></ol><p>填一个坑～～</p><blockquote><p>你会不会觉得next_record这个指针有点儿怪，为啥要指向记录头信息和真实数据之间的位置 呢?为啥不干脆指向整条记录的开头位置，也就是记录的额外信息开头的位置呢? 因为这个位置刚刚好，<strong>向左读取就是记录头信息，向右读取就是真实数据</strong>。我们前边还说过变 长字段长度列表、NULL值列表中的信息都是逆序存放，这样可以使记录中位置靠前的字段和它 们对应的字段长度信息在内存中的距离更近，可能会提高高速缓存的命中率。</p></blockquote><h2 id="Page-Directory"><a href="#Page-Directory" class="headerlink" title="Page Directory"></a>Page Directory</h2><p>现在我们了解了记录在页中按照主键值由小到大顺序串联成一个单链表，那如果我们想根据主键值查找页中的某条记录该咋办呢? 最笨的办法:从 Infimum 记录(最小记录)开始，沿着链表一直往后找，总有一天会找到(或者找不到🤷‍♂️)</p><p>这个方法在页中存储的记录数量比较少的情况用起来也没啥问题，比方说现在我们的表里只有 4 条自己插入的记 录，所以最多找4次就可以把所有记录都遍历一遍，但是如果一个页中存储了非常多的记录，这么查找对性能来说还是损耗很大的。那么Innodb想出了什么好法子呢？也就是Page Directory了。</p><p>像我们看书时找目录一样，Innodb也搞了个目录，具体是：</p><ol><li>将所有正常的记录(包括最大和最小记录，不包括标记为已删除的记录)<strong>划分为几个组</strong>。</li><li>每个组的最后一条记录(也就是组内最大的那条记录)的头信息中的 <strong>n_owned 属性表示该记录拥有多少条记录，也就是该组内共有几条记录</strong>。</li><li><strong>将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近 页 的尾部的地方</strong>，这个地方就是所谓的 Page Directory ，也就是 页目录 (此时应该返回头看看页面各个部分的图)。页面目录中的这些地址 偏移量被称为 槽 (英文名: Slot )，所以这个页面目录就是由槽组成的。</li></ol><p>比方说现在的 page_demo 表中正常的记录共有6条， InnoDB 会把它们分成两组，第一组中只有一个最小记录， 第二组中是剩余的5条记录，看下边的示意图:</p><p><img src="https://img.tucang.cc/api/image/show/5586f6b988f3ce394222aebe3ed9a914"></p><p>如图所示，最小记录的n_owned为1，地址偏移量为99,对应的是槽0，最大记录的n_owned为5，表示的是我们插入的4条记录加上最大记录，地址偏移量为112，对应的槽1。</p><p>为什么最小记录的 n_owned 值为1，而最大记录的 n_owned 值为 5 呢，这里头有什么猫腻么?</p><p>是的，设计 InnoDB的大叔们对每个分组中的记录条数是有规定的:对于最小记录所在的分组只能有<strong>1</strong> 条记录，最大记录所在的分组拥有的记录条数只能在 <strong>1~8</strong> 条之间，剩下的分组中记录的条数范围只能在是 <strong>4~8</strong> 条之间。 <strong>所以分组是按照下边的步骤进行的:</strong></p><ul><li>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。 </li><li>之后每插入一条记录，都会从 页目录 中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对 应的记录的 n_owned 值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。</li><li>在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一 个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。</li></ul><h3 id="如何加快查询过程的？"><a href="#如何加快查询过程的？" class="headerlink" title="如何加快查询过程的？"></a>如何加快查询过程的？</h3><p>真实的情况肯定是不止两个槽的，而是有多个槽，查询过程也就是先根据主键值，使用二分法找到相应的槽，不过这里的二分法和我们平时找一个值的二分法不同，这里的二分法是找到high-low&#x3D;&#x3D;1时停止。此时还不确定能不能找到，还要从high对应的组中最小的记录开始遍历，<strong>怎么定位到high对应的组的最小记录呢？</strong>因为我们的槽保存的是组内最后一行的偏移量，所以无法直接定位到，我们可以采用投机的方式，因为在页中，行是根据主键的大小依次排列的，那么我们就可以靠low对应的槽它的偏移量+1得到high对应的槽组内的第一条记录了。</p><h2 id="Page-Header"><a href="#Page-Header" class="headerlink" title="Page Header"></a>Page Header</h2><p>设计 InnoDB的大叔们为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫 Page Header 的部分，它是页结构的第二部分，这个部分占用固定的 56 个字节，专门存储各种状态信息，具体各个字节都是干嘛的看下面这张表</p><p><img src="https://img.tucang.cc/api/image/show/d4bae983115ff7267a67e51a6b60710a"></p><p>PAGE_DIRECTION 和 PAGE_N_DIRECTION 的意思: </p><p><strong>PAGE_DIRECTION</strong></p><p>假如新插入的一条记录的主键值比上一条记录的主键值大，我们说这条记录的插入方向是右边，反之则是左边。用来表示最后一条记录插入方向的状态就是 PAGE_DIRECTION 。</p><p><strong>PAGE_N_DIRECTION</strong></p><p>假设连续几次插入新记录的方向都是一致的， InnoDB 会把沿着同一个方向插入记录的条数记下来，这个条 数就用 PAGE_N_DIRECTION 这个状态表示。当然，如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计。</p><p>至于我们没提到的那些属性，我没说是因为现在不需要大家知道。不要着急，当我们学完了后边的内容，再回头看，一切都是那么清晰。</p><h2 id="File-Header"><a href="#File-Header" class="headerlink" title="File Header"></a>File Header</h2><p>上边唠叨的 Page Header 是专门针对 数据页 记录的各种状态信息，比方说页里头有多少个记录了呀，有多少个 槽了呀。我们现在描述的 File Header 针对各种类型的页都通用，也就是说不同类型的页都会以 File Header 作 为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁，这个部分占用固定的 38 个字节，是由下边这些内容组成的:</p><p><img src="https://img.tucang.cc/api/image/show/575efe0abd0cd69e63a34019eb61dfa0"><strong>FIL_PAGE_SPACE_OR_CHKSUM</strong></p><p>页的检验和，检验和就是对于较长的字符串使用某种算法进行计算，得到一个长度较小的值，后面就会使用这个值去比较字符串。这个值就是检验和，后面就不用去比较这么长的字符串，如果校验和都不一样两个长字节串肯定是不同 的，所以省去了直接比较两个比较长的字节串的时间损耗。<strong>说了那么多，得出这个检验和，它是用在哪里呢？</strong> 详情在File Trailer部分～～</p><p><strong>FIL_PAGE_OFFSET</strong></p><p>每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB 通过页号来可以唯一定位一个页 。</p><p><strong>FIL_PAGE_TYPE</strong></p><p>这个代表当前 页 的类型，我们前边说过， InnoDB 为了不同的目的而把页分为不同的类型，我们上边介绍的其实都是存储记录的数据页 ，其实还有很多别的类型的页，具体如下</p><ul><li><p>|  类型名称  |   十六进制   |  描述  |</p></li><li><p>FIL_PAGE_TYPE_ALLOCATED |0x0000|最新分配</p></li><li><p>FIL_PAGE_UNDO_LOG |0x0002|Undo日志页</p></li><li><p>FIL_PAGE_INODE |0x0003|段信息节点</p></li><li><p>FIL_PAGE_IBUF_FREE_LIST |0x0004|Insert Buffer空闲列表</p></li><li><p>FIL_PAGE_IBUF_BITMAP |0x0005|Insert Buffer位图</p></li><li><p>FIL_PAGE_TYPE_SYS |0x0006|系统页</p></li><li><p>FIL_PAGE_TYPE_TRX_SYS |0x0007|事务系统数据</p></li><li><p>FIL_PAGE_TYPE_FSP_HDR |0x0008|表空间头部信息</p></li><li><p>FIL_PAGE_TYPE_XDES |0x0009|扩展描述页</p></li><li><p>FIL_PAGE_TYPE_BLOB |0x000A|BLOB页</p></li><li><p>FIL_PAGE_INDEX |0x45BF|索引页，也就是我们所说的 数据页</p></li></ul><p><strong>FIL_PAGE_PREV 和 FIL_PAGE_NEXT</strong></p><p>我们前边强调过， InnoDB 都是以页为单位存放数据的，有时候我们存放某种类型的数据占用的空间非常大 (比方说一张表中可以<strong>有成千上万条记录</strong>)， InnoDB 可能不可以一次性为这么多数据分配一个非常大的存储空间，如果分散到多个不连续的页中存储的话需要把这些页关联起来， FIL_PAGE_PREV 和 FIL_PAGE_NEXT 就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，而无需这些页在物理上真正连着。需要注意的是，并不是所有类型的页都有上一个和下一个页的属性，不过 我们本集中唠叨的 数据页 (也就是类型为 FIL_PAGE_INDEX 的页)是有这两个属性的，所以所有的数据页其 实是一个双链表，就像这样:</p><p><img src="https://img.tucang.cc/api/image/show/23cb8e2ba0e908e9a8ad5c45057dd114"></p><p>关于 File Header 的其他属性我们暂时用不到，等用到的时候再提哈~</p><h2 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h2><p>我们知道 InnoDB 存储引擎会把数据存储到磁盘上，但是磁盘速度太慢，需要以 页 为单位把数据加载到内存中处 理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一 半的时候中断电了咋办，这不是莫名尴尬么?为了检测一个页是否完整(也就是在同步的时候有没有发生只同步 一半的尴尬情况)，设计 InnoDB 的大叔们在每个页的尾部都加了一个 File Trailer 部分，这个部分由 8 个字节组成，可以分成2个小部分:</p><ul><li>前4个字节代表页的校验和</li></ul><p>这个部分是和 File Header 中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为File Header 在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电 了，那么在 File Header 中的校验和就代表着已经修改过的页，而在 File Trialer 中的校验和代表着原先的页，二者不同则意味着同步中间出了错。</p><ul><li>后4个字节代表页面被最后修改时对应的日志序列位置(LSN)，它是用于校验页的完整性的，至于LSN是个什么鬼，得继续看后面的部分</li></ul>]]></content>
    
    
    <categories>
      
      <category>打怪升级</category>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>🍞Mysql--记录的行格式</title>
    <link href="/2022/10/16/Mysql--%E8%AE%B0%E5%BD%95%E7%9A%84%E8%A1%8C%E6%A0%BC%E5%BC%8F/"/>
    <url>/2022/10/16/Mysql--%E8%AE%B0%E5%BD%95%E7%9A%84%E8%A1%8C%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>让我们一起看看记录是如何一行一行摆在页中的，在里面长什么样？</p><span id="more"></span><h1 id="🍞Mysql–记录的行格式"><a href="#🍞Mysql–记录的行格式" class="headerlink" title="🍞Mysql–记录的行格式"></a>🍞Mysql–记录的行格式</h1><p><img src="https://img.tucang.cc/api/image/show/39c6bef6cc8b39b3340a4645a2c11fee"> </p><h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><blockquote><p>你是否有思考过，Mysql表中的数据存在了哪？以什么格式存的？又是以什么方式去访问这些数据的？只有了解了这些才能学习到开发者那些精雕细琢的设计。</p><p>我们知道Mysql服务器上负责写入和读取数据的存储引擎，人们为了不同的目的设计了许多不同的存储引擎，真实数据在不同存储引擎中存放的格式一般也是不同的，因为Innodb现在是mysql的默认存储引擎，所以我接下来好好聊下Innodb的数据存储结构。</p><p>在Innodb中，数据被持久化在磁盘上，而数据的处理过程是发生在内存中的，所以读取数据时都得先从磁盘上把数据读到内存再操作，如果有对数据进行修改还要把新数据刷新回磁盘中。那读数据到内存的过程是怎么样的呢？当然不可能是一行一行的读啦，mysql将将数据分为若干个页，页做为内存和磁盘交换数据的基本单位，一个页大小一般为16KB。</p><p>这篇文章讨论的行格式是什么呢？操作mysql时我们是以记录的格式向表中插入数据的，而这些记录存在页中的格式就称为行格式或者记录格式。</p><p>设计 InnoDB 存储引擎的大叔们到现在为止设计了4种不同类型的 行格式 ，分别是 Compact 、 Redundant 、Dynamic 和 Compressed 行格式，随着时间的推移，他们可能会设计出更多的行格式，但是不管怎么变，在原理 上大体都是相同的。</p></blockquote><h2 id="指定行格式："><a href="#指定行格式：" class="headerlink" title="指定行格式："></a>指定行格式：</h2><p>首先我们学习如何指定行格式，没有像字符集那样要分好几个级别，行格式都是在表层面修改的，也就是在创建表时指定和修改表时指定。也就是</p><ul><li>CREATE TABLE 表名 (列的信息) ROW_FORMAT&#x3D;行格式名称</li><li>ALTER TABLE 表名 ROW_FORMAT&#x3D;行格式名称</li></ul><h2 id="Compact行格式："><a href="#Compact行格式：" class="headerlink" title="Compact行格式："></a>Compact行格式：</h2><blockquote><p>我们以行格式Compact来学习Innodb的行格式，因为学完它后，其他的行格式其实也差不多</p></blockquote><p>先看图：</p><p><img src="https://img.tucang.cc/api/image/show/6f63b6d8a7051c8bfbef45812b7379f3"></p><p>从图中可以看出一行记录分为两部分：记录的额外信息和记录的真实数据。</p><h3 id="记录的额外信息："><a href="#记录的额外信息：" class="headerlink" title="记录的额外信息："></a>记录的额外信息：</h3><p>这部分信息是服务器为了描述这条记录而不得不额外添加的一些信息，这些额外信息分为3类，分别是 变长字段长度列表 、 NULL值列表 和 记录头信息 ，我们分别看一下。</p><h4 id="变长字段长度列表："><a href="#变长字段长度列表：" class="headerlink" title="变长字段长度列表："></a>变长字段长度列表：</h4><p>我们知道mysql中支持一些变长字段，比如varchar(M)、varbinary(M)、各种TEXT类型和各种BLOB类型，变长字段中存储多少字节的数据是不固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来，这样才不至于把 MySQL 服务器搞懵（密密麻麻的数据碍一起，谁是谁的）。也就是说对于变长字段，我们在存入数据时是要存两部分的，一部分是数据的真实数据，另一部分是该字段的占用的字节数。</p><p>在 Compact 行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个<strong>变长字段长度列表</strong>，各变长字段数据占用的字节数按照列的顺序逆序存放，记住是逆序存放哦，（对性能有考虑的，后面会提到）。</p><p>如果我们执行以下语句</p><p><img src="https://img.tucang.cc/api/image/show/0a4a23bfd388b1a00306f19f5dca7269"></p><p>因为我们的c1、c2、c4列是变长字段的，所以第一条记录在页中应该是这样子的。</p><p><img src="https://img.tucang.cc/api/image/show/48fb80a34e6e324abbd6de03a3507de8"></p><p>上面展示的这条例子中，几个字段占用的字节数都较少，所以都用一个字节就存储下来了，而其实如果对于占用字节数较多的字段是会用两个字节表示的，具体的抉择如下：</p><p>我们首先声明一下W、M和L分别代表什么意思：</p><ul><li>W：某个字符集中表示一个字符最多需要使用的字节数为 W ，也就是使用 SHOW CHARSET 语句的结果中的 Maxlen 列，比方说 utf8 字符集中的 W 就是 3 ， gbk 字符集中的 W 就是 2 ， ascii 字符集中的 W 就是 1。</li><li>M：对于变长类型 VARCHAR(M) 来说，这种类型表示能存储最多 M 个字符(注意是字符不是字节)，所以这个类型能表示的字符串最多占用的字节数就是 M×W 。</li><li>L：假设它实际存储的字符串占用的字节数是 L 。</li></ul><p>确定使用1个字节还是2个字节表示真正字符串占用的字节数的规则就是这样:</p><ol><li><p>如果 M×W &lt;&#x3D; 255 ，那么使用1个字节来表示真正字符串占用的字节数。</p></li><li><p>如果 M×W &gt; 255 ，则分为两种情况:</p><ul><li><p>如果 L &lt;&#x3D; 127 ，则用1个字节来表示真正字符串占用的字节数。 </p></li><li><p>如果 L &gt; 127 ，则用2个字节来表示真正字符串占用的字节数。</p></li></ul></li></ol><p>总结一下就是说:如果该可变字段允许存储的最大字节数( M×W )超过255字节并且真实存储的字节数( L ) 超过127字节，则使用2个字节，否则使用1个字节。</p><p>还有一点是，我们用两字节表示后，<strong>mysql怎么知道读到的当前的这个字节是整个长度的字节，还是整个长度的半个字节</strong>，mysql用标记位巧妙地化解了这个问题，也就是使用该字节的第一个二进制位作为标志位:如果该字节的第一个位为0，那 该字节就是一个单独的字段长度(使用一个字节表示不大于127的二进制的第一个位都为0)， 如果该字节的第一个位为1，那该字节就是半个字段长度。</p><p><strong>CHAR(M)列的存储格式</strong></p><p>我们这里还要补充一点，其实除了我们上面说的那几个字段类型Innodb会存储他们的字段长度，CHAR（M）类型也是有可能会的，上面没有的原因是因为我们在创建表时指定了字符集为ASCII，如果换成了其他变长编码的字符集那就会存粗它的长度了。</p><p>而且要知道变长字符集的 CHAR(M) 类型的列要求至少占用 M 个字节，比方说对于使用 utf8 字符集的 CHAR(10) 的列来说，该列存储的数据字节长度的范围是10~30个字节。即 使我们向该列中存储一个空字符串也会占用 10 个字节，这是怕将来更新该列的值的字节长度大于原有值的字节 长度而小于10个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，导致原有 的记录空间成为所谓的碎片</p><h4 id="NULL值列表："><a href="#NULL值列表：" class="headerlink" title="NULL值列表："></a>NULL值列表：</h4><p>这是Innodb对于节约空间的考虑，很容易理解，NULL值本身就不是很大的意义，只是一个标识而已，如果还在真实数据内存入一个个的NULL，可想是很占用存储的，所以 Compact 行格式把这些值为 NULL 的列统一管理起来，存储到NULL值列表中，具体的过程可以总结为：先统计、再用二进制位逆序表示、限制用整数个字节表示。详细的如下：</p><ol><li><p>首先统计表中允许存储 NULL 的列有哪些。我们知道主键列、被 NOT NULL 修饰的列都是不可以存储 NULL 值的，所以在统计的时候不会把这些列放入二进制位的。</p></li><li><p>如果表中没有允许存储 <strong>NULL</strong> 的列，则 NULL值列表也不存在了，否则将每个允许存储 NULL 的列对应一个二进制位.  ，二进制位按照列的顺序逆序排列，二进制位表示的意义如下:</p></li></ol><ul><li><p>二进制位的值为 1 时，代表该列的值为 NULL 。</p></li><li><p>二进制位的值为 0 时，代表该列的值不为 NULL 。</p></li></ul><ol start="3"><li>MySQL规定NULL值列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节 的高位补 0 。</li></ol><p>综上，我们上边那条记录的NULL值在页中的格式如下：</p><p><img src="https://img.tucang.cc/api/image/show/52668884eb9842908d3cca12fbc832d5"></p><h4 id="记录头信息："><a href="#记录头信息：" class="headerlink" title="记录头信息："></a>记录头信息：</h4><p>除了 变长字段长度列表 、 NULL值列表 之外，还有一个用于描述记录的 记录头信息 ，它是由固定的 5 个字节组成。 5 个字节也就是 40 个二进制位，不同的位代表不同的意思，如图:</p><p><img src="https://img.tucang.cc/api/image/show/4fdf8d58107695f2c481058a03c8768b"></p><p>居然这么多个字段，没事，我们先放一放，后面我们会详细的讲它。</p><h3 id="记录的真实数据："><a href="#记录的真实数据：" class="headerlink" title="记录的真实数据："></a>记录的真实数据：</h3><p>对于 record_format_demo 表来说， 记录的真实数据 除了 c1 、 c2 、 c3 、 c4 这几个我们自己定义的列的数据 以外， MySQL 会为每个记录默认的添加一些列(也称为 隐藏列 )，具体的列如下:</p><p><img src="https://img.tucang.cc/api/image/show/9d37565d9d227f922d7ce092fb25fefb"></p><p>这里需要提一下 InnoDB 表对主键的生成策略:优先使用用户自定义主键作为主键，如果用户没有定义主键，则 选取一个 Unique 键作为主键，如果表中连 Unique 键都没有定义的话，则 InnoDB 会为表默认添加一个名为row_id 的隐藏列作为主键。所以我们从上表中可以看出:InnoDB存储引擎会为每条记录都添加 <strong>transaction_id</strong> 和 <strong>roll_pointer</strong> 这两个列，但是 <strong>row_id</strong> 是可选的(在没有自定义主键以及Unique键的情况下才会添加该列)。 这些隐藏列的值不用我们操心， InnoDB 存储引擎会自己帮我们生成的</p><p>综上，我们上面最开始插入的两条数据应该是这样的：<br><img src="https://img.tucang.cc/api/image/show/ff85b76b5476e3d4f8687e0c11725258"></p><p>看这个图的时候我们需要注意几点:</p><ol><li>表 record_format_demo 使用的是 ascii 字符集，所以 0x61616161 就表示字符串 ‘aaaa’ ， 0x626262 就表 示字符串 ‘bbb’ ，以此类推。</li><li>注意第1条记录中 c3 列的值，它是 CHAR(10) 类型的，它实际存储的字符串是: ‘cc’ ，而 ascii 字符集中 的字节表示是 ‘0x6363’ ，虽然表示这个字符串只占用了2个字节，但整个 c3 列仍然占用了10个字节的空 间，除真实数据以外的8个字节的统统都用空格字符填充，空格字符在 ascii 字符集的表示就是 0x20 。</li><li>注意第2条记录中 c3 和 c4 列的值都为 NULL ，它们被存储在了前边的 NULL值列表 处，在记录的真实数据处 就不再冗余存储，从而节省存储空间。</li></ol><h2 id="行溢出数据："><a href="#行溢出数据：" class="headerlink" title="行溢出数据："></a>行溢出数据：</h2><h3 id="VARCHAR-M-最多存储多少数据"><a href="#VARCHAR-M-最多存储多少数据" class="headerlink" title="VARCHAR(M)最多存储多少数据"></a>VARCHAR(M)最多存储多少数据</h3><p>我们知道对于 VARCHAR(M) 类型的列最多可以占用 65535 个字节。其中的 M 代表该类型最多存储的字符数量，如果我们使用 ascii 字符集的话，一个字符就代表一个字节，我们可以存一个VARCHAR(65535)吗？显然是不行的，这个 65535 个字节除了列本身的数据之外，还包括一些 其他的数据，比如说我们为了存储一个 VARCHAR(M) 类型的列，其实需要占用3部分存储 空间:</p><ul><li>真实数据</li><li>真实数据占用字节的长度</li><li>NULL 值标识，如果该列有 NOT NULL 属性则可以没有这部分存储空间</li></ul><p>如果该 VARCHAR 类型的列没有 NOT NULL 属性，那最多只能存储 65532 个字节的数据，因为真实数据的长度可能占用2个字节， NULL 值标识需要占用1个字节。如果 VARCHAR 类型的列有 NOT NULL 属性，那最多只能存储 65533 个字节的数据，因为真实数据的长度可能占用 2个字节，不需要 NULL 值标识。</p><p>也就是说我们可以创建一个字符集为ASCII的VARCHAR(65532)或者VARCHAR(65533)的列。</p><p>那如果字符集不是ASCII而是变长编码的字符集呢？依你聪明的小脑袋应该猜到了，也就是会根据变长编码字符集需要的最大字节数来咯。比如在列的值允许为 NULL 的情况下， gbk 字符集表示一个字符最多需要 2 个字 节，那在该字符集下， M 的最大取值就是 32766 (也就是:65532&#x2F;2)</p><h3 id="记录中的数据太多造成的行溢出："><a href="#记录中的数据太多造成的行溢出：" class="headerlink" title="记录中的数据太多造成的行溢出："></a>记录中的数据太多造成的行溢出：</h3><p>首先解答为什么会行溢出：</p><p>MySQL 中磁盘和内存交互的基本单位是 页 ，也就是说 MySQL 是以 页为基本单位来管理存储空间的，我们 的记录都会被分配到某个页中存储。而一个页的大小一般是 16KB ，也就是 16384 字节，而一个 VARCHAR(M) 类 型的列就最多可以存储 65532 个字节，这样就可能造成一个页存放不了一条记录的尴尬情况。</p><p>在 Compact 和 Reduntant 行格式中，对于占用存储空间非常大的列，在 记录的真实数据处只会存储该列的一部分数据（768个字节），把剩余的数据分散存储在几个其他的页中，然后记录的真实数据处用20个字节存储指向这些页的地址 (当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数)，这些页也被称为溢出页，从而可以找到剩余数据所在的页。</p><p>最后需要注意的是，不只是 <strong>VARCHAR(M)</strong> 类型的列，其他的 <strong>TEXT</strong>、<strong>BLOB</strong> 类型的列在存储数据非常多的时候也会发生行溢出 。</p><h3 id="行溢出的临界值："><a href="#行溢出的临界值：" class="headerlink" title="行溢出的临界值："></a>行溢出的临界值：</h3><p>MySQL 中规定<strong>一个页中至少存放两行记录</strong>，原因后面讲索引的时候会讲到，主要还是高效的问题。</p><p>其实我们了解到这里就行了，也就是知道当一行数据字节数太多时会发生行溢出就行了，当然如果你想了解下怎么算这个值，也可以看看下面的。</p><p>假设我们创建了一个表，表中只有一列数据，我们往这个表中插入两条记录，每条记录最少插入多少字节的数据才会出现行溢出的现象呢?首先得分析一下页中的空间都是如何利用的。</p><p>每个页除了存放我们的记录以外，也需要存储一些额外的信息，乱七八糟的额外信息加起来需要<strong>136</strong> 个字节 的空间(现在只要知道这个数字就好了)，其他的空间都可以被用来存储记录。 每个记录需要的额外信息是 27 字节。这27个字节包括下边这些部分: </p><ul><li>2个字节用于存储真实数据的长度 </li><li>1个字节用于存储列是否是NULL值</li><li>5个字节大小的头信息</li><li>6个字节的 row_id 列</li><li>6个字节的 transaction_id 列</li><li>7个字节的 roll_pointer 列</li></ul><p>假设一个列中存储的数据字节数为n，那么发生行溢出现象时需要满足这个式子: 136 + 2×(27 + n) &gt; 16384，求解这个式子得出的解是: n &gt; 8098 </p><p>总之，其实也可以不用去管他，知道一行数据太大会发现行溢出就对了。</p><h2 id="Dynamic和Compressed行格式"><a href="#Dynamic和Compressed行格式" class="headerlink" title="Dynamic和Compressed行格式"></a>Dynamic和Compressed行格式</h2><p>下边要介绍另外两个行格式， Dynamic 和 Compressed 行格式，我现在使用的 MySQL 版本是 5.7 ，它的默认行格 式就是 Dynamic ，这俩行格式和Compact行格式挺像，只不过在处理 行溢出 数据时有点儿分歧，它们不会在记录的真实数据处存储字段真实数据的前 768 个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址。</p><p>Compressed 行格式和 Dynamic 还有不同的一点是， Compressed 行格式会采用压缩算法对页面进行压缩，以节省空间。</p>]]></content>
    
    
    <categories>
      
      <category>打怪升级</category>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>🧀Redis对象----五大对象</title>
    <link href="/2022/10/15/Redis%E5%AF%B9%E8%B1%A1----%E4%BA%94%E5%A4%A7%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/10/15/Redis%E5%AF%B9%E8%B1%A1----%E4%BA%94%E5%A4%A7%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>redis并没有直接使用这些数据结构来实现键值对数据库， 而是基于之前的数据结构创建了一个对象系统，让redis的键值对的底层数据结构更加灵活，公用对象节约内存，引用计数技术让控制更加便利。</p><span id="more"></span><h1 id="🧀Redis对象—-五大对象"><a href="#🧀Redis对象—-五大对象" class="headerlink" title="🧀Redis对象—-五大对象"></a>🧀Redis对象—-五大对象</h1><p><img src="https://img.tucang.cc/api/image/show/f4420603772a4db7912c1e31b24e45df"></p><blockquote><p>Redis 并没有直接使用这些数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个<mark>对象系统</mark>， 这个系统包含<strong>字符串对象</strong>、<strong>列表对象</strong>、<strong>哈希对象</strong>、<strong>集合对象</strong>和<strong>有序集合对象</strong>这五种类型的对象， 每种对象都用到了至少一种我们前面所介绍的数据结构。</p><p>通过这五种不同类型的对象， Redis 可以在执行命令之前， 根据对象的类型来判断一个对象是否可以执行给定的命令。 使用对象的另一个好处是， 我们可以<strong>针对不同的使用场景， 为对象设置多种不同的数据结构实现</strong>， 从而优化对象在不同场景下的使用效率。</p><p>除此之外， Redis 的对象系统还实现了基于<strong>引用计数</strong>技术的内存回收机制： 当程序不再使用某个对象的时候， 这个对象所占用的内存就会被自动释放； 另外， Redis 还通过引用计数技术实现了对象共享机制， 这一机制可以在适当的条件下， 通过让多个数据库键共享同一个对象来节约内存。</p><p>最后， Redis 的对象带有访问时间记录信息， 该信息可以用于计算数据库键的空转时长， 在服务器启用了 <code>maxmemory</code> 功能的情况下， 空转时长较大的那些键可能会优先被服务器删除</p></blockquote><p>在开始讲各个对象前，我们先来了解下各个对象的共同部分，即对象的存在形式。</p><h2 id="对象的类型与编码"><a href="#对象的类型与编码" class="headerlink" title="对象的类型与编码"></a>对象的类型与编码</h2><p>Redis 使用对象来表示数据库中的键和值， 每次当我们在 Redis 的数据库中新创建一个键值对时， 我们至少会创建两个对象， 一个对象用作键值对的键（键对象）， 另一个对象用作键值对的值（值对象）。那么对象的存在形式是什么呢？</p><p>在Redis 中的每个对象都由一个 <mark><code>redisObject</code></mark> 结构表示， 该结构中和保存数据有关的三个属性分别是 <code>type</code> 属性、 <code>encoding</code> 属性和 <code>ptr</code> 属性，还有几个属性后面再讲。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">redisObject</span> &#123;<br>    <span class="hljs-comment">// 类型</span><br>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 编码</span><br>    <span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 指向底层实现数据结构的指针</span><br>    <span class="hljs-type">void</span> *ptr;<br>    <span class="hljs-comment">// ...未完待续</span><br>&#125; robj;<br></code></pre></td></tr></table></figure><h3 id="类型（type）："><a href="#类型（type）：" class="headerlink" title="类型（type）："></a>类型（type）：</h3><p>该值就是redis用于区分不同对象的一个属性，很容易理解，它可以为以下的几个值之一</p><table><thead><tr><th align="left">类型常量</th><th align="left">对象的名称</th></tr></thead><tbody><tr><td align="left"><code>REDIS_STRING</code></td><td align="left">字符串对象</td></tr><tr><td align="left"><code>REDIS_LIST</code></td><td align="left">列表对象</td></tr><tr><td align="left"><code>REDIS_HASH</code></td><td align="left">哈希对象</td></tr><tr><td align="left"><code>REDIS_SET</code></td><td align="left">集合对象</td></tr><tr><td align="left"><code>REDIS_ZSET</code></td><td align="left">有序集合对象</td></tr></tbody></table><p>上面的这句话《它可以为以下的几个值之一》，键对象表示与他无关，其实在redis中键一直是字符串对象，（这也是我们在往数据库里添加键值对时，不管加不加双引号都可以的原因），值对象才可以拥有以上的所有类型，因此：</p><ul><li>当我们称呼一个数据库键为“字符串键”时， 我们指的是“这个数据库键<strong>所对应的值</strong>为字符串对象”；</li><li>当我们称呼一个键为“列表键”时， 我们指的是“这个数据库键<strong>所对应的值</strong>为列表对象”，</li></ul><p>诸如此类。</p><p>所以我们通过<code>TYPE</code>命令查看的都是键值对的值的对象类型。</p><h3 id="编码和底层实现："><a href="#编码和底层实现：" class="headerlink" title="编码和底层实现："></a>编码和底层实现：</h3><p>对象的 <code>ptr</code> 指针指向对象的底层实现数据结构， 而这些数据结构由对象的 <code>encoding</code> 属性决定。</p><p><code>encoding</code> 属性记录了对象所使用的编码， 也即是说这个对象使用了什么数据结构作为对象的底层实现， 这个属性的值可以是下表列出的常量的其中一个。</p><table><thead><tr><th align="left">编码常量</th><th align="left">编码所对应的底层数据结构</th></tr></thead><tbody><tr><td align="left"><code>REDIS_ENCODING_INT</code></td><td align="left"><code>long</code> 类型的整数</td></tr><tr><td align="left"><code>REDIS_ENCODING_EMBSTR</code></td><td align="left"><code>embstr</code> 编码的简单动态字符串</td></tr><tr><td align="left"><code>REDIS_ENCODING_RAW</code></td><td align="left">简单动态字符串</td></tr><tr><td align="left"><code>REDIS_ENCODING_HT</code></td><td align="left">字典</td></tr><tr><td align="left"><code>REDIS_ENCODING_LINKEDLIST</code></td><td align="left">双端链表</td></tr><tr><td align="left"><code>REDIS_ENCODING_ZIPLIST</code></td><td align="left">压缩列表</td></tr><tr><td align="left"><code>REDIS_ENCODING_INTSET</code></td><td align="left">整数集合</td></tr><tr><td align="left"><code>REDIS_ENCODING_SKIPLIST</code></td><td align="left">跳跃表和字典（较特别）</td></tr></tbody></table><p>下表是对象类型与相应的编码常量，可以大概浏览一下，知道一个对象由一个以上的底层数据结构实现就行。后面我们会对每个对象进行细讲</p><table><thead><tr><th align="left">类型</th><th align="left">编码</th><th align="left">对象</th></tr></thead><tbody><tr><td align="left"><code>REDIS_STRING</code></td><td align="left"><code>REDIS_ENCODING_INT</code></td><td align="left">使用整数值实现的字符串对象。</td></tr><tr><td align="left"><code>REDIS_STRING</code></td><td align="left"><code>REDIS_ENCODING_EMBSTR</code></td><td align="left">使用 <code>embstr</code> 编码的简单动态字符串实现的字符串对象。</td></tr><tr><td align="left"><code>REDIS_STRING</code></td><td align="left"><code>REDIS_ENCODING_RAW</code></td><td align="left">使用简单动态字符串实现的字符串对象。</td></tr><tr><td align="left"><code>REDIS_LIST</code></td><td align="left"><code>REDIS_ENCODING_QUICKLIST</code></td><td align="left">使用快速列表实现的列表对象。</td></tr><tr><td align="left"><code>REDIS_HASH</code></td><td align="left"><code>REDIS_ENCODING_ZIPLIST</code></td><td align="left">使用压缩列表实现的哈希对象。</td></tr><tr><td align="left"><code>REDIS_HASH</code></td><td align="left"><code>REDIS_ENCODING_HT</code></td><td align="left">使用字典实现的哈希对象。</td></tr><tr><td align="left"><code>REDIS_SET</code></td><td align="left"><code>REDIS_ENCODING_INTSET</code></td><td align="left">使用整数集合实现的集合对象。</td></tr><tr><td align="left"><code>REDIS_SET</code></td><td align="left"><code>REDIS_ENCODING_HT</code></td><td align="left">使用字典实现的集合对象。</td></tr><tr><td align="left"><code>REDIS_ZSET</code></td><td align="left"><code>REDIS_ENCODING_ZIPLIST</code></td><td align="left">使用压缩列表实现的有序集合对象。</td></tr><tr><td align="left"><code>REDIS_ZSET</code></td><td align="left"><code>REDIS_ENCODING_SKIPLIST</code></td><td align="left">使用跳跃表和字典实现的有序集合对象。</td></tr></tbody></table><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h3><p>字符串对象的编码可以是 <code>int</code> 、 <code>raw</code> 或者 <code>embstr</code> 。</p><ol><li><p>如果一个字符串对象保存的是整数值， 并且这个整数值可以用 <code>long</code> 类型来表示， 那么字符串对象会将整数值保存在字符串对象结构的 <code>ptr</code>属性里面（将 <code>void*</code> 转换成 <code>long</code> ）， 并将字符串对象的编码设置为 <code>int</code> 。</p></li><li><p>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度大于 <code>39</code> 字节， 那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值， 并将对象的编码设置为 <code>raw</code> 。</p></li><li><p>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度小于等于 <code>39</code> 字节， 那么字符串对象将使用 <code>embstr</code> 编码的方式来保存这个字符串值。</p><p><code>embstr</code> 编码是专门用于保存短字符串的一种优化编码方式， 这种编码和 <code>raw</code> 编码一样， 都使用 <code>redisObject</code> 结构和 <code>sdshdr</code> 结构来表示字符串对象， 但 <code>raw</code> 编码会调用两次内存分配函数来分别创建 <code>redisObject</code> 结构和 <code>sdshdr</code> 结构， 而 <code>embstr</code> 编码则通过调用一次内存分配函数来分配一块连续的空间， 空间中依次包含 <code>redisObject</code> 和 <code>sdshdr</code> 两个结构， 如下图所示。</p></li></ol><p><img src="https://img.tucang.cc/api/image/show/8b9ec49d4f500d38e815d32231e24490"></p><p><code>embstr</code> 编码的字符串对象在执行命令时， 产生的效果和 <code>raw</code> 编码的字符串对象执行命令时产生的效果是相同的， 但使用 <code>embstr</code> 编码的字符串对象来保存短字符串值有以下好处：</p><ol><li><code>embstr</code> 编码将创建字符串对象所需的内存分配次数从 <code>raw</code> 编码的两次降低为一次。</li><li>释放 <code>embstr</code> 编码的字符串对象只需要调用一次内存释放函数， 而释放 <code>raw</code> 编码的字符串对象需要调用两次内存释放函数。</li><li>因为 <code>embstr</code> 编码的字符串对象的所有数据都保存在一块连续的内存里面， 所以这种编码的字符串对象比起 <code>raw</code> 编码的字符串对象能够更好地利用缓存带来的优势。</li><li>可以用 <code>long double</code> 类型表示的浮点数在 Redis 中也是作为字符串值来保存的： 如果我们要保存一个浮点数到字符串对象里面， 那么程序会先将这个浮点数转换成字符串值， 然后再保存起转换所得的字符串值。然后要使用该值进行数值运算操作时，又会将它专为浮点类型，处理完后又转为字符串类型存入数据库中</li></ol><p>存储的值类型与编码类型可以总结如下表：</p><table><thead><tr><th align="left">值</th><th align="left">编码</th></tr></thead><tbody><tr><td align="left">可以用 <code>long</code> 类型保存的整数。</td><td align="left"><code>int</code></td></tr><tr><td align="left">可以用 <code>long double</code> 类型保存的浮点数。</td><td align="left"><code>embstr</code> 或者 <code>raw</code></td></tr><tr><td align="left">字符串值， 或者因为长度太大而没办法用 <code>long</code> 类型表示的整数， 又或者因为长度太大而没办法用 <code>long double</code> 类型表示的浮点数。</td><td align="left"><code>embstr</code> 或者 <code>raw</code></td></tr></tbody></table><h3 id="编码转换："><a href="#编码转换：" class="headerlink" title="编码转换："></a>编码转换：</h3><p><strong><code>int</code> 编码的字符串对象和 <code>embstr</code> 编码的字符串对象在条件满足的情况下， 会被转换为 <code>raw</code> 编码的字符串对象。</strong></p><p>对于 <code>int</code> 编码的字符串对象来说， 如果我们向对象执行了一些命令， 使得这个对象保存的不再是整数值， 而是一个字符串值， 那么字符串对象的编码将从 <code>int</code> 变为 <code>raw</code> 。如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">redis&gt; </span><span class="language-bash">SET number 10086</span><br>OK<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">redis&gt; </span><span class="language-bash">OBJECT ENCODING number</span><br>&quot;int&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">redis&gt; </span><span class="language-bash">APPEND number <span class="hljs-string">&quot; is a good number!&quot;</span></span><br>(integer) 23<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">redis&gt; </span><span class="language-bash">GET number</span><br>&quot;10086 is a good number!&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">redis&gt; </span><span class="language-bash">OBJECT ENCODING number</span><br>&quot;raw&quot;<br></code></pre></td></tr></table></figure><p>另外， 因为 Redis 没有为 <code>embstr</code> 编码的字符串对象编写任何相应的修改程序，所以 <code>embstr</code> 编码的字符串对象在执行任何修改命令时， 程序会先将对象的编码从 <code>embstr</code> 转换成 <code>raw</code> ， 然后再执行修改命令； 因为这个原因， <code>embstr</code> 编码的字符串对象在执行修改命令之后， 总会变成一个 <code>raw</code>编码的字符串对象。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">redis&gt; </span><span class="language-bash">SET msg <span class="hljs-string">&quot;hello world&quot;</span></span><br>OK<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">redis&gt; </span><span class="language-bash">OBJECT ENCODING msg</span><br>&quot;embstr&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">redis&gt; </span><span class="language-bash">APPEND msg <span class="hljs-string">&quot; again!&quot;</span></span><br>(integer) 18<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">redis&gt; </span><span class="language-bash">OBJECT ENCODING msg</span><br>&quot;raw&quot;<br></code></pre></td></tr></table></figure><h2 id="LIst"><a href="#LIst" class="headerlink" title="LIst"></a>LIst</h2><h3 id="encoding-1"><a href="#encoding-1" class="headerlink" title="encoding"></a>encoding</h3><p>列表对象的编码之前可以是 <code>ziplist</code> 或者 <code>linkedlist</code> 。现在改了，全部都用<code>quicklist</code>。</p><p>所以列表对象就没有像上面的String对象有选择相应的encoing和转换的烦恼。我们改为介绍下<strong>快速列表</strong>。</p><h3 id="快速列表："><a href="#快速列表：" class="headerlink" title="快速列表："></a>快速列表：</h3><p><strong>为什么要专门设计一个 quicklist 来重新定义呢？</strong></p><p>redis的注释解释到：</p><blockquote><p>quicklist.c - A doubly linked list of ziplists (一个ziplist的双向链表)</p></blockquote><p>我们再看看它的结构：</p><p><img src="https://img.tucang.cc/api/image/show/634337d5bbee2302cbda1404a7c254c4"></p><p>现在明白了吧，redis并没有放弃<code>ziplist</code> 和 <code>linkedlist</code>，<code>quicklist</code>其实就是一个以 <code>ziplist</code>为节点（quicklistNode中存放指向 ziplist 的指针）的<code>linkedlist</code>。</p><p>现在我们能回答我们最初的问题了，quicklist 的结构为什么这样设计呢？答案是<code>quicklist</code> 平衡了 <code>ziplist</code> 和<code>linkedlist</code>的优缺点：</p><ul><li><p>双向链表方便在于在表的两端进行 push 和 pop 操作，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片，不利于内存管理。</p></li><li><p>ziplist 由于是一整块连续内存，所以存储效率很高。但是，它不利于修改操作，每次数据变动都会引发一次内存的 realloc。特别是当 ziplist 长度很长的时候，一次 realloc 可能会导致大批量的数据拷贝，进一步降低性能。</p></li></ul><p>那么现在的问题是<code>quicklistNode</code>中的<code>ziplist</code>该多大比较合适呢？毕竟太小就变回<code>quicklist</code>，太大对每个节点中<code>ziplist</code>的操作又要降低性能，所以这个长度肯定是一个平衡值，它是 redis 提供的一个选项配置，默认是 -2，来看下官方说明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-5: max size: 64 Kb  -- not recommended <span class="hljs-keyword">for</span> normal workloads</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-4: max size: 32 Kb  -- not recommended</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-3: max size: 16 Kb  -- probably not recommended</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-2: max size: 8 Kb   -- good</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-1: max size: 4 Kb   -- good</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Positive numbers mean store up to _exactly_ that number of elements</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">per list node.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">but <span class="hljs-keyword">if</span> your use <span class="hljs-keyword">case</span> is unique, adjust the settings as necessary.</span><br>list-max-ziplist-size -2<br></code></pre></td></tr></table></figure><p>即一般整个节点为8kb大小</p><h4 id="源码字段解释："><a href="#源码字段解释：" class="headerlink" title="源码字段解释："></a>源码字段解释：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">quicklistNode</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">quicklistNode</span> *prev; <span class="hljs-comment">//上一个node节点</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">quicklistNode</span> *next; <span class="hljs-comment">//下一个node</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *zl;            <span class="hljs-comment">//保存的数据 压缩前ziplist 压缩后压缩的数据</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sz;             <span class="hljs-comment">/* ziplist size in bytes */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count : <span class="hljs-number">16</span>;     <span class="hljs-comment">/* count of items in ziplist */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> encoding : <span class="hljs-number">2</span>;   <span class="hljs-comment">/* RAW==1 or LZF==2 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> container : <span class="hljs-number">2</span>;  <span class="hljs-comment">/* NONE==1 or ZIPLIST==2 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> recompress : <span class="hljs-number">1</span>; <span class="hljs-comment">/* was this node previous compressed? */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> attempted_compress : <span class="hljs-number">1</span>; <span class="hljs-comment">/* node can&#x27;t compress; too small */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> extra : <span class="hljs-number">10</span>; <span class="hljs-comment">/* more bits to steal for future usage */</span><br>&#125; quicklistNode;<br></code></pre></td></tr></table></figure><ul><li>prev: 指向链表前一个节点的指针。</li><li>next: 指向链表后一个节点的指针。</li><li>zl: 数据指针。如果当前节点的数据没有压缩，那么它指向一个ziplist结构；否则，它指向一个quicklistLZF结构。</li><li>sz: 表示zl指向的ziplist的总大小（包括<code>zlbytes</code>, <code>zltail</code>, <code>zllen</code>, <code>zlend</code>和各个数据项）。需要注意的是：如果ziplist被压缩了，那么这个sz的值仍然是压缩前的ziplist大小。</li><li>count: 表示ziplist里面包含的数据项个数。这个字段只有16bit。</li><li>encoding: 表示ziplist是否压缩了（以及用了哪个压缩算法）。目前只有两种取值：2表示被压缩了（而且用的是LZF压缩算法），1表示没有压缩。</li><li>container: 是一个预留字段。本来设计是用来表明一个quicklist节点下面是直接存数据，还是使用ziplist存数据，或者用其它的结构来存数据（用作一个数据容器，所以叫container）。但是，在目前的实现中，这个值是一个固定的值2，表示使用ziplist作为数据容器。</li><li>recompress: 当我们使用类似lindex这样的命令查看了某一项本来压缩的数据时，需要把数据暂时解压，这时就设置recompress&#x3D;1做一个标记，等有机会再把数据重新压缩。</li><li>attempted_compress: 这个值只对Redis的自动化测试程序有用。我们不用管它。</li><li>extra: 其它扩展字段。目前Redis的实现里也没用上。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">quicklistLZF</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sz; <span class="hljs-comment">/* LZF size in bytes*/</span><br>    <span class="hljs-type">char</span> compressed[];<br>&#125; quicklistLZF;<br></code></pre></td></tr></table></figure><ul><li>sz: 表示压缩后的ziplist大小。</li><li>compressed: 是个柔性数组（<a href="https://en.wikipedia.org/wiki/Flexible_array_member">flexible array member</a>），存放压缩后的ziplist字节数组。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">quicklist</span> &#123;<br>    quicklistNode *head;<br>    quicklistNode *tail;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> count;        <span class="hljs-comment">/* total count of all entries in all ziplists */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len;          <span class="hljs-comment">/* number of quicklistNodes */</span><br>    <span class="hljs-type">int</span> fill : QL_FILL_BITS;              <span class="hljs-comment">/* fill factor for individual nodes */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> compress : QL_COMP_BITS; <span class="hljs-comment">/* depth of end nodes not to compress;0=off */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bookmark_count: QL_BM_BITS;<br>    quicklistBookmark bookmarks[];<br>&#125; quicklist;<br></code></pre></td></tr></table></figure><ul><li>head: 指向头节点（左侧第一个节点）的指针。</li><li>tail: 指向尾节点（右侧第一个节点）的指针。</li><li>count: 所有ziplist数据项的个数总和。</li><li>len: quicklist节点的个数。</li><li>fill: 16bit，ziplist大小设置，存放<code>list-max-ziplist-size</code>参数的值。</li><li>compress: 16bit，节点压缩深度设置，存放<code>list-compress-depth</code>参数的值。</li></ul><h4 id="压缩机制："><a href="#压缩机制：" class="headerlink" title="压缩机制："></a>压缩机制：</h4><p>在上面的源码字段解释部分，我们提到了<code>quicklistLZF</code>，可能你有疑惑，这是什么东西？什么时候会去压缩？其实是 redis 为 quicklist 提供了一套压缩机制。</p><p>当 quicklist 很长的时候，最容易被访问的很可能是两端的数据，中间的数据被访问的频率比较低（访问起来性能也很低）。如果应用场景符合这个特点，redis 还提供了一个选项，能够把中间的数据节点进行压缩，从而进一步节省内存空间。Redis的配置参数 <code>list-compress-depth</code> 就是用来完成这个设置的。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xl">列表也可以被压缩。<br># 压缩深度指的是列表两侧开始不需要 ziplist 的节点的深度（下面会解释）。<br>#为了执行快速的 push/pop 操作，列表的头和尾通常不压缩。<br># 设置如下:<br># <span class="hljs-number">0</span>: 禁用压缩机制<br># <span class="hljs-number">1</span>: 压缩深度 <span class="hljs-number">1</span> 表示压缩除了头和尾之外的所有内部节点。例如结构：<br>#    [<span class="hljs-function"><span class="hljs-title">head</span>]-&gt;</span><span class="hljs-function"><span class="hljs-title">node</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">node</span>-&gt;</span>...-&gt;<span class="hljs-function"><span class="hljs-title">node</span>-&gt;</span>[tail]<br>#    因为[head], [tail]永远不会被压缩，它们直接的 node 都后被压缩。<br># <span class="hljs-number">2</span>: [<span class="hljs-function"><span class="hljs-title">head</span>]-&gt;</span>[<span class="hljs-function"><span class="hljs-title">next</span>]-&gt;</span><span class="hljs-function"><span class="hljs-title">node</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">node</span>-&gt;</span>...-&gt;<span class="hljs-function"><span class="hljs-title">node</span>-&gt;</span>[<span class="hljs-function"><span class="hljs-title">prev</span>]-&gt;</span>[tail]<br>#    <span class="hljs-number">2</span> 表示不压缩 <span class="hljs-function"><span class="hljs-title">head</span>，head-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>，tail-&gt;</span>prev 和 tail, 它们之前的 node 都压缩。<br># <span class="hljs-number">3</span>: [<span class="hljs-function"><span class="hljs-title">head</span>]-&gt;</span>[<span class="hljs-function"><span class="hljs-title">next</span>]-&gt;</span>[<span class="hljs-function"><span class="hljs-title">next</span>]-&gt;</span><span class="hljs-function"><span class="hljs-title">node</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">node</span>-&gt;</span>...-&gt;<span class="hljs-function"><span class="hljs-title">node</span>-&gt;</span>[<span class="hljs-function"><span class="hljs-title">prev</span>]-&gt;</span>[<span class="hljs-function"><span class="hljs-title">prev</span>]-&gt;</span>[tail]<br># 以此类推...<br>list-compress-depth <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>这个参数默认是 0 也就是不压缩，Redis对于 quicklist 内部节点的压缩算法，采用的 LZF —— 一种无损压缩算法，有兴趣的可以看下 <a href="https://link.juejin.cn/?target=https://zh.wikipedia.org/wiki/LZFSE">zh.wikipedia.org&#x2F;wiki&#x2F;LZFSE</a>。</p><h4 id="常见操作解析："><a href="#常见操作解析：" class="headerlink" title="常见操作解析："></a>常见操作解析：</h4><p><strong>头插和尾插</strong></p><p>总结为先判断了是否能直接在当前头|尾节点能插入，如果能就直接插入到对应的ziplist里，否则就需要新建一个新节点再操作了。</p><p><strong>特定位置插入</strong></p><ul><li>如果当前被插入节点不满，直接插入。</li><li>如果当前被插入节点是满的，要插入的位置是当前节点的尾部，且后一个节点有空间，那就插到后一个节点的头部。</li><li>如果当前被插入节点是满的，要插入的位置是当前节点的头部，且前一个节点有空间，那就插到前一个节点的尾部。  </li><li>如果当前被插入节点是满的，前后节点也都是满的，要插入的位置是当前节点的头部或者尾部，那就创建一个新的节点插进去。  </li><li>否则，当前节点是满的，且要插入的位置在当前节点的中间位置，我们需要把当前节点分裂成两个新节点，然后再插入。</li></ul><p>相关源码分析可以看这<a href="https://cloud.tencent.com/developer/article/1777876">Redis源码剖析之快速列表(quicklist)</a></p><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><h3 id="encoding-2"><a href="#encoding-2" class="headerlink" title="encoding"></a>encoding</h3><p>哈希对象的编码可以是 <code>ziplist</code> 或者 <code>hashtable</code> 。</p><ol><li><p><code>ziplist</code> 编码的哈希对象使用压缩列表作为底层实现， 每当有新的键值对要加入到哈希对象时， 程序会先将保存了键的压缩列表节点推入到压缩列表表尾， 然后再将保存了值的压缩列表节点推入到压缩列表表尾， 因此保存了同一键值对的两个节点总是紧挨在一起， 保存键的节点在前， 保存值的节点在后。</p></li><li><p><code>hashtable</code> 编码的哈希对象使用字典作为底层实现， 哈希对象中的每个键值对都使用一个字典键值对来保存。</p></li></ol><h3 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h3><p>当哈希对象可以同时满足以下两个条件时， 哈希对象使用 <code>ziplist</code> 编码：</p><ol><li>哈希对象保存的所有键值对的键和值的字符串长度都小于 <code>64</code> 字节；</li><li>哈希对象保存的键值对数量小于 <code>512</code> 个；</li></ol><p>不能满足这两个条件的哈希对象需要使用 <code>hashtable</code> 编码。</p><p>对于使用 <code>ziplist</code> 编码的列表对象来说， 当使用 <code>ziplist</code> 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在压缩列表里的所有键值对都会被转移并保存到字典里面， 对象的编码也会从 <code>ziplist</code> 变为 <code>hashtable</code> 。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="encoding-3"><a href="#encoding-3" class="headerlink" title="encoding"></a>encoding</h3><p>集合对象的编码可以是 <code>intset</code> 或者 <code>hashtable</code> 。</p><ol><li><p><code>intset</code> 编码的集合对象使用整数集合作为底层实现， 集合对象包含的所有元素都被保存在整数集合的contents数组里面。</p></li><li><p>另一方面， <code>hashtable</code> 编码的集合对象使用字典作为底层实现， 字典的每个键都是一个字符串对象， 每个字符串对象包含了一个集合元素， 而字典的值则全部被设置为 <code>NULL</code> 。</p></li></ol><h3 id="编码转换-1"><a href="#编码转换-1" class="headerlink" title="编码转换"></a>编码转换</h3><p>当集合对象可以同时满足以下两个条件时， 对象使用 <code>intset</code> 编码：</p><ol><li>集合对象保存的所有元素都是整数值；</li><li>集合对象保存的元素数量不超过 <code>512</code> 个；（可通过set-max-intset-entries修改）</li></ol><p>不能满足这两个条件的集合对象需要使用 <code>hashtable</code> 编码。</p><p>对于使用 <code>intset</code> 编码的集合对象来说， 当使用 <code>intset</code> 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在整数集合中的所有元素都会被转移并保存到字典里面， 并且对象的编码也会从 <code>intset</code> 变为 <code>hashtable</code> 。</p><h2 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h2><h3 id="encoding-4"><a href="#encoding-4" class="headerlink" title="encoding"></a>encoding</h3><p>有序集合的编码可以是 <code>ziplist</code> 或者 <code>skiplist</code> </p><ol><li><p><code>ziplist</code> 编码的有序集合对象使用压缩列表作为底层实现， 每个集合元素使用两个紧挨在一起的压缩列表节点来保存， 第一个节点保存元素的成员（member）， 而第二个元素则保存元素的分值（score）。</p><p>压缩列表内的集合元素按分值从小到大进行排序， 分值较小的元素被放置在靠近表头的方向， 而分值较大的元素则被放置在靠近表尾的方向。（对于被Zset用来做底层实现的ziplist的特性吧）</p></li><li><p><strong><code>skiplist</code> 编码的有序集合对象使用 <code>zset</code> 结构作为底层实现， 一个 <code>zset</code> 结构同时包含一个字典和一个跳跃表：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zset</span> &#123;<br>    zskiplist *zsl;<br>    dict *dict;<br>&#125; zset;<br></code></pre></td></tr></table></figure><p><code>zset</code> 结构中的 <code>zsl</code> 跳跃表按分值从小到大保存了所有集合元素， 每个跳跃表节点都保存了一个集合元素： 跳跃表节点的 <code>object</code> 属性保存了元素的成员， 而跳跃表节点的 <code>score</code> 属性则保存了元素的分值。 通过这个跳跃表， 程序可以对有序集合进行范围型操作， 比如 ZRANK、 ZRANGE 等命令就是基于跳跃表 API 来实现的。</p><p>除此之外， <code>zset</code> 结构中的 <code>dict</code> 字典为有序集合创建了一个从成员到分值的映射， 字典中的每个键值对都保存了一个集合元素： <strong>字典的键保存了元素的成员， 而字典的值则保存了元素的分值</strong>。 通过这个字典， 程序可以用 O(1) 复杂度查找给定成员的分值， ZSCORE 命令就是根据这一特性实现的， 而很多其他有序集合命令都在实现的内部用到了这一特性。</p></li></ol><p>有序集合每个元素的成员都是一个字符串对象， 而每个元素的分值都是一个 <code>double</code> 类型的浮点数。 值得一提的是， 虽然 <code>zset</code> 结构同时使用跳跃表和字典来保存有序集合元素， <strong>但这两种数据结构都会通过指针来共享相同元素的成员和分值</strong>， 所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值， 也不会因此而浪费额外的内存。</p><h3 id="编码转换：-1"><a href="#编码转换：-1" class="headerlink" title="编码转换："></a>编码转换：</h3><p>当有序集合对象可以同时满足以下两个条件时， 对象使用 <code>ziplist</code> 编码：</p><ol><li>有序集合保存的元素数量小于 <code>128</code> 个；</li><li>有序集合保存的所有元素成员的长度都小于 <code>64</code> 字节；</li></ol><p>不能满足以上两个条件的有序集合对象将使用 <code>skiplist</code> 编码。</p><p>对于使用 <code>ziplist</code> 编码的有序集合对象来说， 当使用 <code>ziplist</code> 编码所需的两个条件中的任意一个不能被满足时， 程序就会执行编码转换操作， 将原本储存在压缩列表里面的所有集合元素转移到 <code>zset</code> 结构里面， 并将对象的编码从 <code>ziplist</code> 改为 <code>skiplist</code> 。</p>]]></content>
    
    
    <categories>
      
      <category>打怪升级</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>🥞Redis数据结构----跳跃表、整数集合、压缩列表</title>
    <link href="/2022/10/15/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84----%E8%B7%B3%E8%B7%83%E8%A1%A8%E3%80%81%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E3%80%81%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/"/>
    <url>/2022/10/15/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84----%E8%B7%B3%E8%B7%83%E8%A1%A8%E3%80%81%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E3%80%81%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>Redis另外几个重要的数据结构，数据结构完结篇🎉</p><span id="more"></span><h1 id="🥞Redis数据结构—-跳跃表、整数集合、压缩列表"><a href="#🥞Redis数据结构—-跳跃表、整数集合、压缩列表" class="headerlink" title="🥞Redis数据结构—-跳跃表、整数集合、压缩列表"></a>🥞Redis数据结构—-跳跃表、整数集合、压缩列表</h1><p><img src="https://img.tucang.cc/api/image/show/6bc2e3a8cabd54c2423d9499c8001e58"></p><h2 id="跳跃表："><a href="#跳跃表：" class="headerlink" title="跳跃表："></a>跳跃表：</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><blockquote><p>跳跃表是一种有序的数据结构，通过在每个节点维护指向其他节点的指针，以达到快速访问节点的目的，时间复杂度平均能达到O(log<sub>n</sub>)，最坏为n，介于它是有序的特点，也提供了对节点进行范围操作的能力。</p><p>跳跃表做为有序集合的底层实现之一，当有序集合中的对象较多，又或者有序集合中元素的成员是比较长的字符串时，就会使用跳跃表做为底层实现。</p><p>和前几个数据结构在redis中被广泛使用不同的是，除了作为有序集合的底层实现，跳跃表就还使用在一个地方：在集群节点中用作内部数据结构</p></blockquote><h4 id="关于跳跃表："><a href="#关于跳跃表：" class="headerlink" title="关于跳跃表："></a>关于跳跃表：</h4><p><strong>介绍下跳跃表</strong></p><p><strong>前提：跳表处理的是有序的链表，所以我们先看个不能再普通了的有序列表（一般是双向链表）</strong></p><p><img src="https://img.tucang.cc/api/image/show/ee425864135d9517429a53a28efeb998"></p><p>如果我们想查找某个数，只能遍历链表逐个比对，时间复杂度 ，插入和删除操作都一样。</p><p>为了提高查找效率，我们对链表做个”索引“</p><p><img src="https://img.tucang.cc/api/image/show/fc8f619b822bc671bbd242cdb563a26d"></p><p>像这样，我们每隔一个节点取一个数据作为索引节点（或者增加一个指针），比如我们要找 31 直接在索引链表就找到了（遍历 3 次），如果找 16 的话，在遍历到 31的时候，发现大于目标节点，就跳到下一层(原数据层)，接着遍历~ (蓝线表示搜索路径)</p><blockquote><p>可能你会以为，就这，不加索引我找16也是4次。把数据量扩大看看～～</p></blockquote><p><img src="https://img.tucang.cc/api/image/show/541f1f32de180fb5fab377cf90012b07"></p><p>每加一层索引，我们搜索的时间复杂度就降为原来的</p><p>加了几层索引，查找一个节点需要遍历的节点个数明线减少了，效率提高不少，bingo~</p><p>有没有似曾相识的感觉，像不像二分查找或者二叉搜索树，通过索引来跳过大量的节点，从而提高搜索效率。</p><p>这样的多层链表结构，就是『<strong>跳表</strong>』了</p><p><strong>跳表索引动态更新</strong></p><p>我们上边建立索引层都是下层节点个数的 1&#x2F;2，高层索引的节点数就是 2 个，但是我们随意插入或者删除一个原有链表的节点，这个比例就肯定会被破坏。</p><p><img src="https://img.tucang.cc/api/image/show/9e20b688a12591c828a9eba75bc49902"></p><p>作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中节点多了，索引节点就相应地增加一些，避免复杂度退化。</p><p>如果重建索引的话，效率就不能保证了。跳表是通过随机函数来维护前面提到的“平衡性”</p><p>redis正是如此，它的实现方法很妙，等下面关于redis中跳跃表实现的内容读完再来体会体会。</p><h3 id="跳跃表的实现："><a href="#跳跃表的实现：" class="headerlink" title="跳跃表的实现："></a>跳跃表的实现：</h3><p>Redis 的跳跃表由 <code>redis.h/zskiplistNode</code> 和 <code>redis.h/zskiplist</code> 两个结构定义， 其中 <code>zskiplistNode</code> 结构用于表示跳跃表节点， 而 <code>zskiplist</code> 结构则用于保存跳跃表节点的相关信息， 比如节点的数量， 以及指向表头节点和表尾节点的指针， 最大的层数。</p><p>跳跃表的实现如下图：</p><p><img src="https://img.tucang.cc/api/image/show/e2d073eeea52f11a3e6ee644e4a327b8"></p><p>最左边的结构为zskiplist，它的4个结构描述如下：</p><ul><li>header：指向头节点的指针</li><li>tail：指向尾节点的指针</li><li>level: 当前跳跃表节点中最大的层数</li><li>length: 当前跳跃表的节点个数</li></ul><p>后边的几个则为zskiplistNode，它分为4个部分，描述如下：</p><ul><li>层(level)：节点中用 <code>L1</code> 、 <code>L2</code> 、 <code>L3</code> 等字样标记节点的各个层，每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。</li><li>后退（backward）指针：节点中用 <code>BW</code> 字样标记节点的后退指针，它指向位于当前节点的前一个节点。</li><li>分值（score）：各个节点中的 <code>1.0</code> 、 <code>2.0</code> 和 <code>3.0</code> 是节点所保存的分值。</li><li>成员对象（obj）：各个节点中的 <code>o1</code> 、 <code>o2</code> 和 <code>o3</code> 是节点所保存的成员对象。</li></ul><p>下面我们再对这两个结构进行详细讨论：</p><h4 id="跳跃表节点："><a href="#跳跃表节点：" class="headerlink" title="跳跃表节点："></a>跳跃表节点：</h4><p>跳跃表节点的实现由 <code>redis.h/zskiplistNode</code> 结构定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistNode</span> &#123;<br><br>    <span class="hljs-comment">// 后退指针</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistNode</span> *backward;<br>    <span class="hljs-comment">// 分值</span><br>    <span class="hljs-type">double</span> score;<br>    <span class="hljs-comment">// 成员对象</span><br>    robj *obj;<br>    <span class="hljs-comment">// 层</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistLevel</span> &#123;<br>        <span class="hljs-comment">// 前进指针</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistNode</span> *forward;<br>        <span class="hljs-comment">// 跨度</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> span;<br>    &#125; level[];<br><br>&#125; zskiplistNode;<br></code></pre></td></tr></table></figure><p><strong>先说level</strong></p><ol><li><p>跳跃表节点的 <code>level</code> 数组可以包含多个元素， 每个元素都包含一个指向其他节点的指针， 程序可以通过这些层来加快访问其他节点的速度， 一般来说， 层的数量越多， 访问其他节点的速度就越快。</p><p>每次创建一个新跳跃表节点的时候， 程序都根据幂次定律 （<a href="http://en.wikipedia.org/wiki/Power_law">power law</a>，越大的数出现的概率越小） 随机生成一个介于 <code>1</code> 和 <code>32</code> 之间的值作为 <code>level</code> 数组的大小， 这个大小就是层的“高度”。<strong>还记得我们上面说的跳跃表索引动态更新的随机函数吗？就是这了</strong>，通过这样就能均匀的在每一层加索引，而且越高层的索引中元素个数越少，恩，很妙～</p></li><li><p>每一个level中两个结构：<code>forward</code>前进指针，指向在同一层上的下一个节点。<code>span</code>，记录了通过该前进指针到达下一个节点的跨度，跨度被用来计算排位（rank）： 在查找某个节点的过程中， 将沿途访问过的所有层的跨度累计起来， 得到的结果就是目标节点在跳跃表中的排位。</p></li></ol><p><strong>BW后退指针</strong></p><p>节点的后退指针（<code>backward</code> 属性）用于从表尾向表头方向访问节点： 跟可以一次跳过多个节点的前进指针不同， 因为每个节点只有一个后退指针， 所以每次只能后退至前一个节点。</p><p><strong>分值和成员</strong></p><p>节点的分值（<code>score</code> 属性）是一个 <code>double</code> 类型的浮点数， 跳跃表中的所有节点都按分值从小到大来排序。</p><p>节点的成员对象（<code>obj</code> 属性）是一个指针， 它指向一个字符串对象， 而字符串对象则保存着一个 SDS 值。</p><p>在同一个跳跃表中， 各个节点保存的成员对象必须是唯一的， 但是多个节点保存的分值却可以是相同的： 分值相同的节点将按照成员对象在字典序中的大小来进行排序，</p><h4 id="跳跃表：-1"><a href="#跳跃表：-1" class="headerlink" title="跳跃表："></a>跳跃表：</h4><p>虽然仅靠多个跳跃表节点就可以组成一个跳跃表。</p><p>但通过使用一个 <code>zskiplist</code> 结构来持有这些节点， 程序可以更方便地对整个跳跃表进行处理， 比如快速访问跳跃表的表头节点和表尾节点， 又或者快速地获取跳跃表节点的数量（也即是跳跃表的长度）等信息</p><p><code>zskiplist</code> 结构的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplist</span> &#123;<br>    <span class="hljs-comment">// 表头节点和表尾节点</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistNode</span> *header, *tail;<br>    <span class="hljs-comment">// 表中节点的数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length;<br>    <span class="hljs-comment">// 表中层数最大的节点的层数</span><br>    <span class="hljs-type">int</span> level;<br>&#125; zskiplist;<br></code></pre></td></tr></table></figure><p><code>header</code> 和 <code>tail</code> 指针分别指向跳跃表的表头和表尾节点， 通过这两个指针， 程序定位表头节点和表尾节点的复杂度为 O(1) 。</p><p>通过使用 <code>length</code> 属性来记录节点的数量， 程序可以在 O(1) 复杂度内返回跳跃表的长度。</p><p><code>level</code> 属性则用于在 O(1) 复杂度内获取跳跃表中层高最大的那个节点的层数量， 注意表头节点的层高并不计算在内。</p><h2 id="整数集合："><a href="#整数集合：" class="headerlink" title="整数集合："></a>整数集合：</h2><h3 id="简介：-1"><a href="#简介：-1" class="headerlink" title="简介："></a>简介：</h3><blockquote><p>整数集合（intset）是集合键的底层实现之一： 当一个集合只包含整数值元素， 并且这个集合的元素数量不多时， Redis 就会使用整数集合作为集合键的底层实现。</p></blockquote><h3 id="整数集合的实现："><a href="#整数集合的实现：" class="headerlink" title="整数集合的实现："></a>整数集合的实现：</h3><p>每个 <code>intset.h/intset</code> 结构表示一个整数集合：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">intset</span> &#123;<br>    <span class="hljs-comment">// 编码方式</span><br>    <span class="hljs-type">uint32_t</span> encoding;<br>    <span class="hljs-comment">// 集合包含的元素数量</span><br>    <span class="hljs-type">uint32_t</span> length;<br>    <span class="hljs-comment">// 保存元素的数组</span><br>    <span class="hljs-type">int8_t</span> contents[];<br>&#125; intset;<br></code></pre></td></tr></table></figure><p><strong>encoding</strong></p><p>这里contents的类型写着int8_t，但并非如此，数据的编码方式是由encoding属性决定的。</p><ul><li>如果 <code>encoding</code> 属性的值为 <code>INTSET_ENC_INT16</code> ， 那么 <code>contents</code> 就是一个 <code>int16_t</code> 类型的数组， 数组里的每个项都是一个 <code>int16_t</code> 类型的整数值 （最小值为 <code>-32,768</code> ，最大值为 <code>32,767</code> ）。</li><li>如果 <code>encoding</code> 属性的值为 <code>INTSET_ENC_INT32</code> ， 那么 <code>contents</code> 就是一个 <code>int32_t</code> 类型的数组， 数组里的每个项都是一个 <code>int32_t</code> 类型的整数值 （最小值为 <code>-2,147,483,648</code> ，最大值为 <code>2,147,483,647</code> ）。</li><li>如果 <code>encoding</code> 属性的值为 <code>INTSET_ENC_INT64</code> ， 那么 <code>contents</code> 就是一个 <code>int64_t</code> 类型的数组， 数组里的每个项都是一个 <code>int64_t</code> 类型的整数值 （最小值为 <code>-9,223,372,036,854,775,808</code> ，最大值为 <code>9,223,372,036,854,775,807</code> ）。</li></ul><p><strong>length</strong>表示当前集合拥有的元素个数</p><p><strong>contents</strong>，contents数组中的每一个元素就代表着集合中的一个元素，<mark>各个项在数组中按值的大小从小到大有序地排列</mark>， 并且数组中不包含任何重复项。</p><h3 id="升级："><a href="#升级：" class="headerlink" title="升级："></a>升级：</h3><p>在整数集合中有一个<strong>升级</strong>的概念，升级策略主要有两个好处， 一个是提升整数集合的灵活性， 另一个是尽可能地节约内存。我们先讲它是如何升级的，待会能更好地理解为啥会有这两好处</p><h4 id="如何升级："><a href="#如何升级：" class="headerlink" title="如何升级："></a>如何升级：</h4><p>每当我们要将一个新元素添加到整数集合里面， 并且新元素的类型比整数集合现有所有元素的类型都要长时， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。</p><p>升级整数集合并添加新元素共分为三步进行：</p><ol><li>根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。</li><li>将新元素添加到底层数组里面。</li></ol><p>因为每次向整数集合添加新元素都可能会引起升级， 而每次升级都需要对底层数组中已有的所有元素进行类型转换， 所以向整数集合添加新元素的时间复杂度为 O(N) 。</p><h4 id="升级的好处："><a href="#升级的好处：" class="headerlink" title="升级的好处："></a>升级的好处：</h4><ol><li>提升灵活性：因为 C 语言是静态类型语言， 为了避免类型错误， 我们通常不会将两种不同类型的值放在同一个数据结构里面。比如说， 我们一般只使用 <code>int16_t</code> 类型的数组来保存 <code>int16_t</code> 类型的值， 只使用 <code>int32_t</code> 类型的数组来保存 <code>int32_t</code> 类型的值，加入了升级策略后，你就可以<del>为所欲为</del>，可以随意地将 <code>int16_t</code> 、 <code>int32_t</code> 或者 <code>int64_t</code> 类型的整数添加到集合中， 而不必担心出现类型错误， 这种做法非常灵活。</li><li>节约内存：当然， 要让一个数组可以同时保存 <code>int16_t</code> 、 <code>int32_t</code> 、 <code>int64_t</code> 三种类型的值， 最简单的做法就是直接使用 <code>int64_t</code> 类型的数组作为整数集合的底层实现。 不过这样一来， 即使添加到整数集合里面的都是 <code>int16_t</code> 类型或者 <code>int32_t</code> 类型的值， 数组都需要使用 <code>int64_t</code> 类型的空间去保存它们， 从而出现浪费内存的情况。有了升级策略后，我们就是非必要不升级，不浪费了。</li></ol><h4 id="能不能降级？"><a href="#能不能降级？" class="headerlink" title="能不能降级？"></a>能不能降级？</h4><p>答案：不能，升了就降不回来了</p><h2 id="压缩列表："><a href="#压缩列表：" class="headerlink" title="压缩列表："></a>压缩列表：</h2><h3 id="简介：-2"><a href="#简介：-2" class="headerlink" title="简介："></a>简介：</h3><p>压缩列表（ziplist）是列表键（凑合算吧，redis3.2后用的是快速列表，而快速列表的基础就是压缩列表）和哈希键的底层实现之一。</p><p>当一个哈希键只包含少量键值对， 并且每个键值对的键和值要么就是小整数值， 要么就是长度比较短的字符串， 那么 Redis 就会使用压缩列表来做哈希键的底层实现。</p><p>当一个列表键只包含少量列表项， 并且每个列表项要么就是小整数值， 要么就是长度比较短的字符串，那么 Redis <strong>也不会</strong>使用压缩列表来做列表键的底层实现。现在改为都用快速列表了。</p><h3 id="压缩列表的实现："><a href="#压缩列表的实现：" class="headerlink" title="压缩列表的实现："></a>压缩列表的实现：</h3><p>压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的<strong>连续内存块</strong>组成的顺序型数据结构。</p><p>一个压缩列表可以包含任意多个节点（entry）， 每个节点可以保存一个字节数组或者一个整数值。</p><p><strong>压缩列表</strong></p><p>压缩列表的结构如下：</p><p><img src="https://img.tucang.cc/api/image/show/b7aa14a959a9f3509798854dc47a82d7"></p><p>由4大部分组层，下面是关于这4大部分详细的介绍</p><p><img src="https://img.tucang.cc/api/image/show/1256a4ceac14ddf3e5ea1277674938a7"></p><p><strong>压缩列表节点</strong></p><p>每个压缩列表节点可以保存一个字节数组或者一个整数值， 其中， 字节数组可以是以下三种长度的其中一种：</p><ol><li>长度小于等于 <code>63</code> （2^{6}-1）字节的字节数组；</li><li>长度小于等于 <code>16383</code> （2^{14}-1） 字节的字节数组；</li><li>长度小于等于 <code>4294967295</code> （2^{32}-1）字节的字节数组；</li></ol><p>而整数值则可以是以下六种长度的其中一种：</p><ol><li><code>4</code> 位长，介于 <code>0</code> 至 <code>12</code> 之间的无符号整数；</li><li><code>1</code> 字节长的有符号整数；</li><li><code>3</code> 字节长的有符号整数；</li><li><code>int16_t</code> 类型整数；</li><li><code>int32_t</code> 类型整数；</li><li><code>int64_t</code> 类型整数。</li></ol><p>每个压缩列表节点都由 <code>previous_entry_length</code> 、 <code>encoding</code> 、 <code>content</code> 三个部分组成， 如下图。</p><p>![image-20221015120553391](&#x2F;Users&#x2F;pengxj&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20221015120553391.png)</p><p>接下来我们详细地看看这三个部分。</p><h4 id="previous-entry-length"><a href="#previous-entry-length" class="headerlink" title="previous_entry_length"></a>previous_entry_length</h4><p>节点的 <code>previous_entry_length</code> 属性以字节为单位， 记录了压缩列表中前一个节点的长度。这里要关注的<strong>第一个重点</strong>就是<mark>它可能用一个字节也可能用五个字节来保存这个长度</mark>，具体如下：</p><ul><li>如果前一节点的长度小于 <code>254</code> 字节， 那么 <code>previous_entry_length</code> 属性的长度为 <code>1</code> 字节： 前一节点的长度就保存在这一个字节里面。</li><li>如果前一节点的长度大于等于 <code>254</code> 字节， 那么 <code>previous_entry_length</code> 属性的长度为 <code>5</code> 字节： 其中属性的第一字节会被设置为 <code>0xFE</code>（十进制值 <code>254</code>）， <strong>而之后的四个字节</strong>则用于保存前一节点的长度。</li></ul><p><img src="https://img.tucang.cc/api/image/show/a814cd2371314422ec2347714a63af87"></p><p><strong>第二个重点是</strong>：因为节点的 <code>previous_entry_length</code> 属性记录了前一个节点的长度， 所以程序可以通过指针运算， 根据当前节点的起始地址来计算出前一个节点的起始地址。</p><h4 id="encoding："><a href="#encoding：" class="headerlink" title="encoding："></a>encoding：</h4><p>节点的 <code>encoding</code> 属性记录了节点的 <code>content</code> 属性所保存数据的类型以及长度：</p><ul><li>一字节、两字节或者五字节长， 值的最高位为 <code>00</code> 、 <code>01</code> 或者 <code>10</code> 的是<strong>字节数组编码</strong>： 这种编码表示节点的 <code>content</code> 属性保存着字节数组， <strong>数组的长度由编码除去最高两位之后的其他位记录</strong>；</li><li>一字节长， 值的最高位以 <code>11</code> 开头的是<strong>整数编码</strong>： 这种编码表示节点的 <code>content</code> 属性保存着整数值， <strong>整数值的类型和长度由编码除去最高两位之后的其他位记录</strong>；</li></ul><p>字节数组编码：</p><table><thead><tr><th align="left">编码</th><th align="left">编码长度</th><th align="left"><code>content</code> 属性保存的值</th></tr></thead><tbody><tr><td align="left"><code>00bbbbbb</code></td><td align="left"><code>1</code> 字节</td><td align="left">长度小于等于 <code>63</code> 字节的字节数组。</td></tr><tr><td align="left"><code>01bbbbbb xxxxxxxx</code></td><td align="left"><code>2</code> 字节</td><td align="left">长度小于等于 <code>16383</code> 字节的字节数组。</td></tr><tr><td align="left"><code>10______ aaaaaaaa bbbbbbbb cccccccc dddddddd</code></td><td align="left"><code>5</code> 字节</td><td align="left">长度小于等于 <code>4294967295</code> 的字节数组。</td></tr></tbody></table><p>整数编码：</p><table><thead><tr><th align="left">编码</th><th align="left">编码长度</th><th align="left"><code>content</code> 属性保存的值</th></tr></thead><tbody><tr><td align="left"><code>11000000</code></td><td align="left"><code>1</code> 字节</td><td align="left"><code>int16_t</code> 类型的整数。</td></tr><tr><td align="left"><code>11010000</code></td><td align="left"><code>1</code> 字节</td><td align="left"><code>int32_t</code> 类型的整数。</td></tr><tr><td align="left"><code>11100000</code></td><td align="left"><code>1</code> 字节</td><td align="left"><code>int64_t</code> 类型的整数。</td></tr><tr><td align="left"><code>11110000</code></td><td align="left"><code>1</code> 字节</td><td align="left"><code>24</code> 位有符号整数。</td></tr><tr><td align="left"><code>11111110</code></td><td align="left"><code>1</code> 字节</td><td align="left"><code>8</code> 位有符号整数。</td></tr><tr><td align="left"><code>1111xxxx</code></td><td align="left"><code>1</code> 字节</td><td align="left">使用这一编码的节点没有相应的 <code>content</code> 属性， 因为编码本身的 <code>xxxx</code> 四个位已经保存了一个介于 <code>0</code> 和 <code>12</code> 之间的值， 所以它无须 <code>content</code> 属性。</td></tr></tbody></table><h4 id="content："><a href="#content：" class="headerlink" title="content："></a>content：</h4><p>节点的 <code>content</code> 属性负责保存节点的值， 节点值可以是一个字节数组或者整数， 值的类型和长度由节点的 <code>encoding</code> 属性决定。</p><p>下面展示了一个保存字节数组的节点示例：</p><ul><li>编码的最高两位 <code>00</code> 表示节点保存的是一个字节数组；</li><li>编码的后六位 <code>001011</code> 记录了字节数组的长度 <code>11</code> ；</li><li><code>content</code> 属性保存着节点的值 <code>&quot;hello world&quot;</code> 。</li></ul><p><img src="https://img.tucang.cc/api/image/show/ccea9372600a49fc2c63f82e66c3e530"></p><p>下面展示了一个保存整数值的节点示例：</p><ul><li>编码 <code>11000000</code> 表示节点保存的是一个 <code>int16_t</code> 类型的整数值；</li><li><code>content</code> 属性保存着节点的值 <code>10086</code> 。</li></ul><p><img src="https://img.tucang.cc/api/image/show/bc3e882642b2de74a9022337ffe48029"></p><h3 id="连续更新："><a href="#连续更新：" class="headerlink" title="连续更新："></a>连续更新：</h3><p>前面说过， 每个节点的 <code>previous_entry_length</code> 属性都记录了前一个节点的长度，但是这个用于保存该长度的字节数是不一定的，有可能为5也可能为1。</p><p>以下面的一个例子为例，我们看看何时会发生连续更新。</p><p>现在， 考虑这样一种情况： 在一个压缩列表中， 有多个连续的、长度介于 <code>250</code> 字节到 <code>253</code> 字节之间的节点 <code>e1</code> 至 <code>eN</code>，因为<code>e1</code>到<code>eN</code>都是小于254个字节的，所以它们的<code>previous_entry_length</code> ，就只为一个字节，这时我们将一个长度大于等于254字节的节点插到列表的前面，这时<code>e1</code>的<code>previous_entry_length</code>也就得更新为5个字节长度来保存这个信息，而因为<code>e1</code>的<code>previous_entry_length</code>更新后使<code>e1</code>的总长也发生了改变，这时<code>e2</code>也得更新它的<code>previous_entry_length</code>，如此反复更新<code>e3</code>，一直到<code>eN</code></p><p>删除一个节点也一样。</p><p>我们这里提到的是变长的情况，那如果是变短的情况呢，<mark>后面的previous_entry_length会不会变回一个字节？</mark>，答案是不会，因为redis认为这个空间重新分配是很复杂的事，会影响效率，居然它现在能容纳前面节点的长度，那就先用着，避免后面一修改又要去重新分配空间。</p><p>因为连锁更新在最坏情况下需要对压缩列表执行 <code>N</code> 次空间重分配操作， 而每次空间重分配的最坏复杂度为 O(N) ， 所以连锁更新的最坏复杂度为 O(N^2) 。</p><blockquote><p> 这里插一嘴，之前看一个人(<a href="http://zhangtielei.com/posts/blog-redis-ziplist.html">Redis内部数据结构详解(4)——ziplist</a>)对压缩列表插入的源码分析，里面说了是先计算出需要新分配空间后我们再去分配的，当时误解了意思，以为是对后面的每个结点都计算出需要新分配的空间后再去分配新空间。其实不然，实际真的是一个一个节点来分配的。<a href="https://www.cnblogs.com/cquccy/p/14305233.html">redis6.0.5之ziplist阅读笔记3–压缩列表(ziplist)之插入和删除</a>，可以结合这篇一起看</p></blockquote><p>当然也不用很悲观，上面引用的例子是一个极端的情况，它真正造成性能问题的几率是很低的：</p><ul><li>首先， 压缩列表里要恰好有多个连续的、<strong>长度介于 <code>250</code> 字节至 <code>253</code> 字节之间的节点</strong>， 连锁更新才有可能被引发， 在实际中， 这种情况并不多见；</li><li>其次， 即使出现连锁更新， 但只要被更新的节点数量不多， 就不会对性能造成任何影响： 比如说， 对三五个节点进行连锁更新是绝对不会影响性能的；</li></ul><blockquote><p>至此，redis的基本数据结构告一段落～～🎉</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>打怪升级</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>🏀打造Go的武器--Gorm☢︎</title>
    <link href="/2022/10/11/%E6%89%93%E9%80%A0Go%E7%9A%84%E6%AD%A6%E5%99%A8--Gorm/"/>
    <url>/2022/10/11/%E6%89%93%E9%80%A0Go%E7%9A%84%E6%AD%A6%E5%99%A8--Gorm/</url>
    
    <content type="html"><![CDATA[<p>Go程序的第一把武器：优雅的CRUD，by <strong>Gorm</strong></p><span id="more"></span><h1 id="🏀打造Go的武器–Gorm☢︎"><a href="#🏀打造Go的武器–Gorm☢︎" class="headerlink" title="🏀打造Go的武器–Gorm☢︎"></a>🏀打造Go的武器–Gorm☢︎</h1><p><img src="https://img.tucang.cc/api/image/show/3d2863ff6fd85dbbe760de1c8bdce037"></p><h2 id="什么是Gorm："><a href="#什么是Gorm：" class="headerlink" title="什么是Gorm："></a>什么是Gorm：</h2><blockquote><p>在用Go开发项目时，我们免不了要和数据库打交道。每种语言都有优秀的ORM可供选择，在Go中也不例外，比如<a href="https://github.com/go-gorm/gorm">gorm</a>、<a href="https://github.com/go-xorm/xorm">xorm</a>、<a href="https://github.com/gohouse/gorose">gorose</a>等。目前，GitHub上 star数最多的是GORM，它也是当前Go项目中使用最多的ORM。</p></blockquote><p>GORM是Go语言的ORM包，功能强大，调用方便。像腾讯、华为、阿里这样的大厂，都在使用GORM来构建企业级的应用。GORM有很多特性，开发中常用的核心特性如下：</p><ul><li>功能全。使用ORM操作数据库的接口，GORM都有，可以满足我们开发中对数据库调用的各类需求。</li><li>支持钩子方法。这些钩子方法可以应用在Create、Save、Update、Delete、Find方法中。</li><li>开发者友好，调用方便。</li><li>支持Auto Migration。</li><li>支持关联查询。</li><li>支持多种关系数据库，例如MySQL、Postgres、SQLite、SQLServer等。</li></ul><p>GORM有两个版本，<a href="https://github.com/jinzhu/gorm">V1</a>和<a href="https://github.com/go-gorm/gorm">V2</a>。遵循用新不用旧的原则，我们学习最新的V2版本。</p><h2 id="快速使用🫥："><a href="#快速使用🫥：" class="headerlink" title="快速使用🫥："></a>快速使用🫥：</h2><p><strong>安装：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>安装gorm包<br>go get -u gorm.io/gorm<br><br><span class="hljs-regexp">//</span>安装mysql数据库驱动<br>go get -u gorm.io<span class="hljs-regexp">/driver/my</span>sql<br></code></pre></td></tr></table></figure><p><strong>使用：</strong></p><p>首先是<strong>导包</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">&quot;gorm.io/driver/mysql&quot;</span><br>  <span class="hljs-string">&quot;gorm.io/gorm&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>然后<strong>定义一个GORM模型</strong>（Models），Models是标准的Go struct，用来代表数据库中的一个表结构。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>  ID <span class="hljs-type">int64</span> <span class="hljs-comment">// 主键</span><br><span class="hljs-comment">//通过在字段后面的标签说明，定义golang字段和表字段的关系</span><br><span class="hljs-comment">//例如 `gorm:&quot;column:username&quot;` 标签说明含义是: 在Mysql中表的列名（字段名)为username</span><br><span class="hljs-comment">//这里golang定义的Username变量和MYSQL表字段username一样，他们的名字可以不一样。</span><br>Username <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;column:username&quot;`</span><br>Password <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;column:password&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>连接数据库：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  username := <span class="hljs-string">&quot;root&quot;</span><br>  password := <span class="hljs-string">&quot;123456&quot;</span><br>  host := <span class="hljs-string">&quot;127.0.0.1&quot;</span><br>  port := <span class="hljs-number">3306</span><br>  Dbname := <span class="hljs-string">&quot;Dbname&quot;</span><br>  <br>  <span class="hljs-comment">// 拼接 mysql dsn，即拼接数据源，下方 &#123;&#125; 中的替换参数即可</span><br>  <span class="hljs-comment">// &#123;username&#125;:&#123;password&#125;@tcp(&#123;host&#125;:&#123;port&#125;)/&#123;Dbname&#125;?charset=utf8&amp;parseTime=True&amp;loc=Local&amp;timeout=10s&amp;readTimeout=30s&amp;writeTimeout=60s</span><br>  <span class="hljs-comment">// timeout 是连接超时时间，readTimeout 是读超时时间，writeTimeout 是写超时时间，可以不填</span><br>  dsn := fmt.Sprintf(<span class="hljs-string">&quot;%s:%s@tcp(%s:%d)/%s?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span>, username, password, host, port, Dbname)<br>  <span class="hljs-comment">// 连接 mysql</span><br>  db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;数据库连接失败, error&quot;</span> + err.Error())<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>正式使用：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">&quot;gorm.io/driver/mysql&quot;</span><br>  <span class="hljs-string">&quot;gorm.io/gorm&quot;</span><br>  <span class="hljs-string">&quot;fmt&quot;</span><br>  <span class="hljs-string">&quot;time&quot;</span><br>  <span class="hljs-string">&quot;errors&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>  ID <span class="hljs-type">int64</span><br>Username <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;column:username&quot;`</span><br>Password <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;column:password&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>username := <span class="hljs-string">&quot;root&quot;</span><br>password := <span class="hljs-string">&quot;123456&quot;</span><br>host := <span class="hljs-string">&quot;127.0.0.1&quot;</span><br>port := <span class="hljs-number">3306</span><br>Dbname := <span class="hljs-string">&quot;Dbname&quot;</span><br>  <br>dsn := fmt.Sprintf(<span class="hljs-string">&quot;%s:%s@tcp(%s:%d)/%s?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span>, username, password, host, port, Dbname)<br>  db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;连接数据库失败, error=&quot;</span> + err.Error())<br>&#125;<br><br><span class="hljs-comment">//定义一个用户，并初始化数据</span><br>u := User&#123;<br>Username:<span class="hljs-string">&quot;tizi365&quot;</span>,<br>Password:<span class="hljs-string">&quot;123456&quot;</span>,<br>&#125;<br><br><span class="hljs-comment">//插入一条用户数据</span><br><span class="hljs-comment">//下面代码会自动生成SQL语句：INSERT INTO `users` (`username`,`password`) VALUES (&#x27;tizi365&#x27;,&#x27;123456&#x27;)</span><br><span class="hljs-keyword">if</span> err := db.Create(&amp;u).Error; err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;插入失败&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>  <br><span class="hljs-comment">//查询并返回第一条数据</span><br>u = User&#123;&#125;<br><span class="hljs-comment">//自动生成sql： SELECT * FROM `users`  WHERE (username = &#x27;tizi365&#x27;) LIMIT 1</span><br>result := db.Where(<span class="hljs-string">&quot;username = ?&quot;</span>, <span class="hljs-string">&quot;tizi365&quot;</span>).First(&amp;u)<br><span class="hljs-keyword">if</span> errors.Is(result.Error, gorm.ErrRecordNotFound) &#123;<br>fmt.Println(<span class="hljs-string">&quot;找不到记录&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(u.Username,u.Password)<br><br><span class="hljs-comment">//更新</span><br><span class="hljs-comment">//自动生成Sql: UPDATE `users` SET `password` = &#x27;654321&#x27;  WHERE (username = &#x27;tizi365&#x27;)</span><br>db.Model(&amp;User&#123;&#125;).Where(<span class="hljs-string">&quot;username = ?&quot;</span>, <span class="hljs-string">&quot;tizi365&quot;</span>).Update(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;654321&quot;</span>)<br><br><span class="hljs-comment">//删除</span><br><span class="hljs-comment">//自动生成Sql： DELETE FROM `users`  WHERE (username = &#x27;tizi365&#x27;)</span><br>db.Where(<span class="hljs-string">&quot;username = ?&quot;</span>, <span class="hljs-string">&quot;tizi365&quot;</span>).Delete(&amp;User&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>在Go项目开发中，使用GORM库主要用来完成以下数据库操作：</p><ul><li>连接和关闭数据库。连接数据库时，可能需要设置一些参数，比如最大连接数、最大空闲连接数、最大连接时长等。</li><li>插入表记录。可以插入一条记录，也可以批量插入记录。</li><li>更新表记录。可以更新某一个字段，也可以更新多个字段。</li><li>查看表记录。可以查看某一条记录，也可以查看符合条件的记录列表。</li><li>删除表记录。可以删除某一个记录，也可以批量删除。删除还支持永久删除和软删除。</li><li>在一些小型项目中，还会用到GORM的表结构自动迁移功能。</li></ul><p>GORM功能强大，上面的示例代码展示的是比较通用的一种操作方式。上面展示的模型定义，连接数据库，增删差改的方法在Gorm中还有很多细节，下面我们开始进一步的学习。</p><h2 id="🤧GORM常用操作讲解："><a href="#🤧GORM常用操作讲解：" class="headerlink" title="🤧GORM常用操作讲解："></a>🤧GORM常用操作讲解：</h2><h3 id="模型定义："><a href="#模型定义：" class="headerlink" title="模型定义："></a>模型定义：</h3><blockquote><p>模型是标准的 struct，由 Go 的<strong>基本数据类型</strong>、实现了 Scanner和 Valuer接口的自定义类型及其指针或别名组成</p></blockquote><p><strong>约定</strong></p><p>GORM 倾向于约定，而不是配置。默认情况下，GORM 使用 <code>ID</code> 作为主键，使用结构体名的 <code>蛇形复数</code> 作为表名，字段名的 <code>蛇形</code> 作为列名，并使用 <code>CreatedAt</code>、<code>UpdatedAt</code> 字段追踪创建、更新时间</p><p>分别的细节：</p><ol><li><p>默认情况下，GORM 会使用 <code>ID</code> 作为表的主键。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>  ID   <span class="hljs-type">string</span> <span class="hljs-comment">// 默认情况下，名为 `ID` 的字段会作为表的主键</span><br>  Name <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p> 不过我们可以使用标签 <code>primaryKey</code> 将其它字段设为主键</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 将 `UID` 设为主键</span><br><span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">struct</span> &#123;<br>  ID     <span class="hljs-type">int64</span><br>  UID   <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;primaryKey&quot;`</span><br>  Name   <span class="hljs-type">string</span><br>  Age    <span class="hljs-type">int64</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用结构体名的 <code>蛇形复数</code> 作为表名，字段名的 <code>蛇形</code> 作为列名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">struct</span> &#123;<br>  AnimalID <span class="hljs-type">int64</span>        <span class="hljs-comment">// 列名 `animal_id`</span><br>  Birthday time.Time    <span class="hljs-comment">// 列名 `birthday`</span><br>  Age      <span class="hljs-type">int64</span>        <span class="hljs-comment">// 列名 `age`</span><br>&#125;<br><span class="hljs-comment">//表名 animals</span><br></code></pre></td></tr></table></figure><p>如果想要自定义，Gorm也提供了相应的方法，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//自定义表名：为结构体定义一个TableName方法，返回表名</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Animal)</span></span> TableName() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;animal&quot;</span><br>&#125;<br><br><span class="hljs-comment">//自定义列名：在结构体的字段上添加关于列名的标签</span><br><span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">struct</span> &#123;<br>    AnimalID <span class="hljs-type">int64</span>     <span class="hljs-string">`gorm:&quot;column:animalID;primarykey&quot;`</span> <span class="hljs-comment">// 将列名设为 `animalID`</span><br>    Birthday time.Time <span class="hljs-string">`gorm:&quot;column:birthday&quot;`</span>            <span class="hljs-comment">// 将列名设为 `birthday`</span><br>    Age      <span class="hljs-type">int64</span>     <span class="hljs-string">`gorm:&quot;column:age&quot;`</span>                 <span class="hljs-comment">// 将列名设为 `age`</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Gorm.Model:</p><p>数据库表通常会包含4个字段。</p><ul><li>ID：自增字段，也作为主键。</li><li>CreatedAt：记录创建时间。</li><li>UpdatedAt：记录更新时间。</li><li>DeletedAt：记录删除时间（软删除时有用）。</li></ul><p>GORM也预定义了包含这4个字段的Models，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// gorm.Model 的定义</span><br><span class="hljs-keyword">type</span> Model <span class="hljs-keyword">struct</span> &#123;<br>  ID        <span class="hljs-type">uint</span>           <span class="hljs-string">`gorm:&quot;primaryKey&quot;`</span><br>  CreatedAt time.Time<br>  UpdatedAt time.Time<br>  DeletedAt gorm.DeletedAt <span class="hljs-string">`gorm:&quot;index&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在我们定义自己的Models时，可以直接内嵌到结构体内，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">struct</span> &#123;<br>    gorm.Model<br>    AnimalID <span class="hljs-type">int64</span>     <span class="hljs-string">`gorm:&quot;column:animalID&quot;`</span> <span class="hljs-comment">// 将列名设为 `animalID`</span><br>    Birthday time.Time <span class="hljs-string">`gorm:&quot;column:birthday&quot;`</span> <span class="hljs-comment">// 将列名设为 `birthday`</span><br>    Age      <span class="hljs-type">int64</span>     <span class="hljs-string">`gorm:&quot;column:age&quot;`</span>      <span class="hljs-comment">// 将列名设为 `age`</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>嵌入结构体：</p><p>对于匿名字段，GORM 会将其字段包含在父结构体中，就是与上面的嵌入gorm.Model一样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//嵌入后的Animal等效于下面这个</span><br><span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">struct</span> &#123;<br>    ID        <span class="hljs-type">uint</span><br>  CreatedAt time.Time<br>  UpdatedAt time.Time<br>  DeletedAt gorm.DeletedAt<br>    AnimalID <span class="hljs-type">int64</span>     <span class="hljs-string">`gorm:&quot;column:animalID&quot;`</span><br>    Birthday time.Time <span class="hljs-string">`gorm:&quot;column:birthday&quot;`</span><br>    Age      <span class="hljs-type">int64</span>     <span class="hljs-string">`gorm:&quot;column:age&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于正常的结构体字段，你也可以通过标签 <code>embedded</code> 将其嵌入，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Author <span class="hljs-keyword">struct</span> &#123;<br>    Name  <span class="hljs-type">string</span><br>    Email <span class="hljs-type">string</span><br>&#125;<br><span class="hljs-keyword">type</span> Blog <span class="hljs-keyword">struct</span> &#123;<br>  ID      <span class="hljs-type">int</span><br>  Author  Author <span class="hljs-string">`gorm:&quot;embedded&quot;`</span><br>  Upvotes <span class="hljs-type">int32</span><br>&#125;<br><span class="hljs-comment">// 等效于</span><br><span class="hljs-keyword">type</span> Blog <span class="hljs-keyword">struct</span> &#123;<br>  ID    <span class="hljs-type">int64</span><br>  Name  <span class="hljs-type">string</span><br>  Email <span class="hljs-type">string</span><br>  Upvotes  <span class="hljs-type">int32</span><br>&#125;<br></code></pre></td></tr></table></figure><p>并且，还可以使用标签 <code>embeddrefix</code> 来为 db 中的字段名添加前缀，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Blog <span class="hljs-keyword">struct</span> &#123;<br>  ID      <span class="hljs-type">int</span><br>  Author  Author <span class="hljs-string">`gorm:&quot;embedded;embeddedPrefix:author_&quot;`</span><br>  Upvotes <span class="hljs-type">int32</span><br>&#125;<br><span class="hljs-comment">// 等效于</span><br><span class="hljs-keyword">type</span> Blog <span class="hljs-keyword">struct</span> &#123;<br>  ID          <span class="hljs-type">int64</span><br>    AuthorName  <span class="hljs-type">string</span><br>    AuthorEmail <span class="hljs-type">string</span><br>  Upvotes     <span class="hljs-type">int32</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>字段标签</p><p>Models中的字段能支持很多GORM标签，但如果我们不使用GORM自动创建表和迁移表结构的功能，很多标签我们实际上是用不到的。在开发中，用得最多的是 <code>column</code> 标签。具体如下：</p><table><thead><tr><th align="left">标签名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">column</td><td align="left">指定 db 列名</td></tr><tr><td align="left">type</td><td align="left">列数据类型，推荐使用兼容性好的通用类型，例如：bool、int、uint、float、string、time、bytes。并可与其他标签一起使用，例如：<code>not null</code>、<code>size</code>, <code>autoIncrement</code>… 像 <code>varbinary(8)</code> 这样指定数据库数据类型也是支持的。在使用指定数据库数据类型时，它需要是完整的数据库数据类型，如：<code>MEDIUMINT UNSINED not NULL AUTO_INSTREMENT</code></td></tr><tr><td align="left">size</td><td align="left">指定列大小，例如：<code>size:256</code></td></tr><tr><td align="left">primaryKey</td><td align="left">指定列为主键</td></tr><tr><td align="left">unique</td><td align="left">指定列为唯一</td></tr><tr><td align="left">default</td><td align="left">指定列的默认值</td></tr><tr><td align="left">precision</td><td align="left">指定列的精度</td></tr><tr><td align="left">not null</td><td align="left">指定列为 NOT NULL</td></tr><tr><td align="left">autoIncrement</td><td align="left">指定列为自动增长</td></tr><tr><td align="left">embedded</td><td align="left">嵌套字段</td></tr><tr><td align="left">embeddedPrefix</td><td align="left">嵌套字段的前缀</td></tr><tr><td align="left">autoCreateTime</td><td align="left">track current time when creating, for <code>int</code> fields, it will track unix seconds, use value <code>nano</code>&#x2F;<code>milli</code> to track unix nano&#x2F;milli seconds, e.g: <code>autoCreateTime:nano</code></td></tr><tr><td align="left">autoUpdateTime</td><td align="left">track current time when creating&#x2F;updating, for <code>int</code> fields, it will track unix seconds, use value <code>nano</code>&#x2F;<code>milli</code> to track unix nano&#x2F;milli seconds, e.g: <code>autoUpdateTime:milli</code></td></tr><tr><td align="left">index</td><td align="left">根据参数创建索引，多个字段拥有相同的名称则创建复合索引，参考 <a href="https://www.bookstack.cn/read/gorm-2.0/$docs-indexes.html">索引</a> 获取详情</td></tr><tr><td align="left">uniqueIndex</td><td align="left">与 <code>index</code> 相同，但创建的是唯一索引</td></tr><tr><td align="left">check</td><td align="left">创建检查约束，例如 <code>check:(age &gt; 13)</code>，查看 <a href="https://www.bookstack.cn/read/gorm-2.0/$docs-constraints.html">约束</a> 获取详情</td></tr><tr><td align="left">&lt;-</td><td align="left">设置字段写入的权限， <code>&lt;-:create</code> 只创建、<code>&lt;-:update</code> 只更新、<code>&lt;-:false</code> 无权限</td></tr><tr><td align="left">-&gt;</td><td align="left">设置字段读取权限</td></tr><tr><td align="left">-</td><td align="left">忽略此字段（禁止读写）</td></tr></tbody></table></li></ol><h3 id="连接数据库："><a href="#连接数据库：" class="headerlink" title="连接数据库："></a>连接数据库：</h3><ol><li>就像快速使用的例子一样，我们可以这样直接连接数据库：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">&quot;gorm.io/driver/mysql&quot;</span><br>  <span class="hljs-string">&quot;gorm.io/gorm&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">// 参考 https://github.com/go-sql-driver/mysql#dsn-data-source-name 获取详情</span><br>  dsn := <span class="hljs-string">&quot;user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span><br>  db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要GORM正确地处理 <code>time.Time</code> 类型，在连接数据库时需要带上 <code>parseTime</code> 参数(通常都要加的，这样Gorm就支持把数据库datetime和date类型转换为golang的time.Time类型，不然会出现一堆奇奇怪怪的问题)。如果要支持完整的UTF-8编码，可将<code>charset=utf8</code>更改为<code>charset=utf8mb4</code>（为了避免乱码，可以mysql字符集那篇博客)。</p><ol start="2"><li><strong>gorm调试模式：</strong></li></ol><p>为了方便调试，了解gorm操作到底执行了怎么样的sql语句，<strong>开发的时候</strong>需要打开调试日志，这样gorm会打印出执行的每一条sql语句。使用Debug函数执行查询即可，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">result := db.Debug().Where(<span class="hljs-string">&quot;username = ?&quot;</span>, <span class="hljs-string">&quot;tizi365&quot;</span>).First(&amp;u)<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>gorm连接池:</strong></li></ol><p>在高并发实践中，为了提高数据库连接的使用率，避免重复建立数据库连接带来的性能消耗，会经常使用数据库连接池技术来维护数据库连接。<br>gorm自带了数据库连接池使用非常简单只要设置下数据库连接池参数即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">sqlDB, err := db.DB()<br>sqlDB.SetMaxIdleConns(<span class="hljs-number">10</span>)              <span class="hljs-comment">// 设置MySQL的最大空闲连接数（推荐10）</span><br>sqlDB.SetMaxOpenConns(<span class="hljs-number">100</span>)             <span class="hljs-comment">// 设置MySQL的最大连接数（推荐100）</span><br>sqlDB.SetConnMaxLifetime(time.Hour)    <span class="hljs-comment">// 设置MySQL的空闲连接最大存活时间（推荐10s）</span><br></code></pre></td></tr></table></figure><p>具体使用例子如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//定义一个工具包，用来管理gorm数据库连接池的初始化工作。</span><br><span class="hljs-keyword">package</span> tools<br><br><span class="hljs-comment">//定义全局的db对象，我们执行数据库操作主要通过他实现。</span><br><span class="hljs-keyword">var</span> _db *gorm.DB<br><br><span class="hljs-comment">//包初始化函数，golang特性，每个包初始化的时候会自动执行init函数，这里用来初始化gorm。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    ...忽略dsn配置，请参考上面例子...<br>    <br>    <span class="hljs-comment">// 声明err变量，下面不能使用:=赋值运算符，否则_db变量会当成局部变量，导致外部无法访问_db变量</span><br>    <span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>    <span class="hljs-comment">//连接MYSQL, 获得DB类型实例，用于后面的数据库读写操作。</span><br>    _db, err = gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;连接数据库失败, error=&quot;</span> + err.Error())<br>&#125;<br>     <br>    sqlDB, _ := _db.DB()<br><br>    <span class="hljs-comment">//设置数据库连接池参数</span><br>    sqlDB.SetMaxOpenConns(<span class="hljs-number">100</span>)   <span class="hljs-comment">//设置数据库连接池最大连接数</span><br>    sqlDB.SetMaxIdleConns(<span class="hljs-number">10</span>)   <span class="hljs-comment">//连接池最大允许的空闲连接数，如果没有sql任务需要执行的连接数大于20，超过的连接会被连接池关闭。</span><br>&#125;<br><br><span class="hljs-comment">//获取gorm db对象，其他包需要执行数据库查询的时候，只要通过tools.getDB()获取db对象即可。</span><br><span class="hljs-comment">//不用担心协程并发使用同样的db对象会共用同一个连接，db对象在调用他的方法的时候会从数据库连接池中获取新的连接</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetDB</span><span class="hljs-params">()</span></span> *gorm.DB &#123;<br><span class="hljs-keyword">return</span> _db<br>&#125;<br></code></pre></td></tr></table></figure><p>使用例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-comment">//导入tools包</span><br><span class="hljs-keyword">import</span> tools<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">//获取DB</span><br>  db := tools.GetDB()<br>  <span class="hljs-comment">//执行数据库查询操作</span><br>  u := User&#123;&#125;<br><span class="hljs-comment">//自动生成sql： SELECT * FROM `users`  WHERE (username = &#x27;tizi365&#x27;) LIMIT 1</span><br>db.Where(<span class="hljs-string">&quot;username = ?&quot;</span>, <span class="hljs-string">&quot;tizi365&quot;</span>).First(&amp;u)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建记录："><a href="#创建记录：" class="headerlink" title="创建记录："></a>创建记录：</h3><ol><li>我们可以通过 <code>db.Create</code> 方法来创建一条记录：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>  gorm.Model<br>  Name         <span class="hljs-type">string</span><br>  Age          <span class="hljs-type">uint8</span><br>  Birthday     *time.Time<br>&#125;<br>user := User&#123;Name: <span class="hljs-string">&quot;Jinzhu&quot;</span>, Age: <span class="hljs-number">18</span>, Birthday: time.Now()&#125;<br>result := db.Create(&amp;user) <span class="hljs-comment">// 通过数据的指针来创建</span><br></code></pre></td></tr></table></figure><p>db.Create函数会返回如下3个值：</p><ul><li>user.ID：返回插入数据的主键，这个是直接赋值给user变量。</li><li>result.Error：返回error。</li><li>result.RowsAffected：返回插入记录的条数。</li></ul><ol start="2"><li>当需要插入的数据量比较大时，可以批量插入，以提高插入性能：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> users = []User&#123;&#123;Name: <span class="hljs-string">&quot;jinzhu1&quot;</span>&#125;, &#123;Name: <span class="hljs-string">&quot;jinzhu2&quot;</span>&#125;, &#123;Name: <span class="hljs-string">&quot;jinzhu3&quot;</span>&#125;&#125;<br>DB.Create(&amp;users)<br><br><span class="hljs-keyword">for</span> _, user := <span class="hljs-keyword">range</span> users &#123;<br>  user.ID <span class="hljs-comment">// 1,2,3</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除记录："><a href="#删除记录：" class="headerlink" title="删除记录："></a>删除记录：</h3><ol><li>我们可以通过Delete方法删除记录：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// DELETE from users where id = 10 AND name = &quot;jinzhu&quot;;</span><br>db.Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;jinzhu&quot;</span>).Delete(&amp;User&#123;&#125;)<br></code></pre></td></tr></table></figure><p>GORM也支持根据主键进行删除，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// DELETE FROM users WHERE id = 10;</span><br>db.Delete(&amp;User&#123;&#125;, <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>不过，更推荐使用db.Where的方式进行删除，这种方式有两个优点。</p><p>第一个优点是删除方式更通用。使用db.Where不仅可以根据主键删除，还能够随意组合条件进行删除。</p><p>第二个优点是删除方式更显式，这意味着更易读。如果使用<code>db.Delete(&amp;User&#123;&#125;, 10)</code>，你还需要确认User的主键，如果记错了主键，还可能会引入Bug。</p><p>此外，GORM也支持批量删除：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Where(<span class="hljs-string">&quot;name in (?)&quot;</span>, []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;jinzhu&quot;</span>, <span class="hljs-string">&quot;colin&quot;</span>&#125;).Delete(&amp;User&#123;&#125;)<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>软硬删除：</strong></li></ol><p>软删除是指执行Delete时，记录不会被从数据库中真正删除。GORM会将 <code>DeletedAt</code> 设置为当前时间，并且不能通过正常的方式查询到该记录。<strong>怎么触发软删除呢？</strong>如果模型包含了一个 <code>gorm.DeletedAt</code> 字段，那么GORM在执行删除操作时，就会软删除该记录。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// UPDATE users SET deleted_at=&quot;2013-10-29 10:23&quot; WHERE age = 20;</span><br>db.Where(<span class="hljs-string">&quot;age = ?&quot;</span>, <span class="hljs-number">20</span>).Delete(&amp;User&#123;&#125;)<br><br><span class="hljs-comment">// SELECT * FROM users WHERE age = 20 AND deleted_at IS NULL;</span><br>db.Where(<span class="hljs-string">&quot;age = 20&quot;</span>).Find(&amp;user)<br></code></pre></td></tr></table></figure><p>可以看到，GORM并没有真正把记录从数据库删除掉，而是只更新了 <code>deleted_at</code> 字段。在查询时，GORM查询条件中新增了<code>AND deleted_at IS NULL</code>条件，所以这些被设置过 <code>deleted_at</code> 字段的记录不会被查询到。对于一些比较重要的数据，我们可以通过软删除的方式删除记录，软删除可以使这些重要的数据后期能够被恢复，并且便于以后的排障。</p><p>我们也可以通过下面的方式查找被软删除的记录：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// SELECT * FROM users WHERE age = 20;</span><br>db.Unscoped().Where(<span class="hljs-string">&quot;age = 20&quot;</span>).Find(&amp;users)<br></code></pre></td></tr></table></figure><p><strong>永久删除:</strong></p><p>如果想永久删除一条记录，可以使用Unscoped：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// DELETE FROM orders WHERE id=10;</span><br>db.Unscoped().Delete(&amp;order)<br></code></pre></td></tr></table></figure><p>或者，也可以在模型中去掉gorm.DeletedAt。</p><h3 id="更新记录："><a href="#更新记录：" class="headerlink" title="更新记录："></a>更新记录：</h3><ol><li>GORM中，<strong>最常用的更新方法</strong>如下：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//先找到那条记录，赋值于结构体中</span><br>db.First(&amp;user)<br><span class="hljs-comment">//修改结构体的值</span><br>user.Name = <span class="hljs-string">&quot;jinzhu 2&quot;</span><br>user.Age = <span class="hljs-number">100</span><br><span class="hljs-comment">// UPDATE users SET name=&#x27;jinzhu 2&#x27;, age=100, birthday=&#x27;2016-01-01&#x27;, updated_at = &#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span><br>db.Save(&amp;user)<br></code></pre></td></tr></table></figure><p>上述方法会保留所有字段，所以执行Save时，需要先执行First，获取某个记录的所有列的值，然后再对需要更新的字段设置值。</p><ol start="2"><li><strong>还可以指定更新单个列：</strong></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// UPDATE users SET age=200, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE name=&#x27;colin&#x27;;</span><br>db.Model(&amp;User&#123;&#125;).Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;colin&quot;</span>).Update(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">200</span>)<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>也可以指定更新多个列：</strong></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18, updated_at = &#x27;2013-11-17 21:34:10&#x27; WHERE name = &#x27;colin&#x27;;</span><br>db.Model(&amp;user).Where(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;colin&quot;</span>).Updates(User&#123;Name: <span class="hljs-string">&quot;hello&quot;</span>, Age: <span class="hljs-number">18</span>, Active: <span class="hljs-literal">false</span>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>提示： 通过结构体变量更新字段值, gorm库会忽略零值字段。就比如如果我们想一个字段的值改为0，那用结构体就行不通了，字段值等于0, nil, “”, false这些值会被忽略掉，不会更新。如果想更新零值，可以使用map类型替代结构体。</p></blockquote><ol start="4"><li><strong>更新表达式</strong>:</li></ol><p><em>UPDATE <code>foods</code> SET <code>stock</code> &#x3D; <code>stock</code> + 1 WHERE id &#x3D; ‘2’</em><br>这样的带计算表达式的更新语句gorm怎么写？</p><p><del>挺重要‼️的哦，而且挺常用的，之前就有搜过这个</del></p><p>gorm提供了Expr函数用于设置表达式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//等价于: UPDATE `foods` SET `stock` = stock + 1  WHERE `foods`.`id` = &#x27;2&#x27;</span><br>db.Model(&amp;food).Update(<span class="hljs-string">&quot;stock&quot;</span>, gorm.Expr(<span class="hljs-string">&quot;stock + 1&quot;</span>))<br></code></pre></td></tr></table></figure><h3 id="查询数据："><a href="#查询数据：" class="headerlink" title="查询数据："></a>查询数据：</h3><p>GORM支持不同的查询方法，下面我来讲解三种在开发中经常用到的查询方式，分别是检索单个记录、查询所有符合条件的记录和智能选择字段。</p><ol><li>检索单个记录</li></ol><p>下面是检索单个记录的示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 获取根据主键排序的第一条记录（主键升序）</span><br><span class="hljs-comment">// 如果model类型没有定义主键，则按第一个字段排序。</span><br><span class="hljs-comment">// SELECT * FROM users ORDER BY id LIMIT 1;</span><br>db.First(&amp;user)<br><br><span class="hljs-comment">// 获取最后一条记录（主键降序）</span><br><span class="hljs-comment">// SELECT * FROM users ORDER BY id DESC LIMIT 1;</span><br>db.Last(&amp;user)<br>result := db.First(&amp;user)<br>result.RowsAffected <span class="hljs-comment">// 返回找到的记录数</span><br>result.Error        <span class="hljs-comment">// returns error</span><br><br><span class="hljs-comment">// 检查 ErrRecordNotFound 错误</span><br>errors.Is(result.Error, gorm.ErrRecordNotFound)<br><br><span class="hljs-comment">//下面这种方式也较为常见</span><br>err := db.Take(&amp;food).Error   <span class="hljs-comment">//Take是随机获取一条数据</span><br><span class="hljs-keyword">if</span> errors.Is(err, gorm.ErrRecordNotFound) &#123;<br>    fmt.Println(<span class="hljs-string">&quot;查询不到数据&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">//如果err不等于record not found错误，又不等于nil，那说明sql执行失败了。</span><br>fmt.Println(<span class="hljs-string">&quot;查询失败&quot;</span>, err)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>查询所有符合条件的记录</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">users := <span class="hljs-built_in">make</span>([]*User, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment">// SELECT * FROM users WHERE name &lt;&gt; &#x27;jinzhu&#x27;;</span><br>db.Where(<span class="hljs-string">&quot;name &lt;&gt; ?&quot;</span>, <span class="hljs-string">&quot;jinzhu&quot;</span>).Find(&amp;users)<br></code></pre></td></tr></table></figure><ol start="3"><li>智能选择字段</li></ol><p>你可以通过Select方法，选择特定的字段。我们可以定义一个较小的结构体来接受选定的字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> APIUser <span class="hljs-keyword">struct</span> &#123;<br>  ID   <span class="hljs-type">uint</span><br>  Name <span class="hljs-type">string</span><br>&#125;<br>user:=APIUser&#123;&#125;<br>db.Select(<span class="hljs-string">&quot;id,name&quot;</span>).Where(<span class="hljs-string">&quot;id = ?&quot;</span>, <span class="hljs-number">1</span>).Take(&amp;user)<br><br><span class="hljs-comment">//例子2:</span><br><span class="hljs-comment">//可以直接书写聚合语句</span><br><span class="hljs-comment">//等价于: SELECT count(*) as total FROM `foods`</span><br>total := []<span class="hljs-type">int</span>&#123;&#125;<br><br><span class="hljs-comment">//Model函数，用于指定绑定的模型，这里生成了一个Food&#123;&#125;变量。目的是从模型变量里面提取表名，Pluck函数我们没有直接传递绑定表名的结构体变量，gorm库不知道表名是什么，所以这里需要指定表名</span><br><span class="hljs-comment">//Pluck函数，主要用于查询一列值</span><br>db.Model(&amp;Food&#123;&#125;).Select(<span class="hljs-string">&quot;count(*) as total&quot;</span>).Pluck(<span class="hljs-string">&quot;total&quot;</span>, &amp;total)<br><span class="hljs-comment">//这里就是我们计算出total后，我们从返回结果中取出total列的值</span><br>fmt.Println(total[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><p>除了上面讲的三种常用的基本查询方法，GORM还支持高级查询</p><ol><li>指定检索记录时的排序方式</li></ol><p>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// SELECT * FROM users ORDER BY age desc, name;</span><br>db.Order(<span class="hljs-string">&quot;age desc, name&quot;</span>).Find(&amp;users)<br></code></pre></td></tr></table></figure><ol start="2"><li>Limit &amp; Offset</li></ol><p>Offset指定从第几条记录开始查询，Limit指定返回的最大记录数。Offset和Limit值为-1时，消除Offset和Limit条件。另外，Limit和Offset位置不同，效果也不同。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// SELECT * FROM users OFFSET 5 LIMIT 10;</span><br>db.Limit(<span class="hljs-number">10</span>).Offset(<span class="hljs-number">5</span>).Find(&amp;users)<br></code></pre></td></tr></table></figure><ol start="3"><li>Distinct</li></ol><p>Distinct可以从数据库记录中选择不同的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Distinct(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>).Order(<span class="hljs-string">&quot;name, age desc&quot;</span>).Find(&amp;results)<br></code></pre></td></tr></table></figure><ol start="4"><li>Count</li></ol><p>Count可以获取匹配的条数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> count <span class="hljs-type">int64</span><br><span class="hljs-comment">// SELECT count(1) FROM users WHERE name = &#x27;jinzhu&#x27;; (count)</span><br>db.Model(&amp;User&#123;&#125;).Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;jinzhu&quot;</span>).Count(&amp;count)<br></code></pre></td></tr></table></figure><p>5.Group</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//例子:</span><br><span class="hljs-comment">//统计每个商品分类下面有多少个商品</span><br><span class="hljs-comment">//定一个Result结构体类型，用来保存查询结果</span><br><span class="hljs-keyword">type</span> Result <span class="hljs-keyword">struct</span> &#123;<br>    Type  <span class="hljs-type">int</span><br>    Total <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> results []Result<br><span class="hljs-comment">//等价于: SELECT type, count(*) as  total FROM `foods` GROUP BY type HAVING (total &gt; 0)</span><br>db.Model(Food&#123;&#125;).Select(<span class="hljs-string">&quot;type, count(*) as  total&quot;</span>).Group(<span class="hljs-string">&quot;type&quot;</span>).Having(<span class="hljs-string">&quot;total &gt; 0&quot;</span>).Scan(&amp;results)<br><br><span class="hljs-comment">//scan类似Find都是用于执行查询语句，然后把查询结果赋值给结构体变量，区别在于scan不会从传递进来的结构体变量提取表名.</span><br><span class="hljs-comment">//这里因为我们重新定义了一个结构体用于保存结果，但是这个结构体并没有绑定foods表，所以这里只能使用scan查询函数。</span><br></code></pre></td></tr></table></figure><p>GORM还支持很多高级查询功能，比如内联条件、Not 条件、Or 条件、Joins、FirstOrInit、FirstOrCreate、迭代、FindInBatches等。因为IAM项目中没有用到这些高级特性，我在这里就不展开介绍了。你如果感兴趣，可以看下<a href="https://gorm.io/zh_CN/docs/index.html">GORM的官方文档</a>。</p><h3 id="原生SQL"><a href="#原生SQL" class="headerlink" title="原生SQL"></a>原生SQL</h3><p>GORM支持原生查询SQL和执行SQL。原生查询SQL用法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Result <span class="hljs-keyword">struct</span> &#123;<br>  ID   <span class="hljs-type">int</span><br>  Name <span class="hljs-type">string</span><br>  Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> result Result<br>db.Raw(<span class="hljs-string">&quot;SELECT id, name, age FROM users WHERE name = ?&quot;</span>, <span class="hljs-number">3</span>).Scan(&amp;result)<br></code></pre></td></tr></table></figure><p>原生执行SQL用法如下；</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">db<span class="hljs-selector-class">.Exec</span>(<span class="hljs-string">&quot;DROP TABLE users&quot;</span>)<br>db<span class="hljs-selector-class">.Exec</span>(<span class="hljs-string">&quot;UPDATE orders SET shipped_at=? WHERE id IN ?&quot;</span>, <span class="hljs-selector-tag">time</span><span class="hljs-selector-class">.Now</span>(), <span class="hljs-selector-attr">[]</span>int64&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;)<br></code></pre></td></tr></table></figure><h2 id="⭐️高级操作："><a href="#⭐️高级操作：" class="headerlink" title="⭐️高级操作："></a>⭐️高级操作：</h2><h3 id="🪝钩子："><a href="#🪝钩子：" class="headerlink" title="🪝钩子："></a>🪝钩子：</h3><p>钩子是在创建、查询、更新、删除等操作之前、之后调用的函数。</p><p>如果您已经为模型定义了指定的方法，它会在创建、更新、查询、删除时自动被调用。如<strong>果任何回调返回错误，GORM 将停止后续的操作并回滚事务。</strong></p><p>钩子方法的函数签名应该是 <code>func(*gorm.DB) error</code></p><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象:"></a>创建对象:</h4><p>创建时可用的钩子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 开始事务</span><br>BeforeSave<br>BeforeCreate<br><span class="hljs-comment">// 关联前的 save</span><br><span class="hljs-comment">// 插入记录至 db</span><br><span class="hljs-comment">// 关联后的 save</span><br>AfterCreate<br>AfterSave<br><span class="hljs-comment">// 提交或回滚事务</span><br><br></code></pre></td></tr></table></figure><p>以下面的代码为例，在创建用户前会申请一个uuid，如果申请失败则会报错回滚，且在成功创建后对id进行判断，进行后续操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *User)</span></span> BeforeCreate(tx *gorm.DB) (err <span class="hljs-type">error</span>) &#123;<br>  u.UUID = uuid.New()<br><br>  <span class="hljs-keyword">if</span> !u.IsValid() &#123;<br>    err = errors.New(<span class="hljs-string">&quot;can&#x27;t save invalid data&quot;</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *User)</span></span> AfterCreate(tx *gorm.DB) (err <span class="hljs-type">error</span>) &#123;<br>  <span class="hljs-keyword">if</span> u.ID == <span class="hljs-number">1</span> &#123;<br>    tx.Model(u).Update(<span class="hljs-string">&quot;role&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> 在 GORM 中保存、删除操作会默认运行在事务上， 因此在事务完成之前该事务中所作的更改是不可见的，如果您的钩子返回了任何错误，则修改将被回滚。</p></blockquote><p>其他类型的操作是相似于上面的，这里就只贴出他们可用的钩子：</p><p><img src="https://img.tucang.cc/api/image/show/a6323ba8fb5196c5b711699cb3fb6420"></p><h3 id="事务："><a href="#事务：" class="headerlink" title="事务："></a>事务：</h3><h4 id="自动事务："><a href="#自动事务：" class="headerlink" title="自动事务："></a>自动事务：</h4><p>通过db.Transaction函数实现事务，如果闭包任何一个函数返回错误，则回滚事务。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Transaction(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(tx *gorm.DB)</span></span> <span class="hljs-type">error</span> &#123;<br>  <span class="hljs-comment">// 在事务中执行一些 db 操作（从这里开始，您应该使用 &#x27;tx&#x27; 而不是 &#x27;db&#x27;）</span><br>  <span class="hljs-keyword">if</span> err := tx.Create(&amp;Animal&#123;Name: <span class="hljs-string">&quot;Giraffe&quot;</span>&#125;).Error; err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// 返回任何错误都会回滚事务</span><br>    <span class="hljs-keyword">return</span> err<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> err := tx.Create(&amp;Animal&#123;Name: <span class="hljs-string">&quot;Lion&quot;</span>&#125;).Error; err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> err<br>  &#125;<br><br>  <span class="hljs-comment">// 返回 nil 提交事务</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="手动事务："><a href="#手动事务：" class="headerlink" title="手动事务："></a>手动事务：</h4><p>在开发中经常需要数据库事务来保证多个数据库写操作的原子性。例如电商系统中的扣减库存和保存订单。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 开启事务</span><br>tx := db.Begin()<br><br><span class="hljs-comment">//在事务中执行数据库操作，使用的是tx变量，不是db。</span><br><br><span class="hljs-comment">//库存减一</span><br><span class="hljs-comment">//等价于: UPDATE `foods` SET `stock` = stock - 1  WHERE `foods`.`id` = &#x27;2&#x27; and stock &gt; 0</span><br><span class="hljs-comment">//RowsAffected用于返回sql执行后影响的行数</span><br>rowsAffected := tx.Model(&amp;food).Where(<span class="hljs-string">&quot;stock &gt; 0&quot;</span>).Update(<span class="hljs-string">&quot;stock&quot;</span>, gorm.Expr(<span class="hljs-string">&quot;stock - 1&quot;</span>)).RowsAffected<br><span class="hljs-keyword">if</span> rowsAffected == <span class="hljs-number">0</span> &#123;<br>    <span class="hljs-comment">//如果更新库存操作，返回影响行数为0，说明没有库存了，结束下单流程</span><br>    <span class="hljs-comment">//这里回滚作用不大，因为前面没成功执行什么数据库更新操作，也没什么数据需要回滚。</span><br>    <span class="hljs-comment">//这里就是举个例子，事务中可以执行多个sql语句，错误了可以回滚事务</span><br>    tx.Rollback()<br>    <span class="hljs-keyword">return</span><br>&#125;<br>err := tx.Create(保存订单).Error<br><br><span class="hljs-comment">//保存订单失败，则回滚事务</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    tx.Rollback()<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    tx.Commit()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="✨错误处理："><a href="#✨错误处理：" class="headerlink" title="✨错误处理："></a>✨错误处理：</h2><blockquote><p>在上面的查询数据里我们已经有提到错误处理了，其实那就是全部了，我们在这里再单独总结下～～～～</p></blockquote><h3 id="错误处理："><a href="#错误处理：" class="headerlink" title="错误处理："></a>错误处理：</h3><p>如果遇到任何错误，GORM 会将错误信息保存到 *gorm.DB 的Error字段，我们只要检测Error字段就可以知道是否存在错误。即：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err := db.Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;tizi365&quot;</span>).First(&amp;user).Error; err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-comment">// 错误处理</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ErrRecordNotFound-error："><a href="#ErrRecordNotFound-error：" class="headerlink" title="ErrRecordNotFound error："></a>ErrRecordNotFound error：</h3><p>当 <code>First</code>、<code>Last</code>、<code>Take</code> 方法找不到记录时，GORM 会返回 <code>ErrRecordNotFound</code> 错误。如果发生了多个错误，你可以通过 <code>errors.Is</code> 判断错误是否为 <code>ErrRecordNotFound</code>，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 检查错误是否为 RecordNotFound</span><br>err := db.First(&amp;user, <span class="hljs-number">100</span>).Error<br>errors.Is(err, gorm.ErrRecordNotFound)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>Gorm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Gorm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>🍟Mysql--乱码的前世今生-字符集和比较规则</title>
    <link href="/2022/09/24/Mysql--%E4%B9%B1%E7%A0%81%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F-%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/"/>
    <url>/2022/09/24/Mysql--%E4%B9%B1%E7%A0%81%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F-%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>突如其来的乱码让你蠢蠢欲动 ，让我们对字符集一探究竟，告别乱码问题。</p><span id="more"></span><h1 id="🍟Mysql–乱码的前世今生-字符集和比较规则"><a href="#🍟Mysql–乱码的前世今生-字符集和比较规则" class="headerlink" title="🍟Mysql–乱码的前世今生-字符集和比较规则"></a>🍟Mysql–乱码的前世今生-字符集和比较规则</h1><p><img src="https://pic8.58cdn.com.cn/nowater/webim/big/n_v280ab437197ac4086b131a5512bd87131.jpg"></p><h2 id="字符集："><a href="#字符集：" class="headerlink" title="字符集："></a>字符集：</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>众所周知计算机中能存储的只有二进制的数据，那我们怎么存储字符串的呢？答案是我们建立了一种规则来将字符串映射为二进制数据。字符有那么多，总不可能所有都包含进来吧，几乎这两点我们就能得到字符集一个言简意赅的定义：<strong>某个字符范围的编码规则</strong>。</p><h3 id="一些重要的字符集："><a href="#一些重要的字符集：" class="headerlink" title="一些重要的字符集："></a>一些重要的字符集：</h3><p>对于同一个字符，不同的人为了达到不同的目的，人们设置了很多种字符集。下面是一些常见的字符集：</p><ul><li><p>ASCII字符集：共收录128个字符，包括空格、标点符号、数字、大小写字母和一些不可见字符。由于总共才128个字符，所以仅使用一个字节来编码。</p></li><li><p>GB2312字符集：收录了汉字以及拉丁字母、希腊字母、日文平假名及片假名字母，俄语西里尔字母。其中汉字6763个，其他文字符号682个。同时这种字符集又兼容ASCII字符集，所以在编码上有些奇怪：</p><ul><li>如果该字符在ASCII字符集中，那么将采用一个字节来编码</li><li>其他都为2个字节</li></ul><p>这里我们发现了个新概念：变长编码方式，即在一个字符集中表示一个字符所需要的字节数可能不同。</p></li><li><p>GBK字符集：在GB2312上进行了扩产，编码上兼容GB2312</p></li><li><p>utf8字符集：收录了地球上能想到的所有字符，而且还在不断扩充，一样地兼容了ASCII字符集，采用变长编码方式，编码一个字符需要使用1-4个字节</p></li></ul><h3 id="Mysql支持的字符集："><a href="#Mysql支持的字符集：" class="headerlink" title="Mysql支持的字符集："></a>Mysql支持的字符集：</h3><p>首先我们解决一个疑惑：utf8mb3与utf8mb4。</p><p>上面我们提到utf8字符集采用了变长编码方式，一个字符可能由1-4字节编码，但是其实我们常用的字符用1-3个字节就足够编码了，而在Mysql中一个字符编码所用最大字节长度在某些方面会影响系统的存储和性能所以，Mysql设立了以上两种概念：</p><ul><li>Utf8mb3: 其实就是utf8的阉割版，只使用1-3个字节表示字符。</li><li>Utf8mb4: 真正的utf8。</li></ul><p>在Mysql中，utf8实际上指的是utf8mb3，是它的一个别名，如果有要用4个字节编码的情况，例如存emoji表情，那一定要明确指定utf8mb4。</p><p>接着我们了解下查看字符集的指令：<code>SHOW (CHARACTER SET|CHARSET)[LIKE 匹配的模式] </code>CHARACTER SET和CHARSET是同义词，用哪个都行。</p><h2 id="比较规则："><a href="#比较规则：" class="headerlink" title="比较规则："></a>比较规则：</h2><h3 id="简介：-1"><a href="#简介：-1" class="headerlink" title="简介："></a>简介：</h3><p>在字符串被编码为相应的二进制数据后，如何比较字符的大小就是比较规则的事了，最简单的莫过于直接比较二进制编码的大小，而这种情况并不是一直都可以，比如我们有时的业务逻辑是将’a’与’A’认为是相等的，我们要怎样解决呢，将所有的字符都转换为大写或小写，再进行比较，这还算简单，就是转换下大小写，实际的情况是英文字符不止一种，汉字有几万个，所以人们为了达到适当的比较的目的，设计了很多比较规则，一个字符集就可以拥有多个比较规则。</p><h3 id="查看比较规则："><a href="#查看比较规则：" class="headerlink" title="查看比较规则："></a>查看比较规则：</h3><p>SHOW COLLATION [LIKE 匹配模式]，就可以看到系统支持的比较规则，可以注意到，一个字符集可以有多个比较规则，比较规则名称的前缀就是相应的字符集，而且每个字符集都有一个默认的比较规则。</p><h2 id="字符集和比较规则的应用："><a href="#字符集和比较规则的应用：" class="headerlink" title="字符集和比较规则的应用："></a>字符集和比较规则的应用：</h2><h3 id="各级别的字符集和比较规则："><a href="#各级别的字符集和比较规则：" class="headerlink" title="各级别的字符集和比较规则："></a>各级别的字符集和比较规则：</h3><p>在Mysql中字符集的级别分为：服务器级别，数据库级别，表级别，列级别。优先级越来越大，比如如果有设置了数据库级别的字符集那就不会去用服务器级别，如果没有设置那就用服务器级别的字符集。比较规则也同理。服务器级别和其它几个级别的设置方式有点不同，具体如下：</p><ul><li>服务器级别：服务器级别的在启动选项中设置，例如在配置选项中写入 character_set_server&#x3D;字符集名称，collaction_set_server&#x3D;比较规则。</li><li>其它：在创建时可以指明，也可以在后续进行更改，例如<code>CHARCTER SET GB2312 和 COLLATE gb2312_chinese_ci</code></li><li>可以通过相应的系统变量(SHOW VARIABLES [LIKE 匹配模式])查看各级别当前的字符集，具体如下：<ul><li>服务器级别：SHOW VARIABLES LIKE ‘character_set_server’，便可查看，同样的还有’character_set_collaction’</li><li>数据库级别：‘character_set_database’ 和 ‘collaction_set_database’，当然前提你得先输入USE进入相应数据库</li><li>表级别：SHOW CREATE TABLE ‘表名’</li><li>列级别：show full columns from ‘表名’</li></ul></li><li>需要注意的一点：在上方数据库及以下级别中我们可以中途修改它们的字符集和比较规则，但要注意一点：对于字段中的值，转换后的字符集一定要能表示，不然就会出错</li></ul><p>上面我们展示了各级别查看和修改字符集的方法，在修改时都是一起修改的，那如果只修改其中一个会怎样呢？</p><ul><li>只修改字符集：如果我们只修改了字符集，由于比较规则是和字符集想对应的，所以比较规则也会被改为字符集的默认比较规则。</li><li>只修改比较规则：这个也同理，字符集也要进行修改，修改成支持该比较规则的字符集。</li></ul><h3 id="客户端和服务器通信中的字符集："><a href="#客户端和服务器通信中的字符集：" class="headerlink" title="客户端和服务器通信中的字符集："></a>客户端和服务器通信中的字符集：</h3><blockquote><p>毋庸质疑，字符在编码时和解码时使用不同的字符集是绝对行不通的，如果真这样做了，解码后就会出现我们的熟客–乱码。正常人谁会用不同的字符集去编解码字符呀，但Mysql的客户端和服务器可能会发生这样的情况，具体如下。</p></blockquote><p>首先，我们知道我们在客户端向服务器发送请求时其实发送的是一段字符串，服务器向客户端发送的响应结果也是一段字符串，而字符串其实就是一段对字符进行编码而形成的二进制数据，在mysql中对这段二进制数据的处理涉及多个步骤，它也会被不同的字符集进行编解码。主要涉及到以下三个系统变量：</p><ul><li>character_set_client:服务器解码时使用的字符集。</li><li>character_set_connection:在上一步解码后的数据会被该字符集重新编码。</li><li>character_set_result: 服务器返回的结果编码时使用的字符集。</li></ul><p>我们将整个过程分为三个阶段，看看其中可能发生的问题。</p><p><strong>请求阶段：</strong></p><p>Mysql客户端会使用操作系统使用的字符集（windows为gbk，类Unix为utf8）对请求进行编码，需要注意的是如果我们使用的是可视化工具如navicat来发送，因为其里面可以设置字符集所以可能和系统不一样。</p><p>Mysql服务器端接收到请求的字符串采用的就是和character_set_client一样的字符集，所以其就使用character_set_client去解码，这时就会可能就会出现第一处便解码使用的字符集不同的情况，这样的结果就是服务器不能正确解码，无法明白客户端的请求，无法做出正确的回应。</p><p><strong>处理阶段：</strong></p><p>如果第一步都正常完成了，那么解码后的字符串就会再被character_set_connection编码，然后如果该请求涉及的列的字符集刚好和character_set_connection一样，那么它就会直接进行相应的操作，否则还要进行一次字符集转换的操作，最后拿得结果。</p><p><strong>返回阶段：</strong></p><p>上面处理结果最后拿到的记录也是编码过的二进制数据，我们首先对其解码，解码后再通过character_set_result进行编码，编码后发送到客户端，这里又可能出现便解码使用的字符集不同的情况，而这次导致的后果，就是<strong>乱码</strong>，客户端无法理解服务端返回的二进制数据。</p><p>很头晕，转来转去的，所以我们一般将上面三个系统变量设置为与客户端使用的字符集一致的情况，也减少了许多无谓的字符集转换。Mysql为我们设置一个方便的指令：<code>SET NAMES 字符集名</code>,这样就能一次性设置三个系统变量。另外如果想在服务器启动的时候这三个系统变量就一样，可以指定一个<code>default-character-set</code>的启动选项。</p><h3 id="比较规则的应用："><a href="#比较规则的应用：" class="headerlink" title="比较规则的应用："></a>比较规则的应用：</h3><p>比较规则的应用，说一个我们较常见的例子就是排序，排序时我们就是遵循比较规则得出一定的顺序。而且同一个字符集可以有不同的比较规则（例如区分字母大小写的，和不区分大小写的），所以当我们对某个字符串做比较或者对某个字符串的列做排序操作时没有得到想象中的结果，可以考虑一下是不是比较规则的问题。</p>]]></content>
    
    
    <categories>
      
      <category>打怪升级</category>
      
      <category>Mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>🍔Redis数据结构----字典</title>
    <link href="/2022/09/24/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84----%E5%AD%97%E5%85%B8/"/>
    <url>/2022/09/24/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84----%E5%AD%97%E5%85%B8/</url>
    
    <content type="html"><![CDATA[<p>Redis高效的原因很大一部分原因就是因为数据库的底层实现为字典，Redis的字典暗藏了什么玄机，让我们一探究竟。</p><span id="more"></span><h1 id="🍔Redis数据结构—-字典"><a href="#🍔Redis数据结构—-字典" class="headerlink" title="🍔Redis数据结构—-字典"></a>🍔Redis数据结构—-字典</h1><p><img src="https://img.tucang.cc/api/image/show/a38d8e52720e2e9b3d860a50e7e87e8a"></p><h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><blockquote><p>字典是一种用于存储键值对的数据结构，里面的值被唯一的键一一映射，具有高效的查询能力，和链表同样的是C语言没有自带字典，所以Redis自己实现了字典。</p><p>字典在Redis中很受重用，比如Redis数据库的底层实现正是字典，还有Hash键的底层实现之一也是字典（当键比较多或者值都是较长的字符串时）</p></blockquote><h2 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><strong>dict.h&#x2F;dictht:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">type <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dictht</span>&#123;<br>  dictEntry **table;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sizemask;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> used;<br>&#125;dictht;<br></code></pre></td></tr></table></figure><ul><li>table: 哈希表节点指针数组，里面存放了指向该哈希表中哈希表节点的指针。</li><li>size：哈希表大小，即上方table的大小。</li><li>sizemask：始终是size-1,会在后面用于一起确定哈希表节点的存放位置。</li><li>used：该哈希表中已经拥有的节点。</li></ul><h3 id="哈希表节点："><a href="#哈希表节点：" class="headerlink" title="哈希表节点："></a>哈希表节点：</h3><p><strong>dict.h&#x2F;dictEntry:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">type <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dictEntry</span>&#123;<br><span class="hljs-type">void</span> *key;<br>  <span class="hljs-keyword">union</span>&#123;<br>    <span class="hljs-type">void</span> *val;<br>    uint64_tu64;<br>    int64_ts64;<br>&#125;v;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dictEntry</span> *next;<br>&#125;dictEntry;<br></code></pre></td></tr></table></figure><ul><li>key: 哈希表节点的键。</li><li>v：保存着哈希表节点的值，里面的值可以是一个int64&#x2F;uint64的整数也可以是一个指针。</li><li>next: 用于解决键冲突，用该指针指向了和他键值相同的节点。</li></ul><h3 id="字典："><a href="#字典：" class="headerlink" title="字典："></a>字典：</h3><p><strong>dict.h&#x2F;dict:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">type <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dict</span>&#123;<br>dictType *type;<br>  <span class="hljs-type">void</span> *<span class="hljs-keyword">private</span>;<br>  dictht ht[<span class="hljs-number">2</span>];<br>  <span class="hljs-type">int</span> rehashidx;<br>&#125;dict;<br></code></pre></td></tr></table></figure><ul><li>type和private这两个属性是为了针对不同类型的键值对，为创建多态字典而设置的。<ul><li>type：dictType结构中保存了一簇用于操作特定类型键值对的函数，redis为用途不同的字典设置了不同的特定类型函数。</li><li>private则是要传入这些函数的可选参数。</li></ul></li><li>ht：哈希表数组，一般使用时只会操作ht[0]，只有在rehash时才会用到ht[1]。</li><li>rehashidx：索引计数器变量，当该值设为-1时表示没有在进行rehash，设置为0时表示rehash正式开始，后面会讲它的用法。</li></ul><h2 id="哈希算法："><a href="#哈希算法：" class="headerlink" title="哈希算法："></a>哈希算法：</h2><p>还记得我们上边说的dict中的type属性吗？这里的哈希函数正是来自于那里面，也就是dict-&gt;type-&gt;hashFunction(key);要想确定键值对的存放位置，我们要知道的就是两个值：hash值和索引值。hash值是通过hashFunction计算得的，索引值是通过与dictht的sizemask做与运算得到的，即<code>index = hash &amp; dict-&gt;ht[x].sizemask</code>，x表示可能为0或者1。</p><p>我们在dict的实现中也有说到type属性是针对不同类型键值对而设计的，redis会为了不同用途的键值对而设置不同的特定类型函数，所以这里的hashFunction是会根据情况改变的，例如在字典做为redis数据库底层实现时，Redis就采用了一个叫做MurmurHash2的算法来计算哈希值，它的特点是即使我们输入的键具有一定规律性，它算出来的hash值还是能有一个较好的随机分布性。</p><h2 id="解决键冲突："><a href="#解决键冲突：" class="headerlink" title="解决键冲突："></a>解决键冲突：</h2><p>这部分可以总结为两个关键词，拉链法，头插法。</p><p>记得我们上边介绍哈希表节点实现的实现提到的next指针吗？即当我们计算出来的hash值相同时，发生hash冲突时，redis会使用这个next指针将和其hash值相同的节点给串起来，形成链表。</p><p>而为了提高插入的效率，redis采用了头插法，也就是将新节点添加到链表的表头位置（时间复杂度为O(1）)。</p><h2 id="Rehash："><a href="#Rehash：" class="headerlink" title="Rehash："></a>Rehash：</h2><p>在哈希表使用了很长时间后，随着插入和删除的次数增多，相应的就造成了链表节点数目过多或过少的问题。所以就要进行Rehash，让负载因子（used&#x2F;size）维持在一个正常水平。</p><h3 id="大致流程："><a href="#大致流程：" class="headerlink" title="大致流程："></a>大致流程：</h3><p>在dict实现中我们知道每个dict都维护了两个hash表，也说了正常使用时操作都会在ht[0]上进行，hash[1]则是在进行rehash的时候才会用到，这里我们在补充一点：ht[1]只有在需要进行rehash时才会被分配地址空间，平时是没有的。所以我们rehash的<strong>第一步：为ht[1]分配地址空间</strong>，分配地址空间也是有规则的，我们细细聊下：</p><ul><li>拓展：当我们的键值对太多而导致进行rehash时，我们就相当于对哈希表进行拓展，redis的规则是，拓展后的大小为<strong>大于或等于</strong>  当前拥有的键值对的数量的2倍的  **首个2<sup>n</sup>**。</li><li>缩小：拓展后的大小为<strong>大于或等于</strong>  当前拥有的键值对的数量的  <strong>首个2<sup>n</sup>。</strong></li></ul><p>而至此rehash还没真正开始，还记得rehashidx吗？我们执行<strong>第二步：将rehashidx设为0</strong>，然后我们就正式开始<strong>第三步：rehash</strong>了，rehash其实就是对ht[0]的所有键值对进行hash运算，然后存放到ht[1]中并且在存放成功后删除ht[0]上相应的指针。<strong>这里在补充一点</strong>，如果移除的哈希表节点上next属性不为空，即有相同索引值的哈希表节点时，这些哈希表节点也会个一同rehash。当所有ht[0]上的键值对被转移完毕后，就要进行<strong>第四步：rehashidx设为-1，释放ht[0]的内存地址空间，并将ht[1]改为ht[0]<strong>，接着</strong>第五步：新建一个hash表，为下一次rehash做准备。</strong></p><h3 id="何时拓展和收缩："><a href="#何时拓展和收缩：" class="headerlink" title="何时拓展和收缩："></a>何时拓展和收缩：</h3><p>首先了解下三个概念：<strong>BGSave</strong>、<strong>负载因子</strong>和<strong>BGrewriteAOF</strong></p><ul><li>BGSave: 用于在后台异步保存当前数据库的数据到磁盘</li><li>BGrewriteAOF: 命令用于异步执行一个 AOF（AppendOnly File） 文件重写操作。重写会创建一个当前 AOF 文件的体积优化版本。即使 Bgrewriteaof 执行失败，也不会有任何数据丢失，因为旧的 AOF 文件在 Bgrewriteaof 成功之前不会被修改。</li><li>负载因子</li></ul><p>自动开始拓展的两种情况：</p><ul><li>当服务器没有在进行BGSave或者BGrewriteAOF，且哈希表的负载因子大于等于1时。</li><li>当服务器有在进行BGSave或者BGrewriteAOF，而哈希表的负载因子大于等于5时。</li></ul><p><strong>为什么？</strong></p><p>因为要进行BGSave或者BGrewriteAOF，服务器则需要创建子进程，而大多数操作系统都采用写时复制技术来优化子进程的使用效率，所以提高所需的负载因子要求，就能避免不必要的内存写入操作，最大限度地节约内存。</p><p>自动开始收缩的情况：当负载因子小于0.1时。</p><h2 id="渐进式Rehash"><a href="#渐进式Rehash" class="headerlink" title="渐进式Rehash:"></a>渐进式Rehash:</h2><h3 id="大致流程：-1"><a href="#大致流程：-1" class="headerlink" title="大致流程："></a>大致流程：</h3><p>对于键值对少的哈希表还好，如果是对于几万，甚至几十万大小数量的哈希表，想要一次性完成rehash那这短时间内庞大的计算量必然导致服务器停止服务。为了减少rehash对服务器性能的影响，redis采用了分多次，渐进式的方式来rehash。</p><p>渐进式rehash的步骤和上面讲的<strong>大致流程</strong>差不多，主要差别就是在第三步rehash上，下面我们讲讲渐进式rehash怎么个渐进法，顺接上面的第二步，索引计数器变量rehashidx被设为0，rehash正式开始，在rehash过程中，每次我们进行对字典的添加、删除、查找、或更新操作时，rehashidx就会进行遍历（自增，不会超过used），找到ht[0]上第一个还未被rehash的键值对，对其进行rehash，rehash完成后加1。</p><blockquote><p> 😊刚开始读书时不太理解这个rehashidx的用法，看了下源码后知道了。</p><p>其实它就是对应于ht[0]上的索引（数组下标），它进行一步步的+1，一步步判断当前table[rehashidx]是否已经被rehash，随着遍历的进行我们也能知道比rehashidx小的索引上的键值对一定已经被rehash了。它就像一把刷子，一步步地将整个哈希表全扫了。</p></blockquote><p>贴上相关源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dictRehash</span><span class="hljs-params">(dict *d, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// 最大可以接受的空bucket数量</span><br>    <span class="hljs-type">int</span> empty_visits = n*<span class="hljs-number">10</span>; <span class="hljs-comment">/* Max number of empty buckets to visit. */</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dictIsRehashing</span>(d)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// ht第一个位置放的未rehash「没有转移前」的数据，第二个位置放的rehash后的数据。</span><br>    <span class="hljs-keyword">while</span>(n-- &amp;&amp; d-&gt;ht_used[<span class="hljs-number">0</span>] != <span class="hljs-number">0</span>) &#123;<br>        dictEntry *de, *nextde;<br><br>        <span class="hljs-comment">/* Note that rehashidx can&#x27;t overflow as we are sure there are more</span><br><span class="hljs-comment">         * elements because ht[0].used != 0 */</span><br>         <span class="hljs-comment">// rehashidx的值不能超过最大值，发生溢出</span><br>        <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">DICTHT_SIZE</span>(d-&gt;ht_size_exp[<span class="hljs-number">0</span>]) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)d-&gt;rehashidx);<br>        <span class="hljs-keyword">while</span>(d-&gt;ht_table[<span class="hljs-number">0</span>][d-&gt;rehashidx] == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-comment">// 跳过空bucket</span><br>            d-&gt;rehashidx++;<br>            <span class="hljs-keyword">if</span> (--empty_visits == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 取出数组的rehashidx下标对应的值，</span><br>        de = d-&gt;ht_table[<span class="hljs-number">0</span>][d-&gt;rehashidx];<br>        <span class="hljs-comment">/* Move all the keys in this bucket from the old to the new hash HT */</span><br>        <span class="hljs-keyword">while</span>(de) &#123;<br>            <span class="hljs-type">uint64_t</span> h;<br><br>            nextde = de-&gt;next;<br>            <span class="hljs-comment">/* Get the index in the new hash table */</span><br>            <span class="hljs-comment">// 计算hash值</span><br>            h = <span class="hljs-built_in">dictHashKey</span>(d, de-&gt;key) &amp; <span class="hljs-built_in">DICTHT_SIZE_MASK</span>(d-&gt;ht_size_exp[<span class="hljs-number">1</span>]);<br>            de-&gt;next = d-&gt;ht_table[<span class="hljs-number">1</span>][h];<br>            d-&gt;ht_table[<span class="hljs-number">1</span>][h] = de;<br>            d-&gt;ht_used[<span class="hljs-number">0</span>]--;<br>            d-&gt;ht_used[<span class="hljs-number">1</span>]++;<br>            <span class="hljs-comment">// de指向下一个</span><br>            de = nextde;<br>        &#125;<br>        <span class="hljs-comment">// 把ht【0】置空</span><br>        d-&gt;ht_table[<span class="hljs-number">0</span>][d-&gt;rehashidx] = <span class="hljs-literal">NULL</span>;<br>        d-&gt;rehashidx++;<br>    &#125;<br><br>    <span class="hljs-comment">/* Check if we already rehashed the whole table... */</span><br>    <span class="hljs-keyword">if</span> (d-&gt;ht_used[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;<br>         <span class="hljs-comment">// chek ht,并释放，ht第一个元素为空，则把 ht[0] = ht[1],这个时候ht[1]为空，ht[0]为整体rehash后的值</span><br>        <span class="hljs-built_in">zfree</span>(d-&gt;ht_table[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">/* Copy the new ht onto the old one */</span><br>        d-&gt;ht_table[<span class="hljs-number">0</span>] = d-&gt;ht_table[<span class="hljs-number">1</span>];<br>        d-&gt;ht_used[<span class="hljs-number">0</span>] = d-&gt;ht_used[<span class="hljs-number">1</span>];<br>        d-&gt;ht_size_exp[<span class="hljs-number">0</span>] = d-&gt;ht_size_exp[<span class="hljs-number">1</span>];<br>        _dictReset(d, <span class="hljs-number">1</span>);<br>        d-&gt;rehashidx = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* More to rehash... */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>rehash完后面就都一样了。</p><p>再附上rehash过程图解方便理解：</p><p><img src="https://img.tucang.cc/api/image/show/4beb763084ec1f97bc9250f870d5294e"></p><p><img src="https://img.tucang.cc/api/image/show/7236eccfd86f89e0d1cb2a3e942d69d7"></p><p><img src="https://img.tucang.cc/api/image/show/6a8c17c270bfa05c2e2ce8339b6c5322"></p><p><img src="https://img.tucang.cc/api/image/show/d288532687c692e98cbdb0f3dcecb9ea"></p><p><img src="https://img.tucang.cc/api/image/show/47b8f5c6f584c203089110b5c794a9db"></p><p><img src="https://img.tucang.cc/api/image/show/cfdb63f74d82e0644c69b71a889766ab"></p><p>渐进式rehash的好处就是它采取了分而治之的方式，将rehash键值对所需的计算均摊到对字典的每个添加、删除、查找、和更新操作上，从而避免了集中式rehash带来的庞大计算量。</p><h3 id="渐进式rehash期间的哈希表操作："><a href="#渐进式rehash期间的哈希表操作：" class="headerlink" title="渐进式rehash期间的哈希表操作："></a>渐进式rehash期间的哈希表操作：</h3><p>因为在rehash期间，键值对会分布在ht[0]和ht[1]上，所以在进行如删除、查找、更新等操作时就会先在ht[0]上找相应键值对，找不到则会再去ht[1]上找，而在添加操作上，则键值对会被直接添加到ht[1],这样ht[0]的键值对就会只减不增，随着rehash进行最后成为一张空表。</p>]]></content>
    
    
    <categories>
      
      <category>打怪升级</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>🥇Redis数据结构----SDS，链表</title>
    <link href="/2022/09/10/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84----SDS%EF%BC%8C%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/09/10/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84----SDS%EF%BC%8C%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>redis为什么能这么高效是有原因，这次我们来学习下保存字符串的SDS和链表在Redis中是如何实现的以及他们的特性。</p><span id="more"></span><h1 id="🥇Redis数据结构—-SDS，链表"><a href="#🥇Redis数据结构—-SDS，链表" class="headerlink" title="🥇Redis数据结构—-SDS，链表"></a>🥇Redis数据结构—-SDS，链表</h1><p><img src="https://img.tucang.cc/api/image/show/51ea04c60f6598e7527465564a39863e"></p><h2 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h2><blockquote><p>众所周知，C语音中的字符串底层实现为一个char类型数组，也就是一个字符数组，所以C字符串在Redis中仅在只需要一个字符串字面量的情况下使用，也就是用于一些不用修改的情景下，比如打印日志。</p><p>出于安全、效率与功能性等的要求Redis自己实现了一个存储字符串的结构–SDS</p><p>并且SDS在Redis中还被用于做缓冲区：AOF模块的AOF缓冲区，以及客户端状态中的输入缓存区</p></blockquote><h3 id="结构："><a href="#结构：" class="headerlink" title="结构："></a>结构：</h3><p>SDS的结构如下：(sds.h&#x2F;sdshdr)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sdshdr</span>&#123;<br>  <span class="hljs-type">int</span> len;<br>  <span class="hljs-type">int</span> free;<br>  <span class="hljs-type">char</span> buf[];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>**len:**当前SDS保存的字符串长度</li><li><strong>free：</strong>当前SDS中未分配的字节长度</li><li><strong>buf：</strong> <strong>字节</strong>数组，用于保存字符串</li></ul><p>同时要注意到一点，虽然Redis自己实现了SDS，但保存的字符串中依然延续了以空字符（&#x2F;0）结尾的传统，SDS在分配空间时会预留一字节长度保存空字符，同时在字符串的末尾加上空字符，这些都由SDS自动完成。这样得到的一个最大好处就是可以复用C语言中对字符串的函数。</p><h3 id="与C字符串的区别："><a href="#与C字符串的区别：" class="headerlink" title="与C字符串的区别："></a>与C字符串的区别：</h3><h4 id="常数复杂度获取字符串长度："><a href="#常数复杂度获取字符串长度：" class="headerlink" title="常数复杂度获取字符串长度："></a>常数复杂度获取字符串长度：</h4><p>对于C字符串，获取字符串长度则是一个时间复杂度为O(n)的操作，因为它是通过一个个遍历得来的</p><p>在SDS的结构中我们可以看到<strong>len</strong>这一属性，它保存了当前SDS保存的字符串的长度，所以我们要获取字符串长度时则只需访问这一属性就可以了。</p><h4 id="杜绝缓冲区溢出："><a href="#杜绝缓冲区溢出：" class="headerlink" title="杜绝缓冲区溢出："></a>杜绝缓冲区溢出：</h4><p>我们通过一个例子来介绍缓冲区溢出：</p><p>例如我们有两个紧邻的字符串，也就是说他们在内存空间上的紧邻着的，我们调用了函数<code>char *strcat(char *dest,const char *src)</code>(该函数会把src的内容拼接到dest上)，而这个函数是假定用户在执行这个函数时已经为dest分配了足够多的内存了，可以容纳src字符串中的所有内容，而一旦这个假设不成立，则会发生缓冲区溢出。</p><p><img src="/" alt="相邻的两个c字符串"></p><p>例如这个上面这个例子，则是‘MongoDB’的内容会被修改。</p><p>而在SDS中，当SDS API需要进行对SDS的修改时，会先判断当前的SDS的空间是否满足此次修改，不满足的话，像上面的例子，SDS则会先扩容到合适的空间后再进行修改，<strong>所以使用SDS既不用自行申请空间，也不会出现缓冲区溢出的情况。</strong></p><p>还是上面这个例子，在SDS中我们调用的是<code>sdscat</code>，其在进行拼接操作前会先查看空间是否满足，发现不满足则先申请空间，</p><p><img src="https://img.tucang.cc/api/image/show/d41eea68a1e12cae6ff192df4ec6060a" alt="before_sdscat"></p><p>申请后，再进行拼接操作。拼接后如下：</p><p><img src="https://img.tucang.cc/api/image/show/21549905d4d141fe5526e554de5cabe4" alt="after_sdscat"></p><p>同时我们注意到一点，在分配足够的空间来完成拼接的同时，SDS还同样申请了同样大小空间的未分配空间，这不是偶然，而是SDS的预分配策略，详情如下。</p><h4 id="减少修改字符串时的内存重分配次数："><a href="#减少修改字符串时的内存重分配次数：" class="headerlink" title="减少修改字符串时的内存重分配次数："></a>减少修改字符串时的内存重分配次数：</h4><p>首先我们先说下C字符串的痛点，由于并没有<strong>len</strong>这一属性，所以底层数组的长度永远是字符串长度+1，正是存在这种字符串长度与底层数组长度的关联，所以在每次进行增长或缩短操作前总需要进行一次内存重分配，比如增长操作中的拼接操作，那么在执行操作前则必须进行一次内存重分配来扩展底层数组的空间，如果忘记这步操作则会造成缓冲区溢出，而比如缩短操作中的截断操作，在执行完此操作后必须进行一次内存重分配来回收这部分不再使用的内存，否则将会造成内存泄漏。<strong>而内存重分配涉及复杂的算法，并且需要执行系统调用，所以它通常是一个比较耗时的操作</strong></p><p>而对于Redis这样一个追求效率，频繁修改的场合，显然每次修改都要进行一次内存重分配是不能接受的。综上原因，Redis使用<strong>free</strong>属性，也就是未分配空间来断开字符串长度与底层数组长度的关联。数组里不再仅有字符串，还有未使用的空间。</p><p>通过未分配空间，SDS实现了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>来减少内存重分配的次数。</p><p><strong>空间预分配：</strong></p><p>上面拼接的例子我们已经看到了，当SDS API进行字符串增长操作，需要进行空间拓展的时候，SDS不仅分配了足够的空间来完成操作，还多分配了相同空间的未分配空间。这就是SDS的空间预分配策略，而分配空间的大小还与分配后SDS的长度有关（也就是len的值）,分两种情况：</p><ul><li>如果分配的SDS的长度&lt;1MB，则是和上面的情况一样，分配相同长度的未分配空间</li><li>如果分配的SDS的长度&gt;1MB，则是再分配1MB。</li></ul><p><strong>通过空间预分配策略，连续增长字符串N次时，内存重分配的次数从N次变为最多N次</strong></p><p><strong>惰性空间释放：</strong></p><p>与C字符串不同的是，SDS再进行缩短操作后并不会立即调用内存重分配来回收收缩后多出来的字节，而是用free属性将这些字节的数量记录下来，并等待将来使用。</p><h4 id="二进制安全："><a href="#二进制安全：" class="headerlink" title="二进制安全："></a>二进制安全：</h4><p>同样先说一下C字符串的痛点，我们知道C字符串是根据空字符来结尾的，所以在字符串里面不能包含空字符，否则最先被程序读入的空字符会被做为字符串的结尾，这些限制使得C字符串只能保存文本数据，而不能保存像图片，视频，压缩文件等的二进制数据</p><p>而SDS API则是二进制安全的，它会以处理二进制的方式来处理字符串，不会对输入的数据进行任何限制、过滤或假设，也就是<strong>数据在写入时什么样的，读出来就是怎么样的</strong>，这也是我们将SDS的buf属性称为<strong>字节数组</strong>的原因–<strong>Redis不是用这个数组来保存字符，而是用它来保存一系列二进制数据</strong>，最后虽然还是会在结尾加上空字符，但并不以其判断结尾，而是用<strong>len</strong>。</p><h4 id="兼容部分C字符串函数："><a href="#兼容部分C字符串函数：" class="headerlink" title="兼容部分C字符串函数："></a>兼容部分C字符串函数：</h4><p>上面我们有说到SDS延续了以空字符结尾的习惯，所以它可以直接复用一些C字符串的函数。</p><h2 id="链表："><a href="#链表：" class="headerlink" title="链表："></a>链表：</h2><blockquote><p>链表有着高效的节点重排能力，顺序性的节点访问方式，并且可以通过增删节点来灵活调整链表的长度。现在的高级编程语言能内置了链表这一数据结构，而C语言没有，所以Redis自己实现了链表。</p><p>在Redis中链表的使用场景：列表键的底层实现之一就是链表，即当列表的节点数量较多，或者列表存储的值都是较长的字符串时。除了列表键，链表还被用于发布与订阅，慢查询，监视器等功能，服务器端则还用来保存多个客户端的状态信息，客户端则还用来做输出缓冲区。</p></blockquote><h3 id="结构：-1"><a href="#结构：-1" class="headerlink" title="结构："></a>结构：</h3><p>节点结构（adlist.h&#x2F;listNode）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span>&#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span>* <span class="hljs-title">prev</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span>* <span class="hljs-title">next</span>;</span><br><span class="hljs-type">void</span>* value;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然通过两两的节点相连就能构成链表了，但Redis为了功能性，再包装了一层，直接定义了一个链表的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span>&#123;</span><br>listNode* head;<br>listNode* tail;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len;<br><span class="hljs-type">void</span>* (*dup)(<span class="hljs-type">void</span>* ptr);<br><span class="hljs-type">void</span> (*<span class="hljs-built_in">free</span>)(<span class="hljs-type">void</span> *ptr);<br><span class="hljs-type">int</span> (*match)(<span class="hljs-type">void</span>* ptr,<span class="hljs-type">void</span>* key);<br>&#125;<span class="hljs-built_in">list</span>;<br></code></pre></td></tr></table></figure><p>这里面包括了头节点，尾节点，节点个数，复制函数，释放函数，比较函数。</p><ul><li>dup 用于复制链表节点的值</li><li>free 用于释放链表节点的值</li><li>match 用于对比链表节点所保存的值和另一个输入值是否相等</li></ul><h3 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h3><p>Redis的链表特性可以总结如下：</p><ul><li>“无环”：head结点的父节点指针和tail节点的子指针都指向NULL。对链表的访问以NULL结尾。</li><li>“双端”：双向链表，访问某节点的父子节点的时间复杂度都是O(1)。</li><li>“头尾指针”：访问链表的头节点和尾节点的复杂度都是O(1)。</li><li>“len”: 因为增加了len属性，获取链表节点个数复杂度为O(1)。</li><li>“多态”：value的属性时void*，可以通过list结构的dup、free、match三个属性为节点设置特定类型函数，所以链表可以用于保存各种不同类型的值。</li></ul>]]></content>
    
    
    <categories>
      
      <category>打怪升级</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>🥤Context学习笔记</title>
    <link href="/2022/09/10/Context%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/10/Context%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>在我们学习 Go 的时候，肯定发现常常时不时就会看到在一些函数的的第一个参数就是 ctx context.Context，而这个context 在这边使用的目的及含义到底是什么呢，本篇我们一起来了解什么是 context，以及使用的场景及方式。</p><span id="more"></span><h1 id="🥤Context学习笔记"><a href="#🥤Context学习笔记" class="headerlink" title="🥤Context学习笔记"></a>🥤Context学习笔记</h1><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h72n6kt9hej30vq0hs0y2.jpg"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Context即上下文，我们可以将其想象做一个承载了截止日期、取消信号和其它请求范围值的包裹，在应用程序的各个层之间、连续调用的函数间穿梭。它主要被使用来实现以下功能：</p><ul><li>终止操作的取消信号</li><li>在一个完整的函数调用中为其中的每次调用携带所需的杂项数据</li></ul><p>我们根据这两个功能来好好认识下context。</p><h2 id="Cancel"><a href="#Cancel" class="headerlink" title="Cancel"></a>Cancel</h2><h3 id="为什么取消："><a href="#为什么取消：" class="headerlink" title="为什么取消："></a>为什么取消：</h3><p>简而言之，及时取消，为了防止我们的系统做不必要的工作。以一个完整的Web请求为例：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6ixprpipnj215008kjru.jpg"></p><p>如果一切正常，那么流程图如下所示：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6ixsldunkj213y05y0td.jpg"></p><p>但是，如果客户在中间取消请求，会发生什么？例如，如果客户端在请求中关闭浏览器，就会发生这种情况。</p><p>在不取消的情况下，即使这两项工作的结果无法得到利用，应用程序服务器和数据库还是会继续完成工作：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6ixvj2rtmj213w05umxy.jpg"></p><p>而我们理想中的状态如下，也就是在上层取消后，我们的下层的工作也跟着一起结束：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6ixyj94o6j21480800u8.jpg"></p><blockquote><p>context是Go并发控制的一大利器，我们这里先插播下Go的其他并发控制方式。</p></blockquote><h3 id="Go其他并发控制："><a href="#Go其他并发控制：" class="headerlink" title="Go其他并发控制："></a>Go其他并发控制：</h3><h4 id="WaitGroup："><a href="#WaitGroup：" class="headerlink" title="WaitGroup："></a>WaitGroup：</h4><p><strong>waitGroup常用于要并发执行多项相同的工作，并等到它们全部完成才可结束</strong>，一个简单的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>wg.Add(<span class="hljs-number">3</span>)<br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;i++&#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(num <span class="hljs-type">int</span>)</span></span>&#123;<br>fmt.Printf(<span class="hljs-string">&quot;PEngxjstudy done %d ! \n&quot;</span>,num)<br>wg.Done()<br>&#125;(i)<br>&#125;<br>wg.Wait()<br>fmt.Println(<span class="hljs-string">&quot;All Done !&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="channel-select"><a href="#channel-select" class="headerlink" title="channel+select:"></a>channel+select:</h4><p>和context的功能有点想象，channel和select的搭配使用常在主动取消的场景中被使用。一个简单的例子如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">channelSel</span><span class="hljs-params">()</span></span>&#123;<br>clo:=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;i++&#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(num <span class="hljs-type">int</span>)</span></span>&#123;<br><span class="hljs-keyword">for</span>&#123;<br><span class="hljs-keyword">select</span>&#123;<br><span class="hljs-keyword">case</span> &lt;-clo:<br>fmt.Println(<span class="hljs-string">&quot;PEnxJ&#x27;s study has been done !&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>fmt.Printf(<span class="hljs-string">&quot;PEnxxJ is studyind %d part \n&quot;</span>,num)<br>time.Sleep(<span class="hljs-number">1</span>*time.Second)<br>&#125;<br><br>&#125;<br>&#125;(i)<br>&#125;<br>time.Sleep(<span class="hljs-number">2</span>*time.Second)<br><span class="hljs-built_in">close</span>(clo)<br>time.Sleep(<span class="hljs-number">2</span>*time.Second)<br>fmt.Println(<span class="hljs-string">&quot;study done !&quot;</span>)<br>&#125;<br><br><br>PEnxxJ is studyind <span class="hljs-number">1</span> part <br>PEnxxJ is studyind <span class="hljs-number">2</span> part <br>PEnxxJ is studyind <span class="hljs-number">3</span> part <br>PEnxxJ is studyind <span class="hljs-number">3</span> part <br>PEnxxJ is studyind <span class="hljs-number">1</span> part <br>PEnxxJ is studyind <span class="hljs-number">2</span> part <br>PEnxJ<span class="hljs-string">&#x27;s study has been done !</span><br><span class="hljs-string">PEnxJ&#x27;</span>s study has been done !<br>PEnxJ<span class="hljs-string">&#x27;s study has been done !</span><br><span class="hljs-string">study done !</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><h3 id="Context"><a href="#Context" class="headerlink" title="Context:"></a>Context:</h3><p>上边我们提到了主动取消的<code>channel+select</code>，那我们为什么还要用context呢？其实一般使用已经挺不错了，只是如果遇到某些场景，例如处理一个请求衍生了很多协程，这些协程之间是相互关联的：需要共享一些全局变量、有共同的 deadline 等，而且可以同时被关闭。再用 <code>channel+select</code> 就会比较麻烦，这时就可以通过 context 来实现。</p><p>一句话：context 更适合用来一起解决 goroutine 之间<code>退出通知</code>、<code>元数据传递</code>的功能。而且还有一点如果一个goroutine1开了个goroutine2，goroutine2又开了个3，3又开了个4，而业务逻辑中会有一种情况：我们只想关掉3和4，那用selete+channel就会非常麻烦了。</p><p>搞明白后，我们正式开始看看context怎么用。</p><p>首先我们试着将上面的例子进行改写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Bycontext</span><span class="hljs-params">()</span></span>&#123;<br>ctx:=context.Background()<br>cancleCtx,cancle:=context.WithCancel(ctx)<br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;i++&#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(num <span class="hljs-type">int</span>)</span></span>&#123;<br><span class="hljs-keyword">for</span>&#123;<br><span class="hljs-keyword">select</span>&#123;<br><span class="hljs-keyword">case</span> &lt;-cancleCtx.Done():<br>fmt.Println(<span class="hljs-string">&quot;PEnxJ&#x27;s study has been done !&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>fmt.Printf(<span class="hljs-string">&quot;PEnxxJ is studyind %d part \n&quot;</span>,num)<br>time.Sleep(<span class="hljs-number">1</span>*time.Second)<br>&#125;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context)</span></span>&#123;<br><span class="hljs-keyword">select</span>&#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Println(<span class="hljs-string">&quot;Second groutine has been done !&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>fmt.Printf(<span class="hljs-string">&quot;Second groutine is run %d part \n&quot;</span>,num)<br>time.Sleep(<span class="hljs-number">1</span>*time.Second)<br>&#125;<br>&#125;(cancleCtx)<br><br>&#125;<br>&#125;(i)<br>&#125;<br>time.Sleep(<span class="hljs-number">2</span>*time.Second)<br>cancle()<br>time.Sleep(<span class="hljs-number">2</span>*time.Second)<br>fmt.Println(<span class="hljs-string">&quot;study done !&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面的代码，我们解析几个点：</p><ol><li>context.Background，在context包中和这个函数类似的还有一个叫context.TODO的函数，两者都是申请一个empty context来做父context。</li><li><code>context.WithCancel()</code>,传入一个父context后返回一个子context和一个cancle函数。</li><li>在 goroutine 中，使用 <code>&lt;-ctx.Done()</code> 来判断是否要结束</li><li>调用<code>cancel()</code>即可通知关闭groutine。</li></ol><p>下面我们进行更体系化的阐述，其实context取消主要有三个方面：</p><ol><li>倾听取消活动</li><li>发射取消事件</li><li>context超时</li></ol><h4 id="倾听取消："><a href="#倾听取消：" class="headerlink" title="倾听取消："></a>倾听取消：</h4><p><code>Context</code>提供了一个<code>Done()</code>方法。其实也就是返回一个channel，每次上下文收到取消事件时都会从这个channel收到空<code>struct&#123;&#125;</code>类型。我们以下面的web请求例子为例：一个需要两秒钟来处理事件的HTTP服务器。如果在此之前取消请求，我们希望立即返回：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.ListenAndServe(<span class="hljs-string">&quot;:8000&quot;</span>, http.HandlerFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>ctx := r.Context()<br>fmt.Fprint(os.Stdout, <span class="hljs-string">&quot;processing request\n&quot;</span>)<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-time.After(<span class="hljs-number">2</span> * time.Second):<br>w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;request processed&quot;</span>))<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Fprint(os.Stderr, <span class="hljs-string">&quot;request cancelled\n&quot;</span>)<br>&#125;<br>&#125;))<br>&#125;<br></code></pre></td></tr></table></figure><p>可以通过运行服务器并在浏览器上打开<a href="http://localhost:8000/">localhost:8000</a>来测试这一点。如果您在2秒前关闭浏览器，您应该会在终端窗口上看到“请求已取消”。</p><h4 id="发射取消事件："><a href="#发射取消事件：" class="headerlink" title="发射取消事件："></a>发射取消事件：</h4><p>也就是我们上面的例子，通过<code>context.WithCancel()</code>,传入一个父context后返回一个子context和一个cancle函数,当我们要取消时就调用cancel函数。</p><p>下面是一个简明点的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">operation1</span><span class="hljs-params">(ctx context.Context)</span></span> <span class="hljs-type">error</span> &#123;<br>time.Sleep(<span class="hljs-number">100</span> * time.Millisecond)<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;failed&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">operation2</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-time.After(<span class="hljs-number">500</span> * time.Millisecond):<br>fmt.Println(<span class="hljs-string">&quot;done&quot;</span>)<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Println(<span class="hljs-string">&quot;halted operation2&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ctx := context.Background()<br>ctx, cancel := context.WithCancel(ctx)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>err := operation1(ctx)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>cancel()<br>&#125;<br>&#125;()<br>operation2(ctx)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="context超时："><a href="#context超时：" class="headerlink" title="context超时："></a>context超时：</h4><p>通过调用<code>context.WithTimeout()</code>或者<code>context.WithDeadline()</code>来获得一个子context和一个cancle函数，其实使用方法和上边的发射取消事件差不多，只不过在这里，我们的context里面有一个计时器，当到时间时就会自动cancle。例如下面的例子，一个HTTP API请求我们不想它消耗时间太长，那么就可以做：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ctx := context.Background()<br>ctx, _ = context.WithTimeout(ctx, <span class="hljs-number">100</span>*time.Millisecond)<br><br>req, _ := http.NewRequest(http.MethodGet, <span class="hljs-string">&quot;http://google.com&quot;</span>, <span class="hljs-literal">nil</span>)<br>req = req.WithContext(ctx)<br><br>client := &amp;http.Client&#123;&#125;<br>res, err := client.Do(req)<br><span class="hljs-comment">// If the request failed, log to STDOUT</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Request failed:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// Print the status code if the request succeeds</span><br>fmt.Println(<span class="hljs-string">&quot;Response received, status code:&quot;</span>, res.StatusCode)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Context上下文值："><a href="#Context上下文值：" class="headerlink" title="Context上下文值："></a>Context上下文值：</h2><p>对于跨多个函数完成的操场，常用的值的使用，相比于在整个函数调用中一直将它们作为变量传递，使用上下文变量来传递是更惯用的方式。这也是context的最重要功能之一。</p><p>使用方法：调用<code>context.WithValue()</code>传入一个父context，和一个键值对，并且我们要知道的是，一个子context只能绑定一个键值对。</p><p>考虑一个具有多个函数调用的操作，并使用一个公共ID来识别它的身份。</p><p>实现这一点，天真点的方法是为每个函数调用传递ID：</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// create a random integer as the ID</span><br>rand.Seed(time.Now().Unix())<br>id := rand.Int()<br>operation1(id)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">operation1</span><span class="hljs-params">(id <span class="hljs-type">int64</span>)</span></span> &#123;<br><span class="hljs-comment">// do some work</span><br>log.Println(<span class="hljs-string">&quot;operation1 for id:&quot;</span>, id, <span class="hljs-string">&quot; completed&quot;</span>)<br>operation2(id)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">operation2</span><span class="hljs-params">(id <span class="hljs-type">int64</span>)</span></span> &#123;<br><span class="hljs-comment">// do some work</span><br>log.Println(<span class="hljs-string">&quot;operation2 for id:&quot;</span>, id, <span class="hljs-string">&quot; completed&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将其改为使用context实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">const</span> keyID = <span class="hljs-string">&quot;id&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>rand.Seed(time.Now().Unix())<br>ctx := context.WithValue(context.Background(), keyID, rand.Int())<br>operation1(ctx)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">operation1</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br><span class="hljs-comment">// do some work</span><br><br><span class="hljs-comment">// we can get the value from the context by passing in the key</span><br>log.Println(<span class="hljs-string">&quot;operation1 for id:&quot;</span>, ctx.Value(keyID), <span class="hljs-string">&quot; completed&quot;</span>)<br>operation2(ctx)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">operation2</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br><span class="hljs-comment">// do some work</span><br><br><span class="hljs-comment">// this way, the same ID is passed from one function call to the next</span><br>log.Println(<span class="hljs-string">&quot;operation2 for id:&quot;</span>, ctx.Value(keyID), <span class="hljs-string">&quot; completed&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>使用context来实现变量的传递还有以下优点：</p><ul><li><strong>线程安全</strong>：设置上下文键后，您无法修改上下文键的值。为给定密钥设置另一个值的唯一方法是使用<code>context.WithValue</code></li><li>这是<strong>规范的</strong>：context包在整个Go的官方库和应用程序中广泛用于传输操作范围的数据。即便于他人使用我们的函数。</li></ul><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><p><strong>不良做法 - 一切使用上下文</strong></p><p>应该注意的是，虽然您当然可以使用上下文在应用程序的层之间传递信息，但您绝对需要仅将其用于真正需要传播的东西。</p><p>您不应该将上下文用作所有信息的桶。这是一个补充对象，您可以存储<code>request IDs</code>或<code>trace IDs</code>等内容，然后用于日志记录和跟踪目的。</p><h2 id="Context底层数据结构："><a href="#Context底层数据结构：" class="headerlink" title="Context底层数据结构："></a>Context底层数据结构：</h2><p>context在底层中其实是一个接口，它的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">interface</span> &#123;<br>Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>)<br>Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>Err() <span class="hljs-type">error</span><br>Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Deadline()：返回该context关闭取消的时间</li><li>Done()：返回一个channel，这个 Channel 会在当前工作完成或者上下文被取消后关闭，多次调用 Done 方法会返回同一个 Channel；</li><li>Err — 返回 context.Context 结束的原因，它只会在 Done 方法对应的 Channel 关闭时返回非空的值；<ol><li>如果 context.Context 被取消，会返回 Canceled 错误；</li><li>如果 context.Context 超时，会返回 DeadlineExceeded 错误；</li></ol></li><li>Value()：从 context.Context 中获取键对应的值。</li></ul><h3 id="Background、TODO"><a href="#Background、TODO" class="headerlink" title="Background、TODO"></a>Background、TODO</h3><p>两个方法都会返回预先初始化好的私有变量 <code>background</code> 和 <code>todo</code>，它们会在同一个 Go 程序中被复用：即</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Background</span><span class="hljs-params">()</span></span> Context &#123;<br><span class="hljs-keyword">return</span> background<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TODO</span><span class="hljs-params">()</span></span> Context &#123;<br><span class="hljs-keyword">return</span> todo<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个私有变量都是通过 <code>new(emptyCtx)</code> 语句初始化的，它们是指向私有结构体 <a href="https://draveness.me/golang/tree/context.emptyCtx"><code>context.emptyCtx</code></a> 的指针，这是最简单、最常用的context类型：<strong>做为父context</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> emptyCtx <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span></span> Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span></span> Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125; &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span></span> Err() <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*emptyCtx)</span></span> Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从上述代码中，我们不难发现 <a href="https://draveness.me/golang/tree/context.emptyCtx"><code>context.emptyCtx</code></a> 通过空方法实现了 <a href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 接口中的所有方法，它没有任何功能。</p><h3 id="WithCancle"><a href="#WithCancle" class="headerlink" title="WithCancle():"></a>WithCancle():</h3><ol><li><p>调用newCancelCtx方法，传入父context，组装出一个私有结构体context.cancelCtx</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A cancelCtx can be canceled. When canceled, it also cancels any children</span><br><span class="hljs-comment">// that implement canceler.</span><br><span class="hljs-keyword">type</span> cancelCtx <span class="hljs-keyword">struct</span> &#123;<br>Context<br><br>mu       sync.Mutex            <span class="hljs-comment">// protects following fields</span><br>done     <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;         <span class="hljs-comment">// created lazily, closed by first cancel call</span><br>children <span class="hljs-keyword">map</span>[canceler]<span class="hljs-keyword">struct</span>&#123;&#125; <span class="hljs-comment">// set to nil by the first cancel call</span><br>err      <span class="hljs-type">error</span>                 <span class="hljs-comment">// set to non-nil by the first cancel call</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>调用context.propagateCancel，构建父子context之间的关联，当父context被关闭时，子context也会同时关闭。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// propagateCancel arranges for child to be canceled when parent is.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">propagateCancel</span><span class="hljs-params">(parent Context, child canceler)</span></span> &#123;<br>done := parent.Done()<br><span class="hljs-keyword">if</span> done == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// parent is never canceled // 父ctx不具备cancel能力，则无需建立父子关联</span><br>&#125;<br><br>  <span class="hljs-comment">// 判断父ctx是否已经进入Done状态</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-done:<br><span class="hljs-comment">// parent is already canceled</span><br>child.cancel(<span class="hljs-literal">false</span>, parent.Err())<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>&#125;<br><br><span class="hljs-keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123; <span class="hljs-comment">// parentCancelCtx方法需要重点关注</span><br>p.mu.Lock()<br><span class="hljs-keyword">if</span> p.err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// parent has already been canceled</span><br>child.cancel(<span class="hljs-literal">false</span>, p.err)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> p.children == <span class="hljs-literal">nil</span> &#123;<br>p.children = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[canceler]<span class="hljs-keyword">struct</span>&#123;&#125;)<br>&#125;<br>p.children[child] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br>p.mu.Unlock()<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>atomic.AddInt32(&amp;goroutines, +<span class="hljs-number">1</span>)<br>    <br>    <span class="hljs-comment">// 当父ctx非cancelCtx标准实现的情况下，需要同时监听父子ctx的Done()信号</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-parent.Done():<br>child.cancel(<span class="hljs-literal">false</span>, parent.Err())<br><span class="hljs-keyword">case</span> &lt;-child.Done():<br>&#125;<br>&#125;()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>propagateCancle的流程又可以总结如下：</p><ul><li><p>当 parent.Done() &#x3D;&#x3D; nil，也就是 parent 不会触发取消事件时（例如调用context.Backgroud生成的父context），当前函数会直接返回；</p></li><li><p>当 child 的继承链包含可以取消的上下文时，会判断 parent 是否已经触发了取消信号；如果已经被取消，child 会立刻被取消；</p></li><li><p>如果没有被取消，先通过parentCanclectx判断父context是否为cancleCtx类型，而不是开发者自定义的类型、而实现了 context.Context 接口并在 Done() 方法中返回了非空的channel，判断完发现父context就是cancleCtx,那child会被加入 parent的children列表中,等待parent释放取消信号；如果不是cancleCtx类型，则会开一个goroutine来同时监听父context和子context的Done()返回的channel是否关闭，如果是父context先关闭，那它将调用方法将子context也一起关闭。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// parentCancelCtx returns the underlying *cancelCtx for parent.</span><br><span class="hljs-comment">// It does this by looking up parent.Value(&amp;cancelCtxKey) to find</span><br><span class="hljs-comment">// the innermost enclosing *cancelCtx and then checking whether</span><br><span class="hljs-comment">// parent.Done() matches that *cancelCtx. (If not, the *cancelCtx</span><br><span class="hljs-comment">// has been wrapped in a custom implementation providing a</span><br><span class="hljs-comment">// different done channel, in which case we should not bypass it.)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parentCancelCtx</span><span class="hljs-params">(parent Context)</span></span> (*cancelCtx, <span class="hljs-type">bool</span>) &#123;<br>done := parent.Done()<br><span class="hljs-keyword">if</span> done == closedchan || done == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br>p, ok := parent.Value(&amp;cancelCtxKey).(*cancelCtx) <span class="hljs-comment">// 通过一个特殊的cancelCtxKey向上递归寻找父路径中最近的cancelCtx</span><br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br>p.mu.Lock()<br>ok = p.done == done <span class="hljs-comment">// 如果父ctx.Done和父路径中最近的cancelCtx的Done不是同一个值，则表示父ctx非cancelCtx标准实现</span><br>p.mu.Unlock()<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">return</span> p, <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>返回上面组装成的context</p></li><li><p>cancleCtx，特别之处就在于它里面加了锁和实现了cancle方法，cancle方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// cancel closes c.done, cancels each of c&#x27;s children, and, if</span><br><span class="hljs-comment">// removeFromParent is true, removes c from its parent&#x27;s children.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cancelCtx)</span></span> cancel(removeFromParent <span class="hljs-type">bool</span>, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;context: internal error: missing cancel error&quot;</span>)<br>&#125;<br>c.mu.Lock()<br><span class="hljs-keyword">if</span> c.err != <span class="hljs-literal">nil</span> &#123;<br>c.mu.Unlock()<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// already canceled</span><br>&#125;<br>c.err = err<br> <br>d, _ := c.done.Load().(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-keyword">if</span> d == <span class="hljs-literal">nil</span> &#123;<br>c.done.Store(closedchan)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">close</span>(d)<br>&#125;<br>  <br>  <span class="hljs-comment">// 标准cancelCtx，还需要循环每个child，依次cancel</span><br><span class="hljs-keyword">for</span> child := <span class="hljs-keyword">range</span> c.children &#123;<br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> acquiring the child&#x27;s lock while holding parent&#x27;s lock.</span><br>child.cancel(<span class="hljs-literal">false</span>, err)<br>&#125;<br>c.children = <span class="hljs-literal">nil</span><br>c.mu.Unlock()<br><br><span class="hljs-keyword">if</span> removeFromParent &#123;<br>removeChild(c.Context, c)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="WithTimeout、WithDeadline："><a href="#WithTimeout、WithDeadline：" class="headerlink" title="WithTimeout、WithDeadline："></a>WithTimeout、WithDeadline：</h3><p>两者都是生成一个<strong>timerCtx，timerCtx嵌入了上面说的cancelCtx，</strong>直接可以使用它的cancle方法,同样也理所应当地可以使用锁和有children字段等。在此基础上添加了一个timer的字段来定时取消，添加了一个Deadline来返回有效时间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> timerCtx <span class="hljs-keyword">struct</span> &#123;<br>cancelCtx<br>timer *time.Timer <span class="hljs-comment">// Under cancelCtx.mu.</span><br><br>deadline time.Time<br>&#125;<br></code></pre></td></tr></table></figure><p>而其实WithTimeout里面最终调用的是WithDeadline方法。所以这两个方法的关键的就是方法WithDeadline，WithDeadline方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithDeadline</span><span class="hljs-params">(parent Context, d time.Time)</span></span> (Context, CancelFunc) &#123;<br><span class="hljs-keyword">if</span> parent == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;cannot create context from nil parent&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;<br><span class="hljs-comment">// The current deadline is already sooner than the new one.</span><br><span class="hljs-keyword">return</span> WithCancel(parent)<br>&#125;<br>c := &amp;timerCtx&#123;<br>cancelCtx: newCancelCtx(parent),<br>deadline:  d,<br>&#125;<br>propagateCancel(parent, c)<br>dur := time.Until(d)<br><span class="hljs-keyword">if</span> dur &lt;= <span class="hljs-number">0</span> &#123;<br>c.cancel(<span class="hljs-literal">true</span>, DeadlineExceeded) <span class="hljs-comment">// deadline has already passed</span><br><span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">false</span>, Canceled) &#125;<br>&#125;<br>c.mu.Lock()<br><span class="hljs-keyword">defer</span> c.mu.Unlock()<br><span class="hljs-keyword">if</span> c.err == <span class="hljs-literal">nil</span> &#123;<br>c.timer = time.AfterFunc(dur, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">// 主要多出time.AfterFunc相关逻辑</span><br>c.cancel(<span class="hljs-literal">true</span>, DeadlineExceeded)<br>&#125;)<br>&#125;<br><span class="hljs-keyword">return</span> c, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c.cancel(<span class="hljs-literal">true</span>, Canceled) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里还要注意一点的是，上面说了一点：因为timeCtx是组装了cancleCtx所以可以直接使用它的cancle方法，但实际是因为两者在cancle时还是有些不一样的，比如得关闭时间器等，所以timeCtx对这个方法进行了进一步的包装，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *timerCtx)</span></span> cancel(removeFromParent <span class="hljs-type">bool</span>, err <span class="hljs-type">error</span>) &#123;<br>c.cancelCtx.cancel(<span class="hljs-literal">false</span>, err)<br><span class="hljs-keyword">if</span> removeFromParent &#123;<br><span class="hljs-comment">// Remove this timerCtx from its parent cancelCtx&#x27;s children.</span><br>removeChild(c.cancelCtx.Context, c)<br>&#125;<br>c.mu.Lock()<br><span class="hljs-keyword">if</span> c.timer != <span class="hljs-literal">nil</span> &#123;<br>c.timer.Stop()<br>c.timer = <span class="hljs-literal">nil</span><br>&#125;<br>c.mu.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="WithValue"><a href="#WithValue" class="headerlink" title="WithValue:"></a>WithValue:</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> valueCtx <span class="hljs-keyword">struct</span> &#123;<br>Context<br>key, val <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>它实现了两个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *valueCtx)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%v.WithValue(%#v, %#v)&quot;</span>, c.Context, c.key, c.val)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *valueCtx)</span></span> Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br><span class="hljs-keyword">if</span> c.key == key &#123;<br><span class="hljs-keyword">return</span> c.val<br>&#125;<br><span class="hljs-keyword">return</span> c.Context.Value(key)<br>&#125;<br></code></pre></td></tr></table></figure><p>创建 valueCtx 的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithValue</span><span class="hljs-params">(parent Context, key, val <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> Context &#123;<br><span class="hljs-keyword">if</span> key == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;nil key&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> !reflect.TypeOf(key).Comparable() &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;key is not comparable&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对 key 的要求是可比较，因为之后需要通过 key 取出 context 中的值，可比较是必须的。</p><p>通过层层传递 context，最终形成这样一棵树：</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h7iy4y5z0zj308b0983yy.jpg"></p><p>和链表有点像，只是它的方向相反：Context 指向它的父节点，链表则指向下一个节点。通过 WithValue 函数，可以创建层层的 valueCtx，存储 goroutine 间可以共享的变量。</p><p>取值的过程，实际上是一个递归查找的过程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *valueCtx)</span></span> Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br><span class="hljs-keyword">if</span> c.key == key &#123;<br><span class="hljs-keyword">return</span> c.val<br>&#125;<br><span class="hljs-keyword">return</span> c.Context.Value(key)<br>&#125;<br></code></pre></td></tr></table></figure><p>它会顺着链路一直往上找，比较当前节点的 key<br>是否是要找的 key，如果是，则直接返回 value。否则，一直顺着 context 往前，最终找到根节点（一般是 emptyCtx），直接返回一个 nil。所以用 Value 方法的时候要判断结果是否为 nil。</p><p>因为查找方向是往上走的，所以，父节点没法获取子节点存储的值，子节点却可以获取父节点的值。</p><p><code>WithValue</code> 创建 context 节点的过程实际上就是创建链表节点的过程。两个节点的 key 值是可以相等的，但它们是两个不同的 context 节点。查找的时候，会向上查找到最后一个挂载的 context 节点，也就是离得比较近的一个父节点 context。所以，整体上而言，用 <code>WithValue</code> 构造的其实是一个低效率的链表。</p><p>如果你接手过项目，肯定经历过这样的窘境：在一个处理过程中，有若干子函数、子协程。各种不同的地方会向 context 里塞入各种不同的 k-v 对，最后在某个地方使用。</p><p>你根本就不知道什么时候什么地方传了什么值？这些值会不会被“覆盖”（底层是两个不同的 context 节点，查找的时候，只会返回一个结果）？你肯定会崩溃的。</p><p>而这也是 <code>context.Value</code> 最受争议的地方。很多人建议尽量不要通过 context 传值。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>Go的魔法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Context</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>🏵打造Go的武器--Viper✪</title>
    <link href="/2022/09/01/%E6%89%93%E9%80%A0Go%E7%9A%84%E6%AD%A6%E5%99%A8--Viper/"/>
    <url>/2022/09/01/%E6%89%93%E9%80%A0Go%E7%9A%84%E6%AD%A6%E5%99%A8--Viper/</url>
    
    <content type="html"><![CDATA[<p>Go程序的第一把武器：项目配置管理<strong>Viper</strong></p><span id="more"></span><h1 id="🏵打造Go的武器–Viper✪"><a href="#🏵打造Go的武器–Viper✪" class="headerlink" title="🏵打造Go的武器–Viper✪"></a>🏵打造Go的武器–Viper✪</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5s8nxlpa2j20fj08q0ti.jpg"></p><h2 id="什么是-Viper？"><a href="#什么是-Viper？" class="headerlink" title="什么是 Viper？"></a>什么是 Viper？</h2><p>Viper 是适用于 Go 应用程序（包括 Twelve-Factor App）的完整配置解决方案。它被设计为在应用程序中工作，并且可以处理所有类型的配置需求和格式。它支持</p><ul><li>设置默认值</li><li>可以读取 JSON，TOML，YAML，HCL，envfile 和 Java properties 格式的配置文件</li><li>实时监控和重新读取配置文件（可选）</li><li>读取环境变量中的配置信息</li><li>读取远程配置系统（etcd 或 Consul）中的配置信息，并监控配置信息发生改变</li><li>读取命令行参数中的配置信息</li><li>读取 buffer 中的配置信息</li><li>显式设置配置项</li></ul><p>可以将 Viper 视为满足您所有应用程序配置需求的注册表。</p><h2 id="快速使用🏆："><a href="#快速使用🏆：" class="headerlink" title="快速使用🏆："></a>快速使用🏆：</h2><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cn">go get github.com/spf13/viper<br></code></pre></td></tr></table></figure><p>使用：</p><p>先在main.go同级目录下，也就是项目目录下建立configs目录，并在其中创建<code>config.yaml</code>，写入以下内容：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">Database:</span><br><span class="hljs-symbol">  DBType:</span> mysql<br><span class="hljs-symbol">  Username:</span> root<br><span class="hljs-symbol">  Password:</span> <span class="hljs-number">123456</span><br><span class="hljs-symbol">  Host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">3306</span><br></code></pre></td></tr></table></figure><p>main.go:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;github.com/spf13/viper&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>viper.SetConfigName(<span class="hljs-string">&quot;config&quot;</span>)<br>viper.SetConfigType(<span class="hljs-string">&quot;yaml&quot;</span>)<br>viper.AddConfigPath(<span class="hljs-string">&quot;configs&quot;</span>)<br><span class="hljs-keyword">if</span> err := viper.ReadInConfig(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;error in read&quot;</span>)<br>&#125;<br>fmt.Println(viper.Get(<span class="hljs-string">&quot;Database.Host&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>很简单，无非就两部分：写入和读取，接下来按照这两部分我们讲讲更深入的用法</p></blockquote><h2 id="😍写入："><a href="#😍写入：" class="headerlink" title="😍写入："></a>😍写入：</h2><p>viper 支持在多个地方设置，使用下面的顺序依次读取：</p><ul><li>调用<code>Set</code>显示设置的；</li><li>命令行选项；</li><li>环境变量；</li><li>配置文件；</li><li>默认值。</li></ul><h3 id="viper-Set"><a href="#viper-Set" class="headerlink" title="viper.Set:"></a>viper.Set:</h3><p>Set的优先级是最高的，所以它可能被用来覆盖命令行参数，或者就单纯自己的应用逻辑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">viper.Set(<span class="hljs-string">&quot;redis.port&quot;</span>, <span class="hljs-number">5381</span>)<br></code></pre></td></tr></table></figure><h3 id="命令行参数："><a href="#命令行参数：" class="headerlink" title="命令行参数："></a>命令行参数：</h3><p>viper的命令行参数是搭配PFlag包一起用的，下面是例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> globalSource = pflag.String(<span class="hljs-string">&quot;global.source&quot;</span>, <span class="hljs-string">&quot;default(flag)&quot;</span>, <span class="hljs-string">&quot;identify the source of configuration&quot;</span>)<br><span class="hljs-keyword">var</span> serverAddress = pflag.String(<span class="hljs-string">&quot;server.address&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;server listen address, empty for all&quot;</span>)<br><span class="hljs-keyword">var</span> serverPort = pflag.Int(<span class="hljs-string">&quot;server.port&quot;</span>, <span class="hljs-number">8080</span>, <span class="hljs-string">&quot;server listen port&quot;</span><br><span class="hljs-comment">//Go中命令行参数绑定的写法，参数1为参数名称，参数2为默认值，参数3为输入提示</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">/* ... */</span><br>    pflag.Parse()  <span class="hljs-comment">//参数解析</span><br>    viper.BindPFlags(pflag.CommandLine) <span class="hljs-comment">//绑定到viper</span><br>    <span class="hljs-comment">/* ... */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>viper.BindPFlags()</code>自动绑定了所有命令行参数，如果只需要其中一部分，可以用viper.BingPflag()选择性绑定，如<code>viper.BindPFlag(&quot;global.source&quot;, pflag.Lookup(&quot;global.source&quot;))</code></p><h3 id="环境变量："><a href="#环境变量：" class="headerlink" title="环境变量："></a>环境变量：</h3><ul><li>AutomaticEnv()</li><li>BindEnv(string…) : error</li><li>SetEnvPrefix(string)</li><li>SetEnvKeyReplacer(*strings.Replacer)</li></ul><p>注意，环境变量是区分大小写的</p><p>首先说<code>AutomaticEnv()</code>和<code>BindEnv(string...)</code>，<code>AutomaticEnv()</code>较为简单，它的作用就是绑定所有的环境变量，eg：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 绑定环境变量</span><br>viper.AutomaticEnv()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 省略部分代码</span><br><br>fmt.Println(<span class="hljs-string">&quot;GOPATH: &quot;</span>, viper.Get(<span class="hljs-string">&quot;GOPATH&quot;</span>))<br>&#125;<br><span class="hljs-comment">//正常输出</span><br></code></pre></td></tr></table></figure><p>而<code>BindEnv</code>则是用于绑定特定的环境变量，它有两种输入参数的方式，当只输入一个参数时，则Key和要绑定的环境变量同名，如果输入的是两个参数，则第一个是Key，第二个是环境变量名，eg：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 绑定环境变量</span><br>viper.BindEnv(<span class="hljs-string">&quot;redis.port&quot;</span>)<br>viper.BindEnv(<span class="hljs-string">&quot;go.path&quot;</span>, <span class="hljs-string">&quot;GOPATH&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 省略部分代码</span><br>fmt.Println(<span class="hljs-string">&quot;go path: &quot;</span>, viper.Get(<span class="hljs-string">&quot;go.path&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>接着是<code>SetEnvPrefix</code>，用于设置前缀，他将会和<code>AutomaticEnv()</code>和<code>BindEnv</code>配套使用，当设置了前缀后，再调用这两个方法，后面使用<code>Get</code>的时候则会自动带上前缀，eg：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">SetEnvPrefix(<span class="hljs-string">&quot;spf&quot;</span>) <span class="hljs-comment">// 会自动转为大写</span><br>BindEnv(<span class="hljs-string">&quot;id&quot;</span>)<br><br>os.Setenv(<span class="hljs-string">&quot;SPF_ID&quot;</span>, <span class="hljs-string">&quot;13&quot;</span>)<br><br>id := Get(<span class="hljs-string">&quot;id&quot;</span>) <span class="hljs-comment">// 13</span><br></code></pre></td></tr></table></figure><p>最后是<code>SetEnvKeyReplacer</code>，这个算是一个辅助方法，用于对在调用<code>Get</code>的时候传入的key的符号进行替换，比如我们常用的是<code>Globar.Source</code>而环境变量里我们使用的是<code>Globar_Source</code>，这时就能用到了，eg：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">viper.AutomaticEnv()<br><br>viper.SetEnvPrefix(<span class="hljs-string">&quot;MYAPP&quot;</span>)<br><br>viper.SetEnvKeyReplacer(strings.NewReplacer(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;_&quot;</span>)<br>                        <br>fmt.Println(viper.Get(<span class="hljs-string">&quot;Globar.Source&quot;</span>))<br><span class="hljs-comment">//输出了 MYAPP_GLOBAL_SOURCE</span><br></code></pre></td></tr></table></figure><h3 id="配置文件（最常用）："><a href="#配置文件（最常用）：" class="headerlink" title="配置文件（最常用）："></a>配置文件（最常用）：</h3><p>正如快速使用里面提到的，步骤就是写好配置文件，再者就是<code>viper.SetConfigName(&quot;config&quot;)</code>，<code>viper.SetConfigType(&quot;yaml&quot;)</code>，<code>viper.AddConfigPath(&quot;configs&quot;)</code>，再<code>viper.ReadInConfig()</code>就可以读取了。</p><h3 id="默认值："><a href="#默认值：" class="headerlink" title="默认值："></a>默认值：</h3><p>设置默认值，可以用于备用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">viper.SetDefault(<span class="hljs-string">&quot;ContentDir&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="从io-Reader中读取"><a href="#从io-Reader中读取" class="headerlink" title="从io.Reader中读取:"></a>从io.Reader中读取:</h3><p>viper 支持从<code>io.Reader</code>中读取配置。这种形式很灵活，来源可以是文件，也可以是程序中生成的字符串，甚至可以从网络连接中读取的字节流</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package main<br><br><span class="hljs-keyword">import</span> (<br>&quot;bytes&quot;<br>&quot;fmt&quot;<br>&quot;log&quot;<br><br>&quot;github.com/spf13/viper&quot;<br>)<br><br>func main() &#123;<br>viper.SetConfigType(&quot;toml&quot;)<br>tomlConfig := []byte(`<br>app_name = &quot;awesome web&quot;<br><br># possible <span class="hljs-keyword">values</span>: <span class="hljs-keyword">DEBUG</span>, <span class="hljs-keyword">INFO</span>, <span class="hljs-built_in">WARNING</span>, ERROR, FATAL<br>log_level = &quot;DEBUG&quot;<br><br>[mysql]<br>ip = &quot;127.0.0.1&quot;<br>port = <span class="hljs-number">3306</span><br><span class="hljs-keyword">user</span> = &quot;root&quot;<br><span class="hljs-keyword">password</span> = <span class="hljs-number">123456</span><br><span class="hljs-keyword">database</span> = &quot;awesome&quot;<br>`)<br>err := viper.ReadConfig(bytes.NewBuffer(tomlConfig))<br><span class="hljs-keyword">if</span> err != nil &#123;<br><span class="hljs-keyword">log</span>.Fatal(&quot;read config failed: %v&quot;, err)<br>&#125;<br><br>fmt.Println(&quot;redis port: &quot;, viper.GetInt(&quot;redis.port&quot;))<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="🤪读取："><a href="#🤪读取：" class="headerlink" title="🤪读取："></a>🤪读取：</h2><h3 id="保存配置："><a href="#保存配置：" class="headerlink" title="保存配置："></a>保存配置：</h3><p>用于在配置发生更好后保存至本地，具体推荐使用以下两个方法：</p><ul><li><code>WriteConfigAs</code>：保存配置到指定路径下的文件，如果文件存在，则覆盖；</li><li><code>SafeWriteConfig</code>：与上面功能一样，但是如果配置文件存在，则不覆盖，会报错。</li></ul><h3 id="基本读取："><a href="#基本读取：" class="headerlink" title="基本读取："></a>基本读取：</h3><p>在 Viper 中，有几种根据值的类型获取值的方法。存在以下功能和方法：</p><ul><li>Get(key string) : interface{}</li><li>GetBool(key string) : bool</li><li>GetFloat64(key string) : float64</li><li>GetInt(key string) : int</li><li>GetIntSlice(key string) : []int</li><li>GetString(key string) : string</li><li>GetStringMap(key string) : map[string]interface{}</li><li>GetStringMapString(key string) : map[string]string</li><li>GetStringSlice(key string) : []string</li><li>GetTime(key string) : time.Time</li><li>GetDuration(key string) : time.Duration</li><li>IsSet(key string) : bool</li><li>AllSettings() : map[string]interface{}</li></ul><p>每个 Get 函数如果找不到值，它将返回零值。为了检查给定键是否存在，提供了 IsSet() 方法。</p><p><strong>访问套接键：</strong></p><p>访问器方法还接受深度嵌套键的格式化路径。例如，如果加载了以下JSON文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go">&#123;<br>    <span class="hljs-string">&quot;host&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;address&quot;</span>: <span class="hljs-string">&quot;localhost&quot;</span>,<br>        <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">5799</span><br>    &#125;,<br>    <span class="hljs-string">&quot;datastore&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;metric&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>,<br>            <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">3099</span><br>        &#125;,<br>        <span class="hljs-string">&quot;warehouse&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;198.0.0.1&quot;</span>,<br>            <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">2112</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Viper 可以通过传递「.」分隔键的路径来访问嵌套字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">GetString(<span class="hljs-string">&quot;datastore.metric.host&quot;</span>) <span class="hljs-comment">// (returns &quot;127.0.0.1&quot;)</span><br></code></pre></td></tr></table></figure><p>遵守上面建立的优先级规则；搜索路径将遍历其余配置注册表，直到找到为止。</p><p>例如，在给定此配置文件的情况下，datastore.metric.host 和 datastore.metric.port 均已定义（并且可以被覆盖）。如果另外在默认设置中定义了 datastore.metric.protocol，Viper 也会找到它。</p><p>但是，如果 datastore.metric 被直接赋值覆盖（通过 flag，环境变量，Set() 方法等），则 datastore.metric 的所有子键也都变为未定义状态，它们被较高的优先级配置遮蔽（shadowed）了。</p><p>Viper 可以使用路径中的数字访问数组索引。例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123;<br>    <span class="hljs-string">&quot;host&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;address&quot;</span>: <span class="hljs-string">&quot;localhost&quot;</span>,<br>        <span class="hljs-string">&quot;ports&quot;</span>: [<br>            <span class="hljs-number">5799</span>,<br>            <span class="hljs-number">6029</span><br>        ]<br>    &#125;<br>&#125;<br><br>GetInt(<span class="hljs-string">&quot;host.ports.1&quot;</span>) <span class="hljs-regexp">//</span> returns <span class="hljs-number">6029</span><br></code></pre></td></tr></table></figure><p>最后，如果存在与分隔的键路径匹配的键，则将返回其值。例如</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&#123;<br>    <span class="hljs-string">&quot;datastore.metric.host&quot;</span>: <span class="hljs-string">&quot;0.0.0.0&quot;</span>,<br>    <span class="hljs-string">&quot;datastore&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;metric&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>,<br>            <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">3099</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">GetString</span><span class="hljs-params">(<span class="hljs-string">&quot;datastore.metric.host&quot;</span>)</span></span> <span class="hljs-comment">// returns &quot;0.0.0.0&quot;</span><br></code></pre></td></tr></table></figure><h3 id="提取子树："><a href="#提取子树：" class="headerlink" title="提取子树："></a>提取子树：</h3><p>我们以下面的例子来讲提取子树。</p><p>应用程序可能出于不同的目的使用多个不同的缓存存储。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">cache:</span><br>  <span class="hljs-attr">cache1:</span><br>    <span class="hljs-attr">max-items:</span> <span class="hljs-number">100</span><br>    <span class="hljs-attr">item-size:</span> <span class="hljs-number">64</span><br>  <span class="hljs-attr">cache2:</span><br>    <span class="hljs-attr">max-items:</span> <span class="hljs-number">200</span><br>    <span class="hljs-attr">item-size:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>这时我们要得到其中一个cache的配置，我们定义了一个函数<code>NewCache()</code>，这时我们可以采用<code>NewCache(&quot;cache1&quot;)</code>直接传入名字的方式，再到函数里面根据名字”cache.cache1.max-items”的形式去创建，显然有点小乱，我们可以采用更优雅的方式。如下：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lisp">func NewCache(<span class="hljs-name">v</span> *Viper) *Cache &#123;<br>    return <span class="hljs-symbol">&amp;Cache</span>&#123;<br>        MaxItems: v.GetInt(<span class="hljs-string">&quot;max-items&quot;</span>),<br>        ItemSize: v.GetInt(<span class="hljs-string">&quot;item-size&quot;</span>),<br>    &#125;<br>&#125;<br><br>cache1Config <span class="hljs-symbol">:=</span> viper.Sub(<span class="hljs-string">&quot;cache.cache1&quot;</span>)<br>if cache1Config == <span class="hljs-literal">nil</span> &#123; // Sub returns <span class="hljs-literal">nil</span> if the key cannot be found<br>    panic(<span class="hljs-string">&quot;cache configuration not found&quot;</span>)<br>&#125;<br><br>cache1 <span class="hljs-symbol">:=</span> NewCache(<span class="hljs-name">cache1Config</span>)<br></code></pre></td></tr></table></figure><h3 id="反序列化："><a href="#反序列化：" class="headerlink" title="反序列化："></a>反序列化：</h3><p>viper 支持将配置<code>Unmarshal</code>到一个结构体中，为结构体中的对应字段赋值。例子如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-string">&quot;github.com/spf13/viper&quot;</span><br>)<br><span class="hljs-keyword">type</span> Database <span class="hljs-keyword">struct</span>&#123;<br>Dbtype <span class="hljs-type">string</span><br>Host <span class="hljs-type">string</span><br>Password <span class="hljs-type">string</span><br>Username <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>viper.SetConfigName(<span class="hljs-string">&quot;config&quot;</span>)<br>viper.SetConfigType(<span class="hljs-string">&quot;yaml&quot;</span>)<br>viper.AddConfigPath(<span class="hljs-string">&quot;configs&quot;</span>)<br><span class="hljs-keyword">if</span> err := viper.ReadInConfig(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;error in read&quot;</span>)<br>&#125;<br><span class="hljs-keyword">var</span> Data Database<br><span class="hljs-keyword">if</span> err:=viper.UnmarshalKey(<span class="hljs-string">&quot;Database&quot;</span>,&amp;Data);err!=<span class="hljs-literal">nil</span>&#123;<br>fmt.Println(err)<br>&#125;<br>fmt.Println(Data)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要解析 Key 本身包含「.」（默认键分隔符）的配置，必须更改分隔符：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go">v := viper.NewWithOptions(viper.KeyDelimiter(<span class="hljs-string">&quot;::&quot;</span>))<br><br>v.SetDefault(<span class="hljs-string">&quot;chart::values&quot;</span>, <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br>    <span class="hljs-string">&quot;ingress&quot;</span>: <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br>        <span class="hljs-string">&quot;annotations&quot;</span>: <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br>            <span class="hljs-string">&quot;traefik.frontend.rule.type&quot;</span>:                 <span class="hljs-string">&quot;PathPrefix&quot;</span>,<br>            <span class="hljs-string">&quot;traefik.ingress.kubernetes.io/ssl-redirect&quot;</span>: <span class="hljs-string">&quot;true&quot;</span>,<br>        &#125;,<br>    &#125;,<br>&#125;)<br><br><span class="hljs-keyword">type</span> config <span class="hljs-keyword">struct</span> &#123;<br>  Chart <span class="hljs-keyword">struct</span>&#123;<br>        Values <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> C config<br><br>v.Unmarshal(&amp;C)<br></code></pre></td></tr></table></figure><h3 id="监听文件修改："><a href="#监听文件修改：" class="headerlink" title="监听文件修改："></a>监听文件修改：</h3><p>viper 可以监听文件修改，热加载配置。因此不需要重启服务器，就能让配置生效。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sqf">package main<br><br>import (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-string">&quot;github.com/spf13/viper&quot;</span><br>)<br><br>func main() &#123;<br>viper.SetConfigName(<span class="hljs-string">&quot;config&quot;</span>)<br>viper.SetConfigType(<span class="hljs-string">&quot;toml&quot;</span>)<br>viper.AddConfigPath(<span class="hljs-string">&quot;.&quot;</span>)<br>err := viper.ReadInConfig()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">log</span>.Fatal(<span class="hljs-string">&quot;read config failed: %v&quot;</span>, err)<br>&#125;<br><br>viper.WatchConfig()<br><br>fmt.Println(<span class="hljs-string">&quot;redis port before sleep: &quot;</span>, viper.<span class="hljs-built_in">Get</span>(<span class="hljs-string">&quot;redis.port&quot;</span>))<br><span class="hljs-built_in">time</span>.<span class="hljs-built_in">Sleep</span>(<span class="hljs-built_in">time</span>.Second * <span class="hljs-number">10</span>)<br>fmt.Println(<span class="hljs-string">&quot;redis port after sleep: &quot;</span>, viper.<span class="hljs-built_in">Get</span>(<span class="hljs-string">&quot;redis.port&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>上面程序中，我们先打印<code>redis.port</code>的值，然后<code>Sleep</code> 10s。在这期间修改配置中<code>redis.port</code>的值，<code>Sleep</code>结束后再次打印。发现打印出修改后的值：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">redis port before sleep:</span>  <span class="hljs-number">7381</span><br><span class="hljs-attr">redis port after sleep:</span>  <span class="hljs-number">73810</span><br></code></pre></td></tr></table></figure><p>另外，还可以为配置修改增加一个回调：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cn">viper.OnConfigChange(func(e fsnotify.Event) &#123;<br>fmt.Printf(&quot;Config file:%s Op:%s\n&quot;, e.Name, e.Op)<br>&#125;)<br></code></pre></td></tr></table></figure><p>这样文件修改时会执行这个回调。</p><p>viper 使用<a href="https://link.zhihu.com/?target=https://github.com/fsnotify/fsnotify">fsnotify</a>这个库来实现监听文件修改的功能。</p><h2 id="Viper实例："><a href="#Viper实例：" class="headerlink" title="Viper实例："></a>Viper实例：</h2><p>Viper 可以开箱即用。无需配置或初始化，就可以使用 Viper。由于大多数应用程序都希望使用单个中央存储库进行配置，因此 viper 包提供了此功能。它类似于单例模式。</p><p>在上面的所有示例中，他们都以单例模式风格演示了使用 Viper 的使用方法</p><p>您还可以创建许多不同的 Viper 实例，供应用程序使用。每个都有其独特的配置和值集。每个都可以从不同的配置文件等读取。Viper 包支持的所有函数都镜像为 Viper 上的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">x := viper.New()<br>y := viper.New()<br><br>x.SetDefault(<span class="hljs-string">&quot;ContentDir&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>)<br>y.SetDefault(<span class="hljs-string">&quot;ContentDir&quot;</span>, <span class="hljs-string">&quot;foobar&quot;</span>)<br><br></code></pre></td></tr></table></figure><p>当使用多个 Viper 时，由用户管理不同的 Viper。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>Viper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Viper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>🤗️怎样写单元测试与如何判断slice中的一个元素</title>
    <link href="/2022/08/13/%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95/"/>
    <url>/2022/08/13/%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>Go中没有可以直接判断一个元素是否在slice中的函数，所以用于判断的方法有遍历，还有改进点的构建Map，用Sort包，那到底是Map好还是Sort包好呢，我们做个单元测试就知道了。</p><span id="more"></span><h1 id="🤗️怎样写单元测试与如何判断slice中的一个元素"><a href="#🤗️怎样写单元测试与如何判断slice中的一个元素" class="headerlink" title="🤗️怎样写单元测试与如何判断slice中的一个元素"></a>🤗️怎样写单元测试与如何判断slice中的一个元素</h1><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5555r4z1xj21900u0n76.jpg"></p><h2 id="单元测试与性能测试"><a href="#单元测试与性能测试" class="headerlink" title="单元测试与性能测试"></a>单元测试与性能测试</h2><blockquote><p>这里我们主要用了Go的testing包。</p></blockquote><p><strong>白盒测试：</strong>测试代码和要测试的代码放在同一包中，测试代码可以读取到该包中的不可导出变量，所以我们在编写需要访问到不可导出变量、函数、常量的测试代码时就要用这种方法，同时这也是较为推荐的方法。</p><p><strong>黑盒测试：</strong>可以不放在同一个包中，但只能测试可导出的标示符。</p><blockquote><p>测试文件的规范要求：测试文件命名规范、函数名规范、变量名规范</p></blockquote><p>测试文件名规范：Go的测试文件名必须以_test.go结尾，因为Go就是利用这个去判断哪些是测试文件，哪些是正式文件的，我们在执行<code>go test</code>命令时，这些文件会给执行，而在构建程序时则会忽略这些文件。</p><p>函数名规范：测试函数必须使用Test&#x2F;Benchmark&#x2F;Example开头，例如TestXxx、BenchmarkXxx、ExampleXxx，Xxx通常是要测试的函数名。</p><p>变量名规范：Go没有对变量名有硬性的要求，但为了清晰的表达函数的实际输出和预期输出，可以将这两类输出命名为expected&#x2F;actual或者got&#x2F;want。</p><h3 id="🤔单元测试："><a href="#🤔单元测试：" class="headerlink" title="🤔单元测试："></a>🤔单元测试：</h3><p>单元测试的测试用例函数以Test开头，函数参数必须是<code>*tesing.T</code>，可以用该类型来记录错误或测试状态。</p><blockquote><p>至此我们可以得出一个总结，要写一个单元测试必要的规范，1.文件名以_test.go结尾，2.函数名以Test开头，3.函数参数为<code>testing.T</code></p></blockquote><p>我们可以调用 <code>testing.T</code> 的 <code>Error</code> 、<code>Errorf</code> 、<code>FailNow</code> 、<code>Fatal</code> 、<code>FatalIf</code> 方法，来说明测试不通过；调用 <code>Log</code> 、<code>Logf</code> 方法来记录测试信息。函数列表和相关描述如下表所示：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>t.Log, t.Logf</td><td>正常信息</td></tr><tr><td>t.Error, t.Errorf</td><td>测试失败信息</td></tr><tr><td>t.Fatal, t.Fatalf</td><td>致命错误，测试程序退出的信息</td></tr><tr><td>t.Fail</td><td>当前测试标记为失败</td></tr><tr><td>t.Failed</td><td>查看失败标记</td></tr><tr><td>t.FailNow</td><td>标记失败，并终止当前测试函数的执行。需要注意的是，我们只能在运行测试函数的Goroutine中调用t.FailNow方法，而不能在我们测试代码创建出的Goroutine中调用它</td></tr></tbody></table><p><strong>一个栗子🌰：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//math.go</span><br><br><span class="hljs-keyword">package</span> Test<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;math&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Abs</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>b := <span class="hljs-type">float64</span>(a)<br><span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(math.Abs(b))<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> Test<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAbs</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>got := Abs(<span class="hljs-number">-1</span>)<br><span class="hljs-keyword">if</span> got != <span class="hljs-number">1</span> &#123;<br>t.Error(<span class="hljs-string">&quot;fault&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>t.Log(<span class="hljs-string">&quot;right&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">终端执行命令</span><br><br>go test &quot;math.go&quot; &quot;math_test.go&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果想执行文件夹中的所有测试用例那就直接go <span class="hljs-built_in">test</span>即可</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">也可以用go <span class="hljs-built_in">test</span>的参数来完成执行指定的函数</span><br></code></pre></td></tr></table></figure><p>go test支持一下三个参数：</p><ul><li><p>-v，显示所有测试函数的运行细节：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">pengxj@PEngxJdeMacBook-Pro test % go test -v &quot;math.go&quot; &quot;math_test.go&quot; <br>=== RUN   TestAbs<br>    math_test.go:10: right<br>--- PASS: TestAbs (0.00s)<br>PASS<br>ok      command-line-arguments  0.612s<br></code></pre></td></tr></table></figure></li><li><p>-run &lt; regexp&gt;，指定要执行的测试函数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">pengxj@PEngxJdeMacBook-Pro test % go test -run &quot;TestAbs&quot;             <br>PASS<br>ok      test    0.608s<br></code></pre></td></tr></table></figure></li><li><p>-count N，指定执行测试函数的次数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">pengxj@PEngxJdeMacBook-Pro test % go test -v -run &quot;TestAbs&quot; -count=2<br>=== RUN   TestAbs<br>    math_test.go:10: right<br>--- PASS: TestAbs (0.00s)<br>=== RUN   TestAbs<br>    math_test.go:10: right<br>--- PASS: TestAbs (0.00s)<br>PASS<br>ok      test    0.087s<br></code></pre></td></tr></table></figure></li></ul><p><strong>多个测试用例：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAbs_2</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>tests:=[]<span class="hljs-keyword">struct</span>&#123;<br>x <span class="hljs-type">int</span><br>want <span class="hljs-type">int</span><br>&#125;&#123;<br>&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">-2</span>,<span class="hljs-number">2</span>&#125;,<br>&#123;<span class="hljs-number">-3</span>,<span class="hljs-number">3</span>&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> _,v:=<span class="hljs-keyword">range</span> tests&#123;<br>got:=Abs(v.x)<br><span class="hljs-keyword">if</span> got!=v.want&#123;<br>t.Error(<span class="hljs-string">&quot;fault&quot;</span>)<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>t.Log(<span class="hljs-string">&quot;right&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中，我们定义了一个结构体，并且给定了入参和希望得到的值，最后用循环测试每个用例</p><h3 id="自动生成单元测试🐮："><a href="#自动生成单元测试🐮：" class="headerlink" title="自动生成单元测试🐮："></a>自动生成单元测试🐮：</h3><p>通过上面的样例我们可以得出个大概的结论：我们编写的单元测试就是，自己设定参数和预期结果值，接着调用函数来看能不能达到预期，逻辑并不复杂，复杂的反而是上面提到的那几个规范。</p><p>所以大牛已经做出工具来了，优秀的生成测试代码的工具：<code>gotests</code>。下面我们讲下他的使用方法：</p><p><strong>第一步：下载gotests包：</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> -<span class="hljs-keyword">u</span> github.<span class="hljs-keyword">com</span>/cweill/gotests/...<br></code></pre></td></tr></table></figure><p><strong>第二步：执行gotests命令：</strong></p><p>gotests命令执行格式为：<code>gotests [options] [PATH] [FILE] ...</code>。gotests可以为<code>PATH</code>下的所有Go源码文件中的函数生成测试代码，也可以只为某个<code>FILE</code>中的函数生成测试代码。</p><p>常用参数：<code>-all:</code>为当前目录下的所有函数生成测试代码。<code>-w：</code>将生成的测试代码生成到指定文件中，而不是命令行窗口。<code>-only:</code>指定要单独生成单元测试的函数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">gotests -only &quot;Abs&quot; -w .<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># -only用于指定选定的要生成单元测试的函数</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># “.” 表示生成在该目录下</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 如果我们没有创建相应的 _test.go文件那他就会自动生成，如果有就会往里继续添加，当然前提是我们没在那个文件中已经写了Test文件，不然就不会生成了。</span></span><br></code></pre></td></tr></table></figure><p><strong>第三步，添加测试用例：</strong></p><p>生成完测试用例，你只需要添加需要测试的输入和预期的输出就可以了。</p><p>上面的命令执行后会出现下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> Test<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAbs</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">type</span> args <span class="hljs-keyword">struct</span> &#123;<br>a <span class="hljs-type">int</span><br>&#125;<br>tests := []<span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>args args<br>want <span class="hljs-type">int</span><br>&#125;&#123;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Add test cases.</span><br>&#125;<br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;<br>t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">if</span> got := Abs(tt.args.a); got != tt.want &#123;<br>t.Errorf(<span class="hljs-string">&quot;Abs() = %v, want %v&quot;</span>, got, tt.want)<br>&#125;<br>&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们要完成的就是上面的TODO部分，也就是添加参数和预期结果。<code>name</code> 表示这组样例的备注，<code>args</code>表示函数的入参， <code>want</code>表示想要得到的结果。例如下面这样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAbs</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">type</span> args <span class="hljs-keyword">struct</span> &#123;<br>a <span class="hljs-type">int</span><br>&#125;<br>tests := []<span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>args args<br>want <span class="hljs-type">int</span><br>&#125;&#123;<br>&#123;<br>name: <span class="hljs-string">&quot;test one&quot;</span>,<br>args: args&#123;<br>a: <span class="hljs-number">1</span>,<br>&#125;,<br>want: <span class="hljs-number">1</span>,<br>&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;<br>t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">if</span> got := Abs(tt.args.a); got != tt.want &#123;<br>t.Errorf(<span class="hljs-string">&quot;Abs() = %v, want %v&quot;</span>, got, tt.want)<br>&#125;<br>&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="性能测试："><a href="#性能测试：" class="headerlink" title="性能测试："></a>性能测试：</h2><p>性能测试的函数Benchmark开头，函数参数必须是<code>*tesing.B</code>,函数内我们使用<code>b.N</code>来作为循环次数，N会在运行时动态调整，下面将是我们用Map和Sort包来判断元素的方法，和我们为其编写的性能测试函数。总结一句话，性能测试和上面的单元测试差不多，都是在_test.go文件中，只是函数名以Benchmark开头和用了<code>*testing.B</code>参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 两种判断Slice中元素是否存在的方法：</span><br><br><span class="hljs-keyword">package</span> Test<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;sort&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makemap</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-keyword">struct</span>&#123;&#125; &#123;<br>tempMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> arr &#123;<br>tempMap[v] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br><span class="hljs-keyword">return</span> tempMap<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Findbymap</span><span class="hljs-params">(tempMap <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-keyword">struct</span>&#123;&#125;, n <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> _, ok := tempMap[n]; ok &#123;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Findbysort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> &#123;<br>sort.Ints(arr)<br><span class="hljs-keyword">if</span> pos := sort.SearchInts(arr, n); pos != <span class="hljs-built_in">len</span>(arr) &#123;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//性能测试代码</span><br><br><span class="hljs-keyword">package</span> Test<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> arr = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>, <span class="hljs-number">66</span>, <span class="hljs-number">77</span>, <span class="hljs-number">88</span>, <span class="hljs-number">23</span>, <span class="hljs-number">34</span>, <span class="hljs-number">45</span>, <span class="hljs-number">56</span>, <span class="hljs-number">67</span>, <span class="hljs-number">78</span>, <span class="hljs-number">89</span>&#125;<br><span class="hljs-keyword">var</span> n = <span class="hljs-number">3</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkBymap</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>tempMap := makemap(arr)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>Findbymap(tempMap, n)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkBysort</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>Findbysort(arr, n)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">文件指定支持正则表达式</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">指定目录下的所有Benchmark函数如下：</span><br>go test -bench=&quot;.*&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">当然也可以指定特定函数</span><br>go test -bench=&quot;BenchmarkBymap&quot;<br><br></code></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">pengxj@PEngxJdeMacBook-Pro test % go test -bench=&quot;.*&quot;<br>goos: darwin<br>goarch: arm64<br>pkg: test<br>BenchmarkBymap-8        243986680                4.892 ns/op<br>BenchmarkBysort-8       11873071                99.28 ns/op<br>PASS<br>ok      test    3.068s<br></code></pre></td></tr></table></figure><p>结果得知，在要多次查询的情况下，构建一个map的效率是非常高的。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>代码测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单元测试与性能测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>⛽常见排序算法与实现📣</title>
    <link href="/2022/08/09/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/08/09/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>学习完数据结构与算法的课已经有很长时间了，排序算法忘的七七八八，好好复习一下吧</p><p>面对这道高频面试题，一定得好好理解下。包括了导航流程和TCP连接</p><span id="more"></span><h1 id="⛽常见排序算法与实现📣"><a href="#⛽常见排序算法与实现📣" class="headerlink" title="⛽常见排序算法与实现📣"></a>⛽常见排序算法与实现📣</h1><h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><p>排序算法可以分为两大类：<strong>比较类排序</strong>和<strong>非比较类排序</strong></p><p><strong>比较类排序：</strong>通过比较来决定元素间的相对次序，由于其时间复杂度无法突破O(nlog<del>2</del>n)，因此也称为非线性时间比较类排序。</p><p><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 </p><p>当前工业界和面试时考察的比较多的都是比较类排序，所以这次我们重点来学习下比较类排序中常见的两类排序：<strong>初级排序</strong>和<strong>高级排序</strong></p><p><img src="https://pic.rmb.bdstatic.com/bjh/839422a30a824720938d3e4a35f2f5d1.png" alt="常见排序的时间复杂度"></p><p><strong>初级排序：</strong>平均时间复杂度为O(n^2^)的排序，这些的重要性相对不高，多以了解为主。</p><p><strong>高级排序</strong>：平均时间复杂度为O(nlog<del>2</del>n)的排序，在公司面试和使用这方面主要就是这几个，优先级是最高的，我们一定要理解他们的原理并且自己能够实现这类排序算法。</p><h2 id="初级排序："><a href="#初级排序：" class="headerlink" title="初级排序："></a>初级排序：</h2><blockquote><p>我们主要熟悉下选择排序、插入排序、冒泡排序</p></blockquote><h3 id="选择排序："><a href="#选择排序：" class="headerlink" title="选择排序："></a>选择排序：</h3><blockquote><p>平均时间复杂度：O(n^2^)</p><p>最优时间复杂度：O(n^2^)  因为每次都要完整地遍历一次无序数组</p><p>最差时间复杂度：O(n^2^) 一样的，每次都是要完整地遍历一次无序数组</p><p>空间复杂度：O(1)  不用开辟新数组</p></blockquote><p>一句话理解：在乱序数组中遍历，找到最小元素，放到有序数组的最后面，如此反复最后就能得到有序数组。步骤就是每次都遍历一遍无序数组，找到最小元素，然后与无序数组的第一个元素交换（原理上是放到有序数组的下一个元素，其实也就是无序数组的第一个元素）</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h543464jifg20mj06w7l2.gif" alt="选择排序"></p><p><strong>代码实现（Go）：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arr)<span class="hljs-number">-1</span>; i++ &#123; <span class="hljs-comment">//每次遍历无序数组的第一个元素的位置</span><br>min := arr[i]<br>pos := i<br>        <span class="hljs-comment">//找到最小元素</span><br><span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(arr); j++ &#123;<br><span class="hljs-keyword">if</span> arr[j] &lt; min &#123;<br>min = arr[j]<br>pos = j<br>&#125;<br>&#125;<br>        <span class="hljs-comment">//与无序数组的第一个元素交换</span><br> arr[i],arr[pos]=arr[pos],arr[i]<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插入排序："><a href="#插入排序：" class="headerlink" title="插入排序："></a>插入排序：</h3><blockquote><p>平均时间复杂度：O(n^2^)</p><p>最优时间复杂度：O(n)  数组为本身有序的情况</p><p>最差时间复杂度：O(n^2^) 逆序的情况，每次都要一次与前面有序数组完整的比较</p><p>空间复杂度：O(1)  不用开辟新数组</p></blockquote><p>一句话理解：将乱序数组中的元素插入到有序数组中。步骤是每次选取无序数组的第一个元素从有序数组的最后一个元素开始一一判断，找到位置后，腾出插入位置后插入。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5436dwi6zg20mj0e113f.gif" alt="插入排序"></p><p><strong>代码实现（Go）：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span>&#123;<br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(arr);i++&#123;  <span class="hljs-comment">// 这里每次的i为乱序数组的第一个元素的下标</span><br><span class="hljs-keyword">var</span>(<br>j <span class="hljs-type">int</span><br>temp=arr[i]  <span class="hljs-comment">//后面要移动元素腾出插入的空间，所以要先保存下来</span><br>)<br><span class="hljs-comment">//查找插入位置</span><br><span class="hljs-keyword">for</span> j=i<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--&#123;   <span class="hljs-comment">// 这里的j是每次的有序数组的最后一个元素的下标</span><br><span class="hljs-keyword">if</span> arr[i]&lt;arr[j]&#123; <br><span class="hljs-keyword">continue</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">break</span>  <span class="hljs-comment">//j+1就是要插入的位置了</span><br>&#125;<br>&#125;<br><span class="hljs-comment">//移动位置，腾出插入空间</span><br><span class="hljs-keyword">for</span> ;i&gt;j+<span class="hljs-number">1</span>;i--&#123;<br>arr[i]=arr[i<span class="hljs-number">-1</span>]<br>&#125;<br>arr[j+<span class="hljs-number">1</span>]=temp<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="冒泡排序："><a href="#冒泡排序：" class="headerlink" title="冒泡排序："></a>冒泡排序：</h3><blockquote><p>平均时间复杂度：O(n^2^)</p><p>最优时间复杂度：O(n^2^)  数组为本身有序的情况</p><p>最差时间复杂度：数组为逆序的状态</p><p>空间复杂度：O(1)  不用开辟新数组</p></blockquote><p>一句话理解：每进行一次整个数组（除去浮出水面的）两两交换，就一定会有至少一个当前剩余数组中的最大元素会浮出水面。步骤就是在无序中，不断重复的进行一趟两两比较交换，每次会浮出一个至多个元素，随着浮出元素的增多，每次比较的次数也相应减少。</p><p><strong>代码实现（Go）：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span>&#123;<br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(arr);i++&#123;<br><span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;<span class="hljs-built_in">len</span>(arr)-i;j++&#123;<br><span class="hljs-keyword">if</span> arr[j]&lt;arr[j<span class="hljs-number">-1</span>]&#123;<br>arr[j<span class="hljs-number">-1</span>],arr[j]=arr[j],arr[j<span class="hljs-number">-1</span>]<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高级排序："><a href="#高级排序：" class="headerlink" title="高级排序："></a>高级排序：</h2><h3 id="快速排序："><a href="#快速排序：" class="headerlink" title="快速排序："></a>快速排序：</h3><blockquote><p>平均时间复杂度：O(nlog<del>2</del>n)</p><p>最优时间复杂度：O(nlog<del>2</del>n)  选取的pivot可以，每次都能把数组分成等份的两份</p><p>最差时间复杂度：O(n^2^)选取的pivot不行，分出的数组的元素数量严重不均等</p><p>空间复杂度：O(1)  不用开辟新数组</p></blockquote><p>一句话理解，运用了分治的思想，每次我们都选取一个pivot，将原数组分成左半边数组和右半边数组，左子数组都小于pivot，右子数组都大于pivot，再递归处理这两个左右子数组。步骤就是，我们这里是为了方便选用了数组的最后一个元素为pivot，真实应用场景下可能会根据数据的大致情况选择相应的pivot来提高效率，counter的值理解为经过分类后小于pivot的左子数组的最后一个元素位置加1，所以我们遍历过程中遇到比pivot小的元素就都和counter交换，扩充左子数组，遍历完成后，counter位置始终代表左子数组的下一个位置，所以最后pivot直接与counter交换位置，即能得到分好类的左右子数组。再递归处理左右子数组。</p><p>再记一下自己疑惑的点（不知道为啥疑惑😓）</p><p><strong>剩下两个的情况是怎么结束的？</strong></p><ol><li><p>倒序的情况，按照惯例，pivot设为第二个元素，遍历完比它小的左子数组的下一位即为第一个元素的位置（没有比它小的元素，counter没变），交换后就正序了，进入下面的情况。</p></li><li><p>正序的情况，按照惯例，pivot设为第二个元素，遍历后只有一个元素比它小，比它小的左子数组的下一位即为第二个元素的位置，这时我们再递归处理这两个子数组，我们先看右子数组，我们的左边界会设为counter+1，有边界还是high没有变，而此时counter+1已经大于high了，所以就结束了，我们再看左子数组，此时就是剩余一个元素的情况了。</p></li><li><p>剩余一个元素的情况：判断后low等于high，结束</p></li></ol><p><strong>复杂度为什么O(nlog<del>2</del>n)：</strong>首先是前面的n，前面的n代表是每一层在做<code>partition</code>的时候都要处理“n”次，log<del>2</del>n代表调用栈有多高，最坏情况，调用栈的高度就为n，所以复杂度为O(n^2^)。</p><p><strong>代码实现（Go）：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>,low <span class="hljs-type">int</span>,high <span class="hljs-type">int</span>)</span></span>&#123;<br><span class="hljs-keyword">if</span> low&gt;=high&#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(arr[low:high+<span class="hljs-number">1</span>])<br>pivot:=partition(arr,low,high)<br>quicksort(arr,low,pivot<span class="hljs-number">-1</span>)<br>quicksort(arr,pivot+<span class="hljs-number">1</span>,high)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partition</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>,begin,end <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>&#123;<br>pivot,counter:=arr[end],begin<br><span class="hljs-keyword">for</span> i:=begin;i&lt;end;i++&#123;<br><span class="hljs-keyword">if</span> arr[i]&lt;pivot&#123;<br>fmt.Println(arr[i],arr[counter])<br>arr[i],arr[counter]=arr[counter],arr[i]<br>counter++<br>&#125;<br>&#125;<br>arr[counter],arr[end]=arr[end],arr[counter]<br><span class="hljs-keyword">return</span> counter<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="归并排序："><a href="#归并排序：" class="headerlink" title="归并排序："></a>归并排序：</h3><blockquote><p>平均时间复杂度：O(nlog<del>2</del>n)</p><p>最优时间复杂度：O(nlog<del>2</del>n)  归并排序每次都要分到最小，再合并，所以变化不大</p><p>最差时间复杂度：同上</p><p>空间复杂度：O(n)  需要开辟新数组</p></blockquote><p>一句话理解，先切割成n个子序列，最小为1，然后再合并子序列（归并），在合并的过程中会使这两个子序列合并成整体有序的子序列，不断将整体有序的子序列合并，并且合并过程夹有排序，最终就能得到有序的序列。步骤就是，可以理解为一个后序遍历，先把数组一直切分，“在根结点”合并，把左右子树中整体有序的子序列合并就能最终得到整体有序的序列</p><p><strong>复杂度为什么O(nlog<del>2</del>n)：</strong>先说后面的log<del>2</del>n，归并的调用栈就固定为log<del>2</del>n了，不会像快排那样有变化，而前面的n代表着就是在每一层合并的时候都要处理“n”次。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h543b37d25g20mj0e1qcv.gif" alt="归并排序"></p><p><strong>代码实现（Go）：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, low, high <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> low &gt;= high &#123;  大于的情况是越界了，等于的情况是不用再分了<br><span class="hljs-keyword">return</span><br>&#125;<br>mid := (low + high) &gt;&gt; <span class="hljs-number">1</span><br>fmt.Println(mid)<br>MergeSort(arr, low, mid)<br>MergeSort(arr, mid+<span class="hljs-number">1</span>, high)<br>Merge(arr, low, high, mid)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Merge</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, low, high, mid <span class="hljs-type">int</span>)</span></span> &#123;<br>left, right := low, mid+<span class="hljs-number">1</span><br>TempArr := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, high-low+<span class="hljs-number">1</span>)<br>k := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> left &lt;= mid &amp;&amp; right &lt;= high &#123;<br><span class="hljs-keyword">if</span> arr[left] &lt; arr[right] &#123;<br>TempArr[k] = arr[left]<br>k++<br>left++<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>TempArr[k] = arr[right]<br>k++<br>right++<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> left &lt;= mid &#123;<br>TempArr[k] = arr[left]<br>k++<br>left++<br>&#125;<br><span class="hljs-keyword">for</span> right &lt;= high &#123;<br>TempArr[k] = arr[right]<br>k++<br>right++<br>&#125;<br><span class="hljs-built_in">copy</span>(arr[low:high+<span class="hljs-number">1</span>], TempArr)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆排序："><a href="#堆排序：" class="headerlink" title="堆排序："></a>堆排序：</h3><blockquote><p>平均时间复杂度：O(nlog<del>2</del>n)</p><p>最优时间复杂度：O(nlog<del>2</del>n)  堆排序时间主要在维护堆上，和数组情况无关</p><p>最差时间复杂度：同上</p><p>空间复杂度：O(n)  需要开辟新数组</p></blockquote><p>一句话理解：用序列先维护一个堆(nlog<del>2</del>n)，再用堆弹出堆顶元素到新的数组中，完成排序。堆的维护我们常用语言自带的方法来实现，以Go为例就是实现接口的方法，它的底层实现里面默认弹出时使用的方法是堆顶与最后一个元素交换，弹出最后一个元素，再进行堆的维护，所以我们自己要实现的pop方法就是要弹出最后一个元素，Push方法也一样，默认放在最后一个元素，再进行堆的维护</p><p><strong>复杂度为什么O(nlog<del>2</del>n)：</strong>在维护堆时，堆的特性每次的插入和删除都需要log<del>2</del>n，而要插入n个元素，所以为O(nlog<del>2</del>n)</p><p><strong>代码实现（Go）：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myHeap []<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(heap *myHeap)</span></span>Len()<span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span>(<span class="hljs-built_in">len</span>(*heap))&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(heap *myHeap)</span></span>Less(i,j <span class="hljs-type">int</span>)<span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> (*heap)[i]&lt;(*heap)[j] &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(heap *myHeap)</span></span>Swap(i,j <span class="hljs-type">int</span>) &#123;(*heap)[i],(*heap)[j]=(*heap)[j],(*heap)[i]&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(heap *myHeap)</span></span>Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;*heap=<span class="hljs-built_in">append</span>(*heap,x.(<span class="hljs-type">int</span>))&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(heap *myHeap)</span></span>Pop()<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br><span class="hljs-keyword">var</span> x=(*heap)[<span class="hljs-built_in">len</span>(*heap)<span class="hljs-number">-1</span>] <br>*heap=(*heap)[<span class="hljs-number">0</span>:<span class="hljs-built_in">len</span>(*heap)<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>myheap:=&amp;myHeap&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>&#125;<br>a:=<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(*myheap))<br>heap.Init(myheap)<br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(a);i++&#123;<br>a[i]=heap.Pop(myheap).(<span class="hljs-type">int</span>)<br>&#125;<br>fmt.Println(a)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速排序与归并排序的比较："><a href="#快速排序与归并排序的比较：" class="headerlink" title="快速排序与归并排序的比较："></a>快速排序与归并排序的比较：</h3><p>快速排序和归并排序的平均时间复杂度都是O(nlog<del>2</del>n)，而快速排序的最坏情况是O(n^2^)，但快排还是优于归并，快排优于归并的地方在哪？</p><ol><li><p>快速排序中效率的主要来源之一是引用位置，在引用位置中，计算机硬件经过优化，因此访问彼此相邻的内存位置往往比访问分散在整个内存中的内存位置更快。quicksort中的分区步骤通常具有很好的局部性，因为它访问前面和后面附近的连续数组元素。因此，快速排序往往比其他排序算法（如heapsort）执行得更好，尽管它通常执行大致相同数量的比较和交换，因为在heapsort的情况下，访问更加分散。</p><p>也就是说，一个原因是计算机硬件经过优化，访问彼此相邻的内存位置往往比访问分散在整个内存中的内存位置更快，所以快速排序我们在划分数组的时候，元素都是相邻的，而归并排序在合并的时候是元素较为分散，所以在这一点上快排优于归并</p></li><li><p>另一个普遍都知道的原因就是快排我们可以直接在原数组上操作，而归并排序我们在合并的时候需要重新开辟数组（空间复杂度为O(n)），还要进行多次的赋值的操作，所以在这一点上让快排优于归并。</p></li></ol><p><strong>和堆排序的相比：</strong>在维护堆的时候，堆排里面有大量近乎无效的比较，因为被拿到堆顶的那个元素几乎肯定是很小的，而靠近堆顶的元素又几乎肯定是很大的，将一个很小的数和一个很大的数比较，结果几乎肯定是“小于”的，这就意味着问题的可能性只被排除掉了很小一部分。</p><p>所以堆排虽然和快排一样复杂度都是O(nlog<del>2</del>n)但堆排复杂度的常系数更大</p>]]></content>
    
    
    <categories>
      
      <category>站在巨人的肩膀上</category>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>🤯从输入URL到页面展示，这中间发生了什么？🤬</title>
    <link href="/2022/08/07/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%EF%BC%8C%E8%BF%99%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <url>/2022/08/07/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%EF%BC%8C%E8%BF%99%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<p>面对这道高频面试题，一定得好好理解下。包括了导航流程和TCP连接</p><span id="more"></span><h1 id="从输入URL到页面展示，这中间发生了什么"><a href="#从输入URL到页面展示，这中间发生了什么" class="headerlink" title="从输入URL到页面展示，这中间发生了什么?"></a>从输入URL到页面展示，这中间发生了什么?</h1><p><img src="https://static001.geekbang.org/resource/image/71/e3/714208d4e10499868688361130d1d2e3.jpg"></p><h2 id="三个进程："><a href="#三个进程：" class="headerlink" title="三个进程："></a>三个进程：</h2><p><strong>浏览器进程：</strong>主要负责用户的交互、子进程的控制和文件存储的服务</p><p><strong>网络进程</strong>：主要负责为浏览器进程和渲染进程提供下载功能</p><p><strong>渲染进程：</strong>对接受的javascript，css，html、图片等资源解析成可以显示和交互的界面</p><h2 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h2><ol><li>用户输入URL回车后，浏览器进程先判断输入的内容是否为搜索内容，是的话就会根据浏览器的默认搜索引擎，组成新的带有搜索内容的URL。如果输入的内容符合URL规则，那就会选用相应的协议，一般现在的网站都是HTTPS，组成新的URL。</li><li>浏览器进程会通过进程间通信（IPC），向网络进程发送URL请求，由网络进程真正进行URL请求。</li><li>获得URL后，网络进程不是直接就开始请求的步骤，而是先查找本地缓存是否缓存了该资源。如果有找到缓存资源则结束请求，直接把资源返回给浏览器进程。没有再进行接下来的步骤。</li><li>URL请求第一步是找目标服务器的地址和端口号，也就是域名解析，首先会在本地的域名解析缓存中查找是否有该域名的缓存记录，有则会直接使用该地址和端口号，本地缓存没有再会向DNS服务器发送请求，获得服务器地址和端口号。如果获取到的只有IP地址，则会使用默认的端口号，HTTP默认是80而HTTPS默认的是HTTPS。如果是HTTPS协议，这里还有一个步骤：建立TLS连接。</li><li>接下来就是使用IP地址与服务器进行TCP连接</li></ol><h3 id="TCP连接："><a href="#TCP连接：" class="headerlink" title="TCP连接："></a>TCP连接：</h3><p><img src="https://pic.rmb.bdstatic.com/bjh/d5169b6fc8b3fad501c31afb19f037ff.jpeg" alt="TCP结构"></p><h4 id="😊三次握手："><a href="#😊三次握手：" class="headerlink" title="😊三次握手："></a>😊三次握手：</h4><p><strong>第一次握手：</strong> 此次过程为TCP客户端发送一个TCP报文段，里面将首部的同步位SYN设为1，表明该报文段为连接请求报文段，并为序号字段（seq）设置一个值x，（这个序号会给消耗掉，即接下来的报文段要用x+1，因为TCP规定SYN设置为1后不可携带数据，但会消耗掉一个序号）作为TCP客户端所选择的初始序号，并进入同步已发送阶段。</p><p><strong>第二次握手：</strong>TCP服务器端接受到客户端发来请求连接报文段后，如果同意连接，会往客户端再发送一个TCP报文段，里面将首部的同步位SYN和确认位ACK都设为1，表明该报文段为连接请求确认报文段，并为序号字段（seq）设置一个值y，作为TCP服务器进程所选择的初始序号，确认号字段设为x+1，这是对TCP客户端所选择的初始序号的确认。同时进入同步己接受阶段</p><p><strong>第三次握手：</strong>TCP客户端接受到请求连接确认报文段后，会往服务器端再发送一次TCP报文段，里面将确认位ACK设为1，表明这是一个普通的TCP确认报文段，并将序号设置为x+1（TCP规定普通的确认报文段可以携带数据，如果这次报文段中有携带数据那这个序号将会给消耗掉，如果没有携带，那么下一次发送TCP请求时则还可以继续用这个x+1），确认号设置为y+1,这是对服务器的初始序号的确认。发送完成后，客户端进入连接已建立状态，服务器接收到确认报文段后也进入连接已建立状态。</p><p><strong>为什么要三次，两次不行吗？</strong></p><p>这是因为TCP为了保证连接的可靠性，始终认为网络层是不可靠的，如果是两次握手那TCP服务器端在发送完TCP请求连接确认报文段后就会进入连接已建立状态，这里就存在一种可能，在服务器端接收到请求连接报文段前，因为网络问题，客户端一直没接受到请求连接确认报文段已经发送了好几个请求连接报文段，而等到TCP服务器端接受到TCP请求连接报文段，TCP客户端接受到请求连接报文段，并完成了数据传输，四次挥手断开连接后，之前那些没能到达服务器端的TCP请求连接报文段又姗姗来迟到达了服务器端，这是我们如果我们采用的两次握手，服务器端就会进入连接已建立状态，而因为客户端已经认为这次连接已经完成了，那这个状态就会一直尬等着，没人传数据也没人告诉他断开，这样就导致占用了服务器端许多的资源。</p><h4 id="🤗四次挥手："><a href="#🤗四次挥手：" class="headerlink" title="🤗四次挥手："></a>🤗四次挥手：</h4><p>客户端和服务器端都可以发起断开连接，这里以客户端为例</p><p><strong>第一次挥手：</strong>此时客户端会发送一个TCP报文段，里面将终止位FIN和确认位ACK设置为1，表明该报文段为请求释放报文段，并将序号设置为u（u等于最后一次客户端发送到服务器端的数据的最后一个字节的序号加1，并且TCP规定即使该请求释放报文段不携带数据也会消耗一个序号），确认号设置为v(v等于客户端之前接受到的数据的最后一个字节的序号+1)，同时进入终止等待1状态</p><p><strong>第二次挥手：</strong>服务器端接受到连接释放字段后，再发送一个TCP报文段，里面将ACK设为1，表明该报文段为普通确认报文段，并将序号设置为v（与上面的v相等）确认号设置为u+1，并进入关闭等待状态。这时服务器端会通知应用层TCP客户端要断开与服务器端的连接，此时客户端到服务器端的这个方向的连接就释放了（由全双工变为半双工，客户端可以继续接受数据，但不可以发送数据了，这里别错误理解为不能发送任何东西了，只是不能依赖建立的通道可靠的发送数据，但是还是可以发送TCP报文段的），客户端接受到普通确认报文段后进入终止等待2状态。</p><p><strong>第三次挥手：</strong>等到应用层进程发送完数据后，它就会通知TCP服务器段进程关闭TCP连接，TCP服务端会再向客户端发送一个TCP报文段，里面将终止位FIN和确认位设置为1，表明该报文段为连接释放报文段，并将序号设置为w(w等于后来服务器端往客户端发送的剩余的数据的最后一个字节的序号+1)，确认号设置为u+1(对一次挥手的报文段的再次确认)，同时进入最后确认状态。</p><p><strong>第四次挥手：</strong>客户端收到连接释放字段后，再向服务器端发送一个TCP报文段，里面将确认位ACK设为1,表明该报文段为普通确认报文段，并将序号设置为u+1，确认号设为w+1，服务器端接受到该确认报文段后进入关闭状态，而客户端进入时间等待状态，只有等2MSL（Maximum Segment Lifetime，最长报文寿命）后进入关闭状态。</p><p><strong>为什么要等待：</strong>还是一样，TCP始终认为网络层是不可靠的，第四次挥手发送的TCP报文段可能因为某种原因未能到达服务器端，而服务器端没接受到客户端的确认报文字段就会发起超时重传连接释放字段，而这时客户端已经关闭了，服务器端不可能再接受到确认报文字段，会一直进行超时重传，一直处于最后确认状态，而无法进入关闭状态。而且经过了这个2MSL时间，就可以使本次连接的所有字段都消失，保证下一次连接不会收到旧的字段。</p><ol start="6"><li>TCP连接建立后，浏览器就会构建请求行和请求头等信息，并把和该域名相关的Cookie等数据附加到请求头中，然后向服务器发送构建好的请求信息。</li><li>服务器接受到消息后，就根据请求信息生成响应信息（包括响应行，响应头和响应体等信息），并发送回客户端。</li><li>网络进程接受到响应信息后就开始解析响应头信息，首先是判断状态码是否3xx，是否为重定向，如果是的话就读取响应头的Location字段中的地址信息，然后再发起HTTP或HTTPS请求，一切由从头开始了。</li><li>处理了跳转信息后，接下来就是处理响应数据类型，URL请求有时可能请求的是一个下载类型，也可能是一个正常的HTML界面，这时浏览器就会根据响应头中的Content-Type来处理请求，如果Content-Type为下载类型那就将它交给浏览器的下载管理器，而该URL的导航到此就结束了。但如果是HTML，那就会继续下面的导航流程。接下来就是通知浏览器进程开始<strong>准备渲染</strong>。</li><li>浏览器进程收到通知后，Chrome的方案是如果当前浏览器下已经有同一站点（同一域名，同一协议）的渲染进程，那就会复用其渲染进程，否则则是创建一个新的渲染进程，渲染进程准备好之后还不能进入文档解析阶段，因为此时的文档数据还在网络进程中，并没有提交给渲染进程。</li><li>提交文档阶段，提交响应信息中的响应体部分，<strong>提交文档</strong>的命令由浏览器进程发出，渲染进程接收到通知后，会和网络进程建立传输数据的“管道”，等到文档全部提交后，渲染进程会给浏览器进程发送<strong>确认提交</strong>的信息。</li><li>浏览器接受到<strong>确认提交</strong>的消息后，就会<strong>更新浏览器界面状态</strong>，包括了安全状态，地址栏的URL、前进后退的历史状态，并更新web界面。</li><li>之后就是渲染进程了，一旦渲染进程结束，就会往浏览器进程发送信息，收到信息后，浏览器就会停止标签图标上加载动画</li></ol>]]></content>
    
    
    <categories>
      
      <category>站在巨人的肩膀上</category>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>😃搞定Docker--进阶使用</title>
    <link href="/2022/07/30/%E6%90%9E%E5%AE%9ADocker--%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/30/%E6%90%9E%E5%AE%9ADocker--%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="😃搞定Docker–进阶使用"><a href="#😃搞定Docker–进阶使用" class="headerlink" title="😃搞定Docker–进阶使用"></a>😃搞定Docker–进阶使用</h1><p>在快速入门学习完后，我们开始来学习些真实工作场景下，需要了解学习的技术。</p><span id="more"></span><p>在快速入门那一节我们使用的镜像都是从公共的docker仓库拉取的，而对于一些真实使用的场景，我们常常需要将整个项目的环境都配置到一个镜像中，给使用者一个开箱即用的体验。这里就需要镜像构建的技术。通常有以下两种方式：</p><ul><li><code>docker commit</code>：从已有容器创建一个新的镜像。</li><li><code>docker build</code>：配合 Dockerfile 文件创建镜像。</li></ul><h2 id="Commit命令创建镜像："><a href="#Commit命令创建镜像：" class="headerlink" title="Commit命令创建镜像："></a>Commit命令创建镜像：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker commit [OPTIONS] 容器名 [创建后的镜像名[:TAG]]<br></code></pre></td></tr></table></figure><p> <strong>参数说明：</strong></p><ul><li><strong>-a</strong>：镜像作者</li><li><strong>-m</strong>：提交时的说明</li><li><strong>-p</strong>：在容器commit时，将容器暂停</li><li>TAG虽然是可选，但强烈建议还是加上比较好</li></ul><h3 id="一个栗子💭"><a href="#一个栗子💭" class="headerlink" title="一个栗子💭"></a>一个栗子💭</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.先拉取一个镜像<br>docker pull centos:7<br>2.创建一个容器<br>docker run -di --name centos centos:7<br>3.进入容器<br>docker <span class="hljs-built_in">exec</span> -it centos bash<br>4.配置Go环境，和mysql到里面（docker <span class="hljs-built_in">cp</span> 拷贝、解压）<br>5.创建镜像<br>docker commit -a <span class="hljs-string">&quot;PEngxJ&quot;</span> -m <span class="hljs-string">&quot;Go and mysql&quot;</span> centos mycentos:7<br>6.根据自己的镜像创建容器<br>docker run -di --name mycentos mycentos:7 <br><br></code></pre></td></tr></table></figure><h2 id="Dockerfile方式："><a href="#Dockerfile方式：" class="headerlink" title="Dockerfile方式："></a>Dockerfile方式：</h2><blockquote><p>总体来说就是把上面一个个的步骤写到一个Dockerfile文件中，然后运行这个文件，它就会自动帮我们完成所有步骤，然后创建相应的容器。</p></blockquote><p>在使用该方式前，我们得先学一学Dockerfile的常用命令</p><h3 id="FROM："><a href="#FROM：" class="headerlink" title="FROM："></a>FROM：</h3><p><strong>指定该镜像是基于哪个镜像构建的</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">eg:<br>FROM centos:7<br></code></pre></td></tr></table></figure><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN:"></a>RUN:</h3><p><strong>执行后面跟着的命令行命令</strong>,有以下两种格式：</p><p>shell格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> &lt;命令行命令&gt;</span><br><span class="hljs-comment">#&lt;命令行命令&gt;和在终端上的命令一样</span><br>eg:<br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;RUN&#x27;</span> &gt; /usr/local/run.text</span><br></code></pre></td></tr></table></figure><p>exec格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">&quot;可执行文件&quot;</span>,<span class="hljs-string">&quot;参数1&quot;</span>,<span class="hljs-string">&quot;参数2&quot;</span>]</span><br>eg：<br><span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">&quot;./main.go&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>]</span><br><span class="hljs-comment">#相当于 RUN ./main.go hello world</span><br></code></pre></td></tr></table></figure><p>**注意:**Dockerfile的指令每执行一次都会在docker上新建一层（之前镜像分层的概念），所以过多无意义的层必会导致生成的镜像的膨胀。所以常采用以下方式：</p><p>不用：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos<br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y install wget</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> wget -O redis.tar.gz <span class="hljs-string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span></span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> tar -xvf redis.tar.gz</span><br></code></pre></td></tr></table></figure><p>而用：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos<br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y install wget \</span><br><span class="language-bash">    &amp;&amp; wget -O redis.tar.gz <span class="hljs-string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span><br><span class="language-bash">    &amp;&amp; tar -xvf redis.tar.gz</span><br></code></pre></td></tr></table></figure><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY:"></a>COPY:</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> [--<span class="hljs-built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;...  &lt;目标路径&gt;</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> [--<span class="hljs-built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [<span class="hljs-string">&quot;&lt;源路径1&gt;&quot;</span>,...  <span class="hljs-string">&quot;&lt;目标路径&gt;&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>[–chown&#x3D;&lt;user&gt;:&lt;group&gt;]：可选参数，用户改变复制到容器内文件的拥有者和属组</p><p>**&lt;源路径&gt;**：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> hom* /mydir/</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> hom?.txt /mydir/</span><br></code></pre></td></tr></table></figure><p>**&lt;目标路径&gt;**：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。</p><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD:"></a>ADD:</h3><p>ADD 指令和 COPY 的使用格类似（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下：</p><p>区别：ADD命令，如果复制的内容是压缩包的话，则它会自动解压，当然这样也带来一个不好的地方就是它不能用来复制压缩包</p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD:"></a>CMD:</h3><p>和RUN一样用与执行命令，不过他们各自的执行时间不同。RUN在<code>docker build</code>的时候执行，而CMD是在<code>docker run</code>时执行的。</p><p>介于这点它常用于为启动的容器指定默认的启动程序，如果想让容器一直运行着那就必须得让这个程序在<strong>前台运行</strong>，不然根据docker的规则当命令运行结束后docker就退出了。</p><p><strong>注意：</strong></p><ol><li>CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</li></ol><p>eg：<code>docker run --name nginx -P nginx echo &#39;hello&#39;</code>如果是这样的话，那就会使Dockerfile中CMD的失效。</p><ol start="2"><li>如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。</li></ol><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="language-bash"> &lt;shell 命令&gt; </span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;可执行文件或命令&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...] </span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...]  <span class="hljs-comment"># 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</span></span><br></code></pre></td></tr></table></figure><p>推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。</p><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT:"></a>ENTRYPOINT:</h3><p>和上面CMD类型，在<code>docker run</code>时执行命令，但不同的是它不会被<code>docker run</code>跟着的参数中的命令所覆盖，而是把这些“命令”做为参数给ENTRYPOINT设置的命令使用。</p><p>当然, 如果运行 docker run 时使用了 –entrypoint 选项，将覆盖 ENTRYPOINT 指令指定的程序。</p><p><strong>优点</strong>：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。（ENTRYPOINT设置定参后，后面我们可以在docker run时自己指定变参，可以看后面例子）</p><p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;executeable&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...]</span><br></code></pre></td></tr></table></figure><p>示例：</p><p>假设已通过 Dockerfile 构建了 nginx:test 镜像：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> nginx<br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;nginx&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>] <span class="hljs-comment"># 定参</span></span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/etc/nginx/nginx.conf&quot;</span>] <span class="hljs-comment"># 变参 </span></span><br></code></pre></td></tr></table></figure><p>1、不传参运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run  nginx:<span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><p>容器内会默认运行以下命令，启动主进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx -c /etc/nginx/nginx.conf<br></code></pre></td></tr></table></figure><p>2、传参运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run nginx:<span class="hljs-built_in">test</span> <span class="hljs-string">&quot;/etc/nginx/new.conf&quot;</span></span><br></code></pre></td></tr></table></figure><p>容器内执行以下命令，启动主进程(&#x2F;etc&#x2F;nginx&#x2F;new.conf:假设容器内已有此文件)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx -c /etc/nginx/new.conf<br></code></pre></td></tr></table></figure><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV:"></a>ENV:</h3><p>设置环境变量</p><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> &lt;key&gt; &lt;value&gt;<br><span class="hljs-keyword">ENV</span> &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...<br></code></pre></td></tr></table></figure><h3 id="LABLE"><a href="#LABLE" class="headerlink" title="LABLE:"></a>LABLE:</h3><p>LABEL 指令用来给镜像添加一些元数据（metadata），以键值对的形式，语法格式如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">LABEL</span><span class="language-bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span><br></code></pre></td></tr></table></figure><p>eg:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">LABEL</span><span class="language-bash"> image.authors=<span class="hljs-string">&quot;runoob&quot;</span></span><br></code></pre></td></tr></table></figure><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE:"></a>EXPOSE:</h3><p>仅仅是声明端口并不会打开</p><p>作用：</p><ul><li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。（在docker run时 -p）</li><li>在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</li></ul><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">EXPOSE</span> &lt;端口<span class="hljs-number">1</span>&gt; [&lt;端口<span class="hljs-number">2</span>&gt;...]<br></code></pre></td></tr></table></figure><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR:"></a>WORKDIR:</h3><p>指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。如果不存在，docker会自动创建。</p><p>作用：</p><p>WORKDIR指令为Dockerfile中在其下面的任何RUN、CMD、ENTRYPOINT、COPY和ADD指令设置工作目录。</p><p><strong>怎么理解工作目录：</strong></p><p>在上面的RUN我们说过，每次的RUN都会在docker上新建一层，所以就会导致后面的命令不知道前面的命令的情况。举个例子：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">cd</span> /app</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello&quot;</span> &gt; world.txt</span><br></code></pre></td></tr></table></figure><p>这里我们构键完后会发现在目录&#x2F;app下找不到world.txt，而会在一个其它的地方找到这个东西，这就是上面所说的，因为下一个<code>RUN</code>根本不会在<code>/app</code>目录下。</p><p>这里我们就要用到<strong>WORKDIR</strong>了：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello&quot;</span> &gt; world.txt</span><br></code></pre></td></tr></table></figure><p>如果你的 <code>WORKDIR</code> 指令使用的相对路径，那么所切换的路径与之前的 <code>WORKDIR</code> 有关：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /a</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> b</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> c</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">pwd</span></span><br></code></pre></td></tr></table></figure><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME:"></a>VOLUME:</h3><p>定义&#x3D;&#x3D;匿名&#x3D;&#x3D;数据卷</p><p>格式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">VOLUME</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;容器路径1&gt;&quot;</span>, <span class="hljs-string">&quot;&lt;容器路径2&gt;&quot;</span>...]</span><br><span class="hljs-keyword">VOLUME</span><span class="language-bash"> &lt;容器路径&gt;</span><br></code></pre></td></tr></table></figure><p>不过我们一般通过在<code>docker run</code>时添加<code>-v</code>参数来指定挂载目录</p><h3 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build:"></a>docker build:</h3><p>常用的参数：</p><ul><li><code>-t</code>：镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</li><li><code>-f</code>：指定要使用的Dockerfile路径；</li></ul><h3 id="一个栗子🤖："><a href="#一个栗子🤖：" class="headerlink" title="一个栗子🤖："></a>一个栗子🤖：</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos:<span class="hljs-number">7</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> go1.18.4.linux-amd64.tar.gz /usr/local/go</span><br>&amp;&amp; Goweb /usr/home/<br><span class="hljs-keyword">ENV</span> PATH=$PATH:/usr/local/go/bin <br><span class="hljs-keyword">LABEL</span><span class="language-bash"> author=<span class="hljs-string">&quot;PEngxJ&quot;</span></span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /usr/home/</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> go run /usr/home/Goweb/main.go</span><br></code></pre></td></tr></table></figure><h2 id="镜像迁移："><a href="#镜像迁移：" class="headerlink" title="镜像迁移："></a>镜像迁移：</h2><h3 id="备份与恢复的方式："><a href="#备份与恢复的方式：" class="headerlink" title="备份与恢复的方式："></a>备份与恢复的方式：</h3><p><strong>备份：</strong></p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker save <span class="hljs-selector-attr">[OPTIONS]</span> IMAGE <span class="hljs-selector-attr">[IMAGE...]</span><br></code></pre></td></tr></table></figure><ul><li>-o :输出到的文件</li></ul><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker save -o myubuntu.tar ubuntu:v3<br></code></pre></td></tr></table></figure><p><strong>恢复：</strong></p><p>语法:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">docker <span class="hljs-keyword">load</span> [<span class="hljs-keyword">OPTIONS</span>]<br></code></pre></td></tr></table></figure><ul><li>-i : 指定导入的文件，代替 STDIN。</li><li>-q : 精简输出信息。</li></ul><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker load -i myubuntu.tar<br></code></pre></td></tr></table></figure><h3 id="上传至私人与共有的方式："><a href="#上传至私人与共有的方式：" class="headerlink" title="上传至私人与共有的方式："></a>上传至私人与共有的方式：</h3><p>得先注册一个在dockerhub上的号。然后使用<code>docker login</code>登录，<code>docker logout</code>退出。</p><h4 id="公共仓库："><a href="#公共仓库：" class="headerlink" title="公共仓库："></a>公共仓库：</h4><p><strong>上传：</strong></p><ol><li><p>docker tag : 标记本地镜像。</p><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker tag IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> tag hello-world:latest peng7066/test-hello-world:<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li><li><p>docker push：上传镜像。</p><p>语法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker push NAME[:TAG]<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> push peng7066/test-hello-world:<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li></ol><p><strong>拉取：</strong></p><ol><li>docker pull：拉取镜像</li></ol><h4 id="私有仓库："><a href="#私有仓库：" class="headerlink" title="私有仓库："></a>私有仓库：</h4><p><strong>配置私有仓库认证：</strong></p><ol><li><p>生成自签名证书：</p><ol><li><p>创建证书目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p /usr/local/registry/certs<br></code></pre></td></tr></table></figure></li><li><p>生成自签名证书命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl req -newkey rsa:2048 -nodes -sha256 -keyout /usr/local/registry/domain.key -x509 -days 365 -out /usr/local/registry/certs/domain.crt<br></code></pre></td></tr></table></figure><ul><li><code>openssl req</code>：创建证书签名请求等功能；</li><li><code>-newkey</code>：创建CSR证书签名文件和RSA私钥文件；</li><li><code>rsa:2048</code>：指定创建的RSA私钥长度为2048；</li><li><code>-nodes</code>：对私钥不进行加密；</li><li><code>-sha256</code>：使用SHA256算法</li><li><code>-keyout</code>：创建的私钥文件名称及位置</li><li><code>-x509</code>：自签发证书格式</li><li><code>-days</code>：证书有效期</li><li><code>-out</code>：指定CSR输出文件名称及位置</li></ul><p>通过openssl 先生成自签名证书，运行命令后需要填写一些证书信息，里面最关键的部分是：<code>Common Name (eg,your name or your server&#39;s hostname) []:81.70.10.115</code>，这里注意填写的要是自己服务器的地址。</p></li></ol></li><li><p>生成鉴权密码文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建存储鉴权密码文件的目录</span><br>mkdir -p /usr/local/registry/auth<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果没有htpasswd 功能需要安装 htpasswd</span><br>yum install -y httpd<br><span class="hljs-meta prompt_">#</span><span class="language-bash">创建用户和密码</span><br>htpasswd -Bbn root 1234 &gt; /usr/local/registry/auth/htpasswd<br></code></pre></td></tr></table></figure><blockquote><p>htpasswd 是 apache http 的基本认证文件，使用htpasswd 命令可以生成用户及密码文件</p></blockquote></li><li><p>拉取镜像后修改配置文件</p><p>修改配置文件<code>daemon.json</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/docker/daemon.json<br></code></pre></td></tr></table></figure><p>添加以下字段，指明我们的私有镜像仓库的地址</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-string">&quot;insecure-registries&quot;</span>: [<span class="hljs-string">&quot;81.70.10.115:5000&quot;</span>]<br></code></pre></td></tr></table></figure></li><li><p>创建私有仓库容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -di --name registry -p 5000:5000 \<br>-v /mydata/docker_registry:/var/lib/registry \<br>-v /usr/local/registry/certs:/certs \<br>-v /usr/local/registry/auth:/auth \<br>-e &quot;REGISTRY_AUTH=htpasswd&quot; \<br>-e &quot;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&quot; \<br>-e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \<br>-e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt \<br>-e REGISTRY_HTTP_TLE_KEY=/certs/domain.key \<br>registry<br></code></pre></td></tr></table></figure></li><li><p>登录</p><p>这时要指定仓库的地址</p><p><code>docker login 81.70.10.115:5000</code></p><p>然后就可以正常地<code>docker push</code>了</p><p>退出时也要指定仓库的地址</p><p><code>docker logout 81.70.10.115:5000</code></p></li></ol><h2 id="使用自定义网络："><a href="#使用自定义网络：" class="headerlink" title="使用自定义网络："></a>使用自定义网络：</h2><blockquote><p>默认的docker网络模式有三种：bridge，host，none</p><p>自定义的网络就是bridge的改进版，我们可以通过容器的名称直接来通讯，而不是每次启动都会改变的ip地址</p></blockquote><table><thead><tr><th>网络模式</th><th>简介</th></tr></thead><tbody><tr><td>Bridge</td><td>在这个模式中，docker daemon(守护进程)创建了一个以太网桥<code>docker0</code>，新建的容器会自动桥接到这个接口，<strong>具体流程是：</strong>守护进程会创建一对对等虚拟设备接口，将其中一端设为容器的<code>eth0</code>接口，一端保存在宿主机的命名空间中。容器创建时默认使用该模式。它分配ip的规则是根据容器的启动顺序递增分配的，就会出现上面说的情况，ip地址会变动。</td></tr><tr><td>Host</td><td>容器将不会虚拟出自己的网卡，配置自己的ip等。<strong>而是直接使用宿主机的ip和端口</strong></td></tr><tr><td>none</td><td>容器有独立的Network namespace,但并没有进行任何网络设置</td></tr></tbody></table><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5unw810twj20ol0dtdh8.jpg" alt="bridge"></p><h3 id="创建网络："><a href="#创建网络：" class="headerlink" title="创建网络："></a>创建网络：</h3><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker network create [OPTIONS] 网络名称<br></code></pre></td></tr></table></figure><p>重要参数：</p><ul><li><code>-d</code>：定义网络的驱动程序，默认为bridge</li></ul><h3 id="使用自定义网络：-1"><a href="#使用自定义网络：-1" class="headerlink" title="使用自定义网络："></a>使用自定义网络：</h3><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --net 网络名称 镜像名称<br></code></pre></td></tr></table></figure><h3 id="其它"><a href="#其它" class="headerlink" title="其它:"></a>其它:</h3><p><strong>断开：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">docker network disconnect <br></code></pre></td></tr></table></figure><blockquote><p>还有个集群的部分，未完待续。。。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>打怪升级</category>
      
      <category>搞定docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>🎮redis入门--简单命令</title>
    <link href="/2022/07/28/redis%E5%85%A5%E9%97%A8--%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/07/28/redis%E5%85%A5%E9%97%A8--%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>之前学过一段时间的redis，但碍于囫囵吞枣，而且没做总结，后来又没怎么用，所以忘的七七八八了，这次要整体好好的学一学redis，首先从简单命令开始。</p><span id="more"></span><h1 id="⛽redis入门–简单命令🙂"><a href="#⛽redis入门–简单命令🙂" class="headerlink" title="⛽redis入门–简单命令🙂"></a>⛽redis入门–简单命令🙂</h1><h2 id="五种数据类型："><a href="#五种数据类型：" class="headerlink" title="五种数据类型："></a>五种数据类型：</h2><h3 id="键命令："><a href="#键命令：" class="headerlink" title="键命令："></a>键命令：</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/keys-del.html">DEL key</a></td><td>删除键</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-dump.html">DUMP key</a></td><td>序列化键对应的值</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-exists.html">EXISTS key</a></td><td>判断键是否存在</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-expire.html">EXPIRE key</a> seconds</td><td>设置键的过期时间</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-expireat.html">EXPIREAT key timestamp</a></td><td>设置键在具体的一个时间过期，参数是时间戳的形式</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-pexpire.html">PEXPIRE key milliseconds</a></td><td>设置键的过期时间，参数以毫秒为单位</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-pexpireat.html">PEXPIREAT key milliseconds-timestamp</a></td><td>设置键在具体的一个时间过期，参数是毫秒时间戳的形式</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-keys.html">KEYS pattern</a></td><td>匹配符合的KEY</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-move.html">MOVE key db</a></td><td>将键移到其它的数据库</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-persist.html">PERSIST key</a></td><td>将KEY的过期时间去掉，永久保存</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-pttl.html">PTTL key</a></td><td>返回Key的有效时间，以毫秒为单位</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-ttl.html">TTL key</a></td><td>同上，以秒为单位</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-randomkey.html">RANDOMKEY</a></td><td>随机返回一个Key</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-rename.html">RENAME key newkey</a></td><td>重命名，如果newkey已经存在，则会覆盖</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-renamenx.html">RENAMENX key newkey</a></td><td>重命名，不过只有newkey不存在时才会成功</td></tr><tr><td>[SCAN cursor <a href="https://www.runoob.com/redis/keys-scan.html">MATCH pattern] [COUNT count]</a></td><td>遍历键，每次返回一个</td></tr><tr><td><a href="https://www.runoob.com/redis/keys-type.html">TYPE key</a></td><td>返回Key的类型</td></tr></tbody></table><h3 id="String-字符串-："><a href="#String-字符串-：" class="headerlink" title="String(字符串)："></a>String(字符串)：</h3><ul><li>string是redis中最基本的数据类型，一个key对应一个value。</li><li>string 类型是二进制安全的。意思是它可以存储任何数据，比如jpg图片和序列化后的对象。</li><li>最多可以存储512MB</li></ul><h4 id="增："><a href="#增：" class="headerlink" title="增："></a>增：</h4><table><thead><tr><th>增</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/strings-set.html">SET key value</a></td><td>设置指定KEY的值，KEY不存在则是添加，存在则是修改覆盖</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-mset.html">MSET key value key value </a></td><td>同时设置多个值</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-setbit.html">SETBIT key offset value</a></td><td>设置key上一个位的值（0或1）</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-setex.html">SETEX key seconds value</a></td><td>设置一个值，并设置过期时间</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-psetex.html">PSETEX key milliseconds value</a></td><td>设置一个值，并设置过期时间，时间的单位毫秒</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-setnx.html">SETNX key value</a></td><td>当KEY还未被使用时，在这个key上设一个值</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-msetnx.html">MSETNX key value key value </a></td><td>同时设置多个值，只有每个KEY都未被使用时成功执行</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-incr.html">INCR key</a></td><td>为数值加1</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-incrby.html">INCRBY key increment</a></td><td>为数值加上increment</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-incrbyfloat.html">INCRBYFLOAT key increment</a></td><td>将 key 所储存的值加上给定的浮点增量值（increment）</td></tr></tbody></table><h4 id="删："><a href="#删：" class="headerlink" title="删："></a>删：</h4><table><thead><tr><th>删</th><th>-</th></tr></thead><tbody><tr><td>DEL KEY</td><td>删查一个键</td></tr><tr><td>借鉴上面的过期</td><td></td></tr></tbody></table><h4 id="查："><a href="#查：" class="headerlink" title="查："></a>查：</h4><table><thead><tr><th>查</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/strings-get.html">GET key</a></td><td>获取key对应的值</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-mget.html">MGET key1 key2</a></td><td>获取多个key对应的值</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-getrange.html">GETRANGE key start end</a></td><td>获取key值对应区间的子字符串</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-getbit.html">GETBIT key offset</a></td><td>获取key上一个位的值</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-strlen.html">STRLEN key</a></td><td>获取key对应的值的长度</td></tr></tbody></table><h4 id="改："><a href="#改：" class="headerlink" title="改："></a>改：</h4><table><thead><tr><th>改</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/strings-setrange.html">SETRANGE key offset value</a></td><td>用value值从offset开始覆盖写</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-incr.html">INCR key</a></td><td>为数值加1</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-incrby.html">INCRBY key increment</a></td><td>为数值加上increment</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-incrbyfloat.html">INCRBYFLOAT key increment</a></td><td>将 key 所储存的值加上给定的浮点增量值（increment）</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-decr.html">DECR key</a></td><td>为数值减1</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-decrby.html">DECRBY key decrement</a></td><td>为数值减decremen</td></tr><tr><td><a href="https://www.runoob.com/redis/strings-append.html">APPEND key value</a></td><td>如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。</td></tr></tbody></table><h3 id="Hash-哈希-："><a href="#Hash-哈希-：" class="headerlink" title="Hash(哈希)："></a>Hash(哈希)：</h3><h4 id="增：-1"><a href="#增：-1" class="headerlink" title="增："></a>增：</h4><table><thead><tr><th>增</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/hashes-hset.html">HSET key field value</a></td><td>设置key上一个键值对</td></tr><tr><td><a href="https://www.runoob.com/redis/hashes-hmset.html">HMSET key field1 value1 field2 value2 </a></td><td>设置key上的多个键值对</td></tr><tr><td><a href="https://www.runoob.com/redis/hashes-hsetnx.html">HSETNX key field value</a></td><td>当key上的field字段还未设置时，添加该键值对</td></tr></tbody></table><h4 id="删：-1"><a href="#删：-1" class="headerlink" title="删："></a>删：</h4><table><thead><tr><th>删</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/hashes-hdel.html">HDEL key field1 field2</a></td><td>删除一个或多个key中的字段</td></tr></tbody></table><h4 id="查：-1"><a href="#查：-1" class="headerlink" title="查："></a>查：</h4><table><thead><tr><th>查</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/hashes-hget.html">HGET key field</a></td><td>获取key中的字段field的值</td></tr><tr><td><a href="https://www.runoob.com/redis/hashes-hmget.html">HMGET key field1 field2</a></td><td>获取key中多个字段field的值</td></tr><tr><td><a href="https://www.runoob.com/redis/hashes-hgetall.html">HGETALL key</a></td><td>获取在哈希表中指定 key 的所有字段和值</td></tr><tr><td><a href="https://www.runoob.com/redis/hashes-hkeys.html">HKEYS key</a></td><td>获取所有哈希表中的字段</td></tr><tr><td><a href="https://www.runoob.com/redis/hashes-hvals.html">HVALS key</a></td><td>获取哈希表中所有值</td></tr><tr><td><a href="https://www.runoob.com/redis/hashes-hlen.html">HLEN key</a></td><td>获取哈希表中字段的数量</td></tr><tr><td>[HSCAN key cursor <a href="https://www.runoob.com/redis/hashes-hscan.html">MATCH pattern] [COUNT count]</a></td><td>迭代哈希表中的键值对。pattern是对应field的</td></tr></tbody></table><h4 id="改：-1"><a href="#改：-1" class="headerlink" title="改："></a>改：</h4><table><thead><tr><th>改</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/hashes-hincrby.html">HINCRBY key field increment</a></td><td>为哈希表 key 中的指定字段的整数值加上增量 increment</td></tr><tr><td><a href="https://www.runoob.com/redis/hashes-hincrbyfloat.html">HINCRBYFLOAT key field increment</a></td><td>为哈希表 key 中的指定字段的浮点数值加上增量 increment</td></tr></tbody></table><h3 id="List-列表-："><a href="#List-列表-：" class="headerlink" title="List(列表)："></a>List(列表)：</h3><h4 id="增：-2"><a href="#增：-2" class="headerlink" title="增："></a>增：</h4><table><thead><tr><th>增</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/lists-lpush.html">LPUSH key value1 value2</a></td><td>往队头插入多个值</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-lpushx.html">LPUSHX key value</a></td><td>将一个值插入到已存在的列表头部</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-rpush.html">RPUSH key value1 value2</a></td><td>在列表尾部添加一个或多个值</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-rpushx.html">RPUSHX key value</a></td><td>为已存在的列表添加值</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-linsert.html">LINSERT key BEFORE|AFTER pivot value</a></td><td>在列表中与pivot相等的元素前或者后插入元素</td></tr></tbody></table><h4 id="删：-2"><a href="#删：-2" class="headerlink" title="删："></a>删：</h4><table><thead><tr><th>删</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/lists-lpop.html">LPOP key</a></td><td>移出并获取列表的第一个元素</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-rpop.html">RPOP key</a></td><td>移除列表的最后一个元素，返回值为移除的元素</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-blpop.html">BLPOP key1 key2 timeout</a></td><td>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-brpop.html">BRPOP key1 key2  timeout</a></td><td>同上，不过是移除最后一个元素</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-rpoplpush.html">RPOPLPUSH source destination</a></td><td>移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-brpoplpush.html">BRPOPLPUSH source destination timeout</a></td><td>从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-lrem.html">LREM key count value</a></td><td>移除列表中与value相等的，count绝对值个元素，count大于0表示从对头开始的count个元素，count小于0表示从队尾开始的count个元素，count&#x3D;0则是删除全部相等的</td></tr></tbody></table><h4 id="查：-2"><a href="#查：-2" class="headerlink" title="查："></a>查：</h4><table><thead><tr><th>查</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/lists-lindex.html">LINDEX key index</a></td><td>通过索引获取列表中的元素</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-llen.html">LLEN key</a></td><td>获取列表长度</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-lrange.html">LRANGE key start stop</a></td><td>获取列表指定范围内的元素</td></tr></tbody></table><h4 id="改：-2"><a href="#改：-2" class="headerlink" title="改："></a>改：</h4><table><thead><tr><th>改</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/lists-lset.html">LSET key index value</a></td><td>通过索引设置列表元素的值</td></tr><tr><td><a href="https://www.runoob.com/redis/lists-ltrim.html">LTRIM key start stop</a></td><td>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</td></tr></tbody></table><h3 id="Set-集合-："><a href="#Set-集合-：" class="headerlink" title="Set(集合)："></a>Set(集合)：</h3><h4 id="增：-3"><a href="#增：-3" class="headerlink" title="增："></a>增：</h4><table><thead><tr><th>增</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/sets-sadd.html">SADD key member1 member2</a></td><td>向集合添加一个或多个成员</td></tr></tbody></table><h4 id="删：-3"><a href="#删：-3" class="headerlink" title="删："></a>删：</h4><table><thead><tr><th>删</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/sets-srem.html">SREM key member1 member2</a></td><td>移除集合中一个或多个成员</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-spop.html">SPOP key</a></td><td>移除并返回集合中的一个随机元素</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-smove.html">SMOVE source destination member</a></td><td>将 member 元素从 source 集合移动到 destination 集合</td></tr></tbody></table><h4 id="查：-3"><a href="#查：-3" class="headerlink" title="查："></a>查：</h4><table><thead><tr><th>查</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/sets-scard.html">SCARD key</a></td><td>获取集合的成员数</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-sdiff.html">SDIFF key1 key2</a></td><td>返回第一个集合与其他集合之间的差异</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-sdiffstore.html">SDIFFSTORE destination key1 key2</a></td><td>返回给定所有集合的差集并存储在 destination 中</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-sinter.html">SINTER key1 key2</a></td><td>返回给定所有集合的交集</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-sinterstore.html">SINTERSTORE destination key1 key2</a></td><td>返回给定所有集合的交集并存储在 destination 中</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-sunion.html">SUNION key1 key2</a></td><td>返回所有给定集合的并集</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-sunionstore.html">SUNIONSTORE destination key1 key2</a></td><td>所有给定集合的并集存储在 destination 集合中</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-sismember.html">SISMEMBER key member</a></td><td>判断 member 元素是否是集合 key 的成员</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-smembers.html">SMEMBERS key</a></td><td>返回集合中的所有成员</td></tr><tr><td><a href="https://www.runoob.com/redis/sets-srandmember.html">SRANDMEMBER key count</a></td><td>返回集合中一个或多个随机数</td></tr><tr><td>[SSCAN key cursor <a href="https://www.runoob.com/redis/sets-sscan.html">MATCH pattern] [COUNT count]</a></td><td>迭代集合中的元素</td></tr></tbody></table><h3 id="zset-sorted-set-有序集合-："><a href="#zset-sorted-set-有序集合-：" class="headerlink" title="zset(sorted set:有序集合)："></a>zset(sorted set:有序集合)：</h3><h4 id="增：-4"><a href="#增：-4" class="headerlink" title="增："></a>增：</h4><table><thead><tr><th>增</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zadd.html">ZADD key score1 member1 score2 member2</a></td><td>向有序集合添加一个或多个成员，或者更新已存在成员的分数</td></tr></tbody></table><h4 id="删：-4"><a href="#删：-4" class="headerlink" title="删："></a>删：</h4><table><thead><tr><th>删</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zrem.html">ZREM key member member </a></td><td>移除有序集合中的一个或多个成员</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zremrangebylex.html">ZREMRANGEBYLEX key min max</a></td><td>移除有序集合中给定的字典区间的所有成员</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zremrangebyrank.html">ZREMRANGEBYRANK key start stop</a></td><td>移除有序集合中给定的排名区间的所有成员</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zremrangebyscore.html">ZREMRANGEBYSCORE key min max</a></td><td>移除有序集合中给定的分数区间的所有成员</td></tr></tbody></table><h4 id="查：-4"><a href="#查：-4" class="headerlink" title="查："></a>查：</h4><table><thead><tr><th>查</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zcard.html">ZCARD key</a></td><td>获取有序集合的成员数</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zcount.html">ZCOUNT key min max</a></td><td>计算在有序集合中指定区间分数的成员数</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zlexcount.html">ZLEXCOUNT key min max</a></td><td>在有序集合中计算指定字典区间内成员数量</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zrange.html">ZRANGE key start stop WITHSCORES</a></td><td>通过索引区间返回有序集合指定区间内的成员</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zrevrange.html">ZREVRANGE key start stop WITHSCORES</a></td><td>返回有序集中指定区间内的成员，通过索引，分数从高到低</td></tr><tr><td>[ZRANGEBYSCORE key min max <a href="https://www.runoob.com/redis/sorted-sets-zrangebyscore.html">WITHSCORES] [LIMIT offset count]</a></td><td>通过分数返回有序集合指定区间内的成员</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zrevrangebyscore.html">ZREVRANGEBYSCORE key max min WITHSCORES</a></td><td>返回有序集中指定分数区间内的成员，分数从高到低排序</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zrangebylex.html">ZRANGEBYLEX key min max LIMIT offset count</a></td><td>通过字典区间返回有序集合的成员</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zinterstore.html">ZINTERSTORE destination numkeys key key </a></td><td>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 destination 中</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zunionstore.html">ZUNIONSTORE destination numkeys key key</a></td><td>计算给定的一个或多个有序集的并集，并存储在新的 key 中</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zrank.html">ZRANK key member</a></td><td>返回有序集合中指定成员的索引</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zrevrank.html">ZREVRANK key member</a></td><td>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td></tr><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zscore.html">ZSCORE key member</a></td><td>返回有序集中，成员的分数值</td></tr><tr><td>[ZSCAN key cursor <a href="https://www.runoob.com/redis/sorted-sets-zscan.html">MATCH pattern] [COUNT count]</a></td><td>迭代有序集合中的元素（包括元素成员和元素分值）</td></tr></tbody></table><h4 id="改：-3"><a href="#改：-3" class="headerlink" title="改："></a>改：</h4><table><thead><tr><th>改</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/sorted-sets-zincrby.html">ZINCRBY key increment member</a></td><td>有序集合中对指定成员的分数加上增量 increment</td></tr></tbody></table><h2 id="基数统计："><a href="#基数统计：" class="headerlink" title="基数统计："></a>基数统计：</h2><blockquote><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p><p>什么是基数?</p><p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p></blockquote><table><thead><tr><th>-</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/hyperloglog-pfadd.html">PFADD key element element</a></td><td>添加指定元素到 HyperLogLog 中</td></tr><tr><td><a href="https://www.runoob.com/redis/hyperloglog-pfcount.html">PFCOUNT key key</a></td><td>返回给定 HyperLogLog 的基数值，如果多个 HyperLogLog 则返回基数估值之和。</td></tr><tr><td><a href="https://www.runoob.com/redis/hyperloglog-pfmerge.html">PFMERGE destkey sourcekey sourcekey </a></td><td>将多个 HyperLogLog 合并为一个 HyperLogLog</td></tr></tbody></table><h2 id="发布订阅："><a href="#发布订阅：" class="headerlink" title="发布订阅："></a>发布订阅：</h2><blockquote><p>Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p></blockquote><table><thead><tr><th>-</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/pub-sub-subscribe.html">SUBSCRIBE channel channel </a></td><td>订阅给定的一个或多个频道的信息。</td></tr><tr><td><a href="https://www.runoob.com/redis/pub-sub-psubscribe.html">PSUBSCRIBE pattern pattern</a></td><td>订阅一个或多个符合给定模式的频道</td></tr><tr><td>[PUNSUBSCRIBE <a href="https://www.runoob.com/redis/pub-sub-punsubscribe.html">pattern [pattern …]]</a></td><td>退订所有给定模式的频道</td></tr><tr><td><a href="https://www.runoob.com/redis/pub-sub-publish.html">PUBLISH channel message</a></td><td>将信息发送到指定的频道</td></tr><tr><td>[UNSUBSCRIBE <a href="https://www.runoob.com/redis/pub-sub-unsubscribe.html">channel [channel …]]</a></td><td>指退订给定的频道</td></tr><tr><td><a href="https://www.runoob.com/redis/pub-sub-pubsub.html">PUBSUB channels pattern</a></td><td>Pattern 有则返回跟pattern相关的，没有则返回全部</td></tr></tbody></table><h2 id="事务："><a href="#事务：" class="headerlink" title="事务："></a>事务：</h2><blockquote><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p><p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p></blockquote><table><thead><tr><th>-</th><th>-</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/redis/transactions-multi.html">MULTI</a></td><td>标记一个事务块的开始。</td></tr><tr><td><a href="https://www.runoob.com/redis/transactions-exec.html">EXEC</a></td><td>执行所有事务块内的命令。</td></tr><tr><td><a href="https://www.runoob.com/redis/transactions-discard.html">DISCARD</a></td><td>取消事务，放弃执行事务块内的所有命令。</td></tr><tr><td><a href="https://www.runoob.com/redis/transactions-watch.html">WATCH key key</a></td><td>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</td></tr><tr><td><a href="https://www.runoob.com/redis/transactions-unwatch.html">UNWATCH</a></td><td>取消 WATCH 命令对所有 key 的监视。</td></tr></tbody></table><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><blockquote><p>Redis Stream 是 Redis 5.0 版本新增加的数据结构。</p><p>Redis Stream 主要用于消息队列（MQ，Message Queue），Redis 本身是有一个 Redis 发布订阅 (pub&#x2F;sub) 来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。</p><p>简单来说发布订阅 (pub&#x2F;sub) 可以分发消息，但无法记录历史消息。</p><p>而 Redis Stream 提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</p></blockquote><table><thead><tr><th>-</th><th>-</th></tr></thead><tbody><tr><td>XADD key ID field value [field value …]</td><td><strong>key</strong> ：队列名称，如果不存在就创建 <strong>ID</strong> ：消息 id，我们使用 * 表示由 redis 生成，可以自定义，但是要自己保证递增性。 <strong>field value</strong> ： 记录。</td></tr><tr><td>XTRIM key MAXLEN</td><td><strong>key</strong> ：队列名称 <strong>MAXLEN</strong> ：长度</td></tr><tr><td>XDEL key ID [ID …]</td><td><strong>key</strong>：队列名称 <strong>ID</strong> ：消息 ID</td></tr><tr><td>XLEN key</td><td>使用 XLEN 获取流包含的元素数量，即消息长度</td></tr><tr><td>XRANGE key start end [COUNT count]</td><td><strong>key</strong> ：队列名 <strong>start</strong> ：开始值， <strong>-</strong> 表示最小值 <strong>end</strong> ：结束值， <strong>+</strong> 表示最大值 <strong>count</strong> ：数量</td></tr><tr><td>XREVRANGE key end start [COUNT count]</td><td><strong>key</strong> ：队列名 <strong>end</strong> ：结束值， <strong>+</strong> 表示最大值 <strong>start</strong> ：开始值， <strong>-</strong> 表示最小值 <strong>count</strong> ：数量</td></tr><tr><td>XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key …] id [id …]</td><td><strong>count</strong> ：数量 <strong>milliseconds</strong> ：可选，阻塞毫秒数，没有设置就是非阻塞模式 <strong>key</strong> ：队列名 <strong>id</strong> ：消息 ID</td></tr><tr><td>XGROUP [CRETE KEY groupname id-or-$]</td><td><strong>key</strong> ：队列名称，如果不存在就创建 <strong>groupname</strong> ：组名。 <strong>$</strong> ： 表示从尾部开始消费，只接受新消息，当前 Stream 消息会全部忽略。</td></tr><tr><td>XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key …] ID [ID …]</td><td><strong>group</strong> ：消费组名 <strong>consumer</strong> ：消费者名。 <strong>count</strong> ： 读取数量。 <strong>milliseconds</strong> ： 阻塞毫秒数。 <strong>key</strong> ： 队列名。 <strong>ID</strong> ： 消息 ID。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>打怪升级</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>⚒认证与授权--cookie|session|token|JWT</title>
    <link href="/2022/07/27/%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/"/>
    <url>/2022/07/27/%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<p>用户认证与授权是一个系统最基本的功能，下面我们一起了解下常见的解决方案的特性与他们相互间的差别，最后是JWT在Go上的使用案例。</p><span id="more"></span><h1 id="😀认证与授权："><a href="#😀认证与授权：" class="headerlink" title="😀认证与授权："></a>😀认证与授权：</h1><blockquote><p>常见的解决方案有cookie、session、token</p><p>在知乎上看到有人用了一个很秒的例子来描述这三个东西👍：在学校或公司，入学入职的那一天，会录入你的身份、账户信息，然后给你发个卡，今后在园区内，你的门禁、打卡、消费都只需要这张卡。</p></blockquote><h2 id="😁Cookie："><a href="#😁Cookie：" class="headerlink" title="😁Cookie："></a>😁Cookie：</h2><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>保存在客户端</li><li>不可跨域，每个Cookie会被绑定在单一域名下，无法在别的域名下使用</li></ul><h3 id="属性（1-⑥）："><a href="#属性（1-⑥）：" class="headerlink" title="属性（1+⑥）："></a>属性（1+⑥）：</h3><ul><li><p><strong>键值对</strong>：在Cookie中设置自定义的值，eg：<code>id=&quot;123456&quot;</code></p></li><li><p><strong>Cookie的域：</strong>在响应首部的Set-Cookie添加domain属性，来控制哪些站点能看到这个Cookie。eg：<code>Set-Cookie: name=&quot;Peng&quot;;domain=&quot;m.zhuanzhuan.58.com&quot;</code>，如果用户访问的是m.zhuanzhuan.58.com，或者m.zhuanzhuan.58.com&#x2F;user 则都可以，而如果是<a href="http://www.aaa.com(非zhuanzhuan.58.com)就不会看到这个cookie./">www.aaa.com(非zhuanzhuan.58.com)就不会看到这个Cookie。</a></p></li><li><p><strong>Cookie的路径Path：</strong>通过添加Path属性可以在特定的路径（这个属性设置的Url和带有这个前缀的Url路径都是有效的）下获得Cookie。</p></li><li><p><strong>Secure：</strong>设置了属性Secure，<code>Set-Cookie: name=&quot;Peng&quot;;domain=&quot;m.zhuanzhuan.58.com&quot;;Secure</code>，则这个Cookie只有在https协议加密的情况下才会发送给客户端</p></li><li><p>**HTTP only:**设置该属性后，则无法通过JS脚本来获得Cookie。</p></li><li><p><strong>Expires：</strong>设置Cookie的过期时间，GMT格式，到达该时间后Cookie会自动失效。</p></li><li><p><strong>max-age：</strong>在HTTP1.1中定义的，优先级高于Expires，表示Cookie的有效期，单位为秒，当值为正数时表示再过去n秒后该Cookie失效，当值为负数时，表示该Cookie为临时Cookie，在浏览器退出后该Cookie则失效，如果值为0则表示取消该Cookie。默认为-1。</p></li></ul><h3 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h3><p><img src="https://pic.rmb.bdstatic.com/bjh/9005b6a0f0e19e96d433046bbf434448.png"></p><ol><li>用户输入用户名，密码（或其它认证方式）到服务器。</li><li>服务器认证成功后，就会利用Set-cookie的头部字段，将Cookie返回给客户端。</li><li>客户端下一次发起请求时，请求首部则会带上这个Cookie</li><li>服务器通过客户端发来的Cookie，便能知道发出该请求的用户，并决定是否通过</li></ol><h2 id="Session-😜"><a href="#Session-😜" class="headerlink" title="Session:😜"></a>Session:😜</h2><blockquote><p>对应于Session就是，其实你的卡上只存了一个id（可能是你的学号），刷的时候物业系统就会去查你的信息、账户，再决定“这个门你能不能进”“这个鸡腿去哪个账户扣钱”</p></blockquote><h3 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h3><ul><li>有重要信息（用户信息，Session状态等）的Session保存在服务器中，而会生成一个SessionId给客户端保存。</li><li>一般基于Cookie实现。</li></ul><h3 id="过程：-1"><a href="#过程：-1" class="headerlink" title="过程："></a>过程：</h3><p><img src="https://pic3.zhimg.com/80/v2-18bd4826103a35c3ef4d99742ad1bd12_1440w.jpg"></p><ol><li>用户输入用户名，密码（或其它认证方式）到服务器。</li><li>服务器认证成功后，在服务器端生成一个Session，保存在文件或者内存或缓存中，然后返回给客户端一个SessionId，SessionId会被客户端保存在Cookie上。</li><li>客户端下一次发起请求时，会自动带上Cookie，Cookie中会携带SessionId。</li><li>服务器接受到Cookie后，检查SessionId的有效性后，决定是否通过。</li></ol><h2 id="😋Token："><a href="#😋Token：" class="headerlink" title="😋Token："></a>😋Token：</h2><blockquote><p>对应于Token就是，在比较早之前，在没有校园卡技术以前，我们都靠学生证。门卫小哥直接对照我和学生证上的脸，确认学生证有效期、年纪等信息，就可以放行了。</p></blockquote><h3 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h3><ul><li>服务器不用再存储信息，减少服务器的压力。</li><li>Token保存在客户端，服务器只需检验Token的有效性</li></ul><h3 id="过程：-2"><a href="#过程：-2" class="headerlink" title="过程："></a>过程：</h3><p><img src="https://pic2.zhimg.com/80/v2-45c53c27a611d78c489a25f3496c7625_1440w.jpg"></p><ol><li>用户输入用户名，密码（或其它认证方式）到服务器。</li><li>服务器认证成功后，在服务器端生成一个Token，这里展示的是通过Cookie传回token,token里面包括了基本的用户信息。</li><li>客户端保存Token后，下次请求时会带上Token</li><li>服务器检验Token的有效性后，决定是否通过。</li></ol><p><strong>考虑到编码，防篡改等问题我们直接讲Token的一个实践JWT（Json Web Token）</strong></p><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT:"></a>JWT:</h2><p><img src="https://pic.rmb.bdstatic.com/bjh/f5b29a28f7c421c77022122c1d291c6c.png" alt="image-20220722172608892"></p><center>一个完整的JWT的结构</center><h3 id="特点：-3"><a href="#特点：-3" class="headerlink" title="特点："></a>特点：</h3><ul><li>继承上面Token的优势，进一步地改善了编码，防篡改的问题。</li></ul><h3 id="三大组成："><a href="#三大组成：" class="headerlink" title="三大组成："></a>三大组成：</h3><p><strong>Header：</strong></p><p>Header主要保存了这个JWT的元数据，主要就是两个部分:<code>alg</code>和<code>typ</code>，<code>alg</code>属性表示签名的算法(algorithm),默认是HMAC SHA256 简写为HS256，<code>typ</code>表示Token的类型，JWT则为JWT。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;alg&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;HS256&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;typ&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;JWT&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>Payload：</strong></p><p>Payload则是存放数据的地方，JWT规定了7个官方字段，供选用。</p><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul><p>我们也可以自己加入一些私有字段。</p><p><strong>这里要注意的是：</strong>虽说我们后面有签名的环节，但那只是为了防止篡改，上面两个部分我们采用的base64UrlEncode编码方法是可以通过防编码出来的，所以重要数据不能放在Payload中。</p><p><strong>Signature:</strong></p><p>在上面Token的部分你可能就有察觉到，我们这次是将用户的信息放在Token里面保存到Cookie中的，这里就存在我们的Token信息被读取，被人用来伪装的可能性，所以就加了签名这一步骤，服务器自己保存了一把密钥，这样就算别人窃取了信息，也无法进行签名，进行伪装。</p><p><strong>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户</strong>。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">HMACSHA256</span>(<br>  base64UrlEncode(header) + &quot;.&quot; +<br>  <span class="hljs-built_in">base64UrlEncode</span>(payload),<br>  secret)<br></code></pre></td></tr></table></figure><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（<code>.</code>）分隔，就可以返回给用户。</p><h3 id="过程：-3"><a href="#过程：-3" class="headerlink" title="过程："></a>过程：</h3><ol><li>用户输入用户名，密码（或其它认证方式）到服务器。</li><li>服务器认证成功后，生成一个JWT，返回给客户端，客户端将会保存JWT。</li><li>客户端下一次发起请求时会带上JWT</li><li>服务器用自己的私钥解析客户端发送过来的JWT，决定是否通过</li></ol><h2 id="JWT在Go中的使用案例："><a href="#JWT在Go中的使用案例：" class="headerlink" title="JWT在Go中的使用案例："></a>JWT在Go中的使用案例：</h2><p>首先go get 一下✨</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> get github.com/dgrijalva/jwt-<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><h3 id="获取JWT："><a href="#获取JWT：" class="headerlink" title="获取JWT："></a>获取JWT：</h3><p>根据前面的讲解，我们已经了解到JWT的数据结构，它就是由两个编码过的json文件加一个签名组成。那我们要做的就是拼装这三个部分。</p><p><strong>Header：</strong></p><p>这个部分包含两个字段，这两个字段都不用我们填，会由你选择的签名算法自动填写好。</p><p><strong>Payload：</strong>（获得Token对象）</p><p>首先我们看下<code>jwt.StandardClaims</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">type</span> StandardClaims <span class="hljs-keyword">struct</span> &#123;<br>Audience  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;aud,omitempty&quot;`</span><br>ExpiresAt <span class="hljs-type">int64</span>  <span class="hljs-string">`json:&quot;exp,omitempty&quot;`</span><br>Id        <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;jti,omitempty&quot;`</span><br>IssuedAt  <span class="hljs-type">int64</span>  <span class="hljs-string">`json:&quot;iat,omitempty&quot;`</span><br>Issuer    <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;iss,omitempty&quot;`</span><br>NotBefore <span class="hljs-type">int64</span>  <span class="hljs-string">`json:&quot;nbf,omitempty&quot;`</span><br>Subject   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;sub,omitempty&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这就是我们上面所说的官方提供的几个可选的字段，在Go中我们使用常用的方法–结构体组合来实现添加我们想要的字段，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Claims <span class="hljs-keyword">struct</span> &#123;<br>UserId <span class="hljs-type">int64</span><br>jwt.StandardClaims<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们把这些字段填充完整，就可以得到Token了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">claims := &amp;Claims&#123;<br>    UserId: user.UserInfoId,<br>    StandardClaims: jwt.StandardClaims&#123;<br>        ExpiresAt: expirationTime.<span class="hljs-built_in">Unix</span>(),<br>        IssuedAt:  time.<span class="hljs-built_in">Now</span>().<span class="hljs-built_in">Unix</span>(),<br>        Issuer:    <span class="hljs-string">&quot;douyin_pro_131&quot;</span>,<br>        Subject:   <span class="hljs-string">&quot;L_B__&quot;</span>,<br>    &#125;&#125;<br>token := jwt.<span class="hljs-built_in">NewWithClaims</span>(jwt.SigningMethodHS256, claims)<br><br></code></pre></td></tr></table></figure><p><strong>Signature:</strong></p><p>上面获得Token对象后，调用<code>jwt.SignedString()</code>，并传入自己服务器保存的密钥（一个 <code>byte[]</code>），就会自动完成Signature部分的编写和对上面三个部分分别进行base64url编码，再整合成一个最终的字符串返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">jwtKey:=[]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;我的密钥&quot;</span>)<br>tokenString,err:=token.SignedString(jwtKey)<br></code></pre></td></tr></table></figure><h3 id="验证JWT："><a href="#验证JWT：" class="headerlink" title="验证JWT："></a>验证JWT：</h3><p>以常用的Web框架Gin为例，我们会把这个部分放到中间件那里使用。</p><p>解析Token：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParseToken</span><span class="hljs-params">(tokenString <span class="hljs-type">string</span>)</span></span> (*MyClaims, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 验证token是否是我们自己签发的</span><br>token, err := jwt.ParseWithClaims(tokenString, &amp;MyClaims&#123;&#125;, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(token *jwt.Token)</span></span> (i <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> jwtKey, <span class="hljs-literal">nil</span><br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> claims, ok := token.Claims.(*MyClaims); ok &amp;&amp; token.Valid &#123; <span class="hljs-comment">// 校验token</span><br><span class="hljs-keyword">return</span> claims, <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;invalid token&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>用于中间件中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">JWTAuthMiddleware</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">// 客户端携带Token有三种方式 1.放在请求头 2.放在请求体 3.放在URI</span><br><span class="hljs-comment">// 这里假设Token放在Header的Authorization中，并使用Bearer开头</span><br><span class="hljs-comment">// 这里的具体实现方式要依据你的实际业务情况决定</span><br>authHeader := c.Query(<span class="hljs-string">&quot;token&quot;</span>)<br>fmt.Println(authHeader)<br><span class="hljs-keyword">if</span> authHeader == <span class="hljs-string">&quot;&quot;</span> &#123;<br>authHeader = c.PostForm(<span class="hljs-string">&quot;token&quot;</span>)<br>fmt.Println(authHeader)<br>&#125;<br><br><span class="hljs-keyword">if</span> authHeader == <span class="hljs-string">&quot; &quot;</span> &#123;<br>c.JSON(http.StatusOK, service.UserResponse&#123;<br>Response: service.Response&#123;StatusCode: <span class="hljs-number">1</span>&#125;,<br>&#125;)<br>c.Abort()<br><span class="hljs-keyword">return</span><br>&#125;<br><br>mc, err := app.ParseToken(authHeader)  <span class="hljs-comment">//就是调用上面的ParseToken</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>c.JSON(http.StatusOK, service.UserResponse&#123;<br>Response: service.Response&#123;StatusCode: <span class="hljs-number">1</span>&#125;,<br>&#125;)<br>c.Abort()<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(mc.UserId)<br><span class="hljs-comment">// 将当前请求的username信息保存到请求的上下文c上</span><br>c.Set(<span class="hljs-string">&quot;user_id&quot;</span>, mc.UserId)<br>c.Next() <span class="hljs-comment">// 后续的处理函数可以用过c.Get(&quot;user_id&quot;)来获取当前请求的用户信息</span><br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="JWT的一些问题："><a href="#JWT的一些问题：" class="headerlink" title="JWT的一些问题："></a>JWT的一些问题：</h3><ol><li><p>JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p></li><li><p>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p></li><li><p>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>常用中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>认证与授权</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搞定Docker--快速入门</title>
    <link href="/2022/07/19/Docker%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/19/Docker%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="🎉Docker🎉"><a href="#🎉Docker🎉" class="headerlink" title="🎉Docker🎉"></a>🎉Docker🎉</h1><p>之前老是听别人讲docker部署的各种优点，但之前单单就感觉确实挺好的，没去深入学习，这段时间有空所以打算把这把利器给捡起来！</p><span id="more"></span><blockquote><p>容器：操作系统级别的虚拟化技术。</p></blockquote><p>简史：前面是dotCloud，用了linux的容器化技术，中途发现活不下去了，就变成开源的了，活了之后就改名为docker了，后面为了进一步优化，投入了Go的怀抱，用了Go构建的引擎。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros">复习一点新虚拟机配网络的知识：<br><br>vim /etc/sysconfig/network-scripts/ifcfg-ens32 (32,也可能是33)<br><br>修改的参数：<br><span class="hljs-attribute">BOOTPROTO</span>=dhcp  (使用动态IP还是静态IP，dhcp改为static 动态改为静态)<br><span class="hljs-attribute">ONBOOT</span>=<span class="hljs-literal">no</span> (<span class="hljs-literal">no</span>改为<span class="hljs-literal">yes</span> 开机自启)<br><span class="hljs-attribute">IPADDR</span>=192.168.91.100 (IP地址，从VMware的虚拟网络设置里看)<br><span class="hljs-attribute">NETMASK</span>=255.255.255.0 (子网掩码)<br><span class="hljs-attribute">GATEWAY</span>=192.168.91.2 (网关，默认就是 IP地址 .2 )<br><span class="hljs-attribute">DNS1</span>=192.168.91.2 (自己的网关)<br><span class="hljs-attribute">DNS2</span>=144.144.144.44 (中国移动，联通 通用的 144.144.144.144)<br><span class="hljs-attribute">DNS3</span>=8.8.8.8(全球通用的,Google的)<br><br></code></pre></td></tr></table></figure><h2 id="🎖安装："><a href="#🎖安装：" class="headerlink" title="🎖安装："></a>🎖安装：</h2><ol><li><p><code>sudo yum install -y yum-utils </code>: 安装yum-utils这个包，我们才可以用它里面的工具:<code>yum-config-manager</code>来指定下载源</p></li><li><p><code>sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code>：设置为阿里的下载源</p></li><li><p><code> sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</code>  docker-ce ：docker引擎社区版、docker-ce-cli：docker引擎命令行界面 containerd.io：守护进程</p></li><li><p><code>docker -v</code>：查看版本，看是否成功。</p></li><li><p><code>docker run hello-world</code>:测试能否正常使用</p></li><li><p>配置镜像加速：1.<code>vim /etc/docker/daemon.json</code> </p><ol start="2"><li><p>添加到里面</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>启用配置、重启docker</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nsis">sudo <span class="hljs-params">system</span>ctl daemon-reload<br>sudo <span class="hljs-params">system</span>ctl restart docker<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="😱Docker-架构及工作原理："><a href="#😱Docker-架构及工作原理：" class="headerlink" title="😱Docker 架构及工作原理："></a>😱Docker 架构及工作原理：</h2><p>三个东西:</p><ul><li>Client：<strong>宿主机</strong>的命令行界面</li><li>Docker_Host：Docker引擎<ul><li>Docker daemon：<strong>守护进程</strong>，就像一个中枢一样，Client的命令发到这里，并由它来进行相应的操作，比如从远程仓库（Registry）拉取镜像，将拉取的镜像生成容器</li><li>images：镜像（模板，类似语言中的一个类）</li><li>Containers：容器 （真正工作的玩意，类似用上面的类创建的一个对象）</li></ul></li><li>Registry：远程仓库</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5un93x8qfj20hz0a4q3x.jpg"></p><h3 id="Client客户端："><a href="#Client客户端：" class="headerlink" title="Client客户端："></a>Client客户端：</h3><h3 id="镜像分层："><a href="#镜像分层：" class="headerlink" title="镜像分层："></a>镜像分层：</h3><p><img src="http://i2.51cto.com/images/blog/201711/27/462718f3cd35608c20481b33b09db020.jpg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="Docker镜像的内部结构(四)"></p><p>在使用docker后，我们会拉取很多很多的镜像到本地，为了防止拉取的镜像互相间存在冗余的数据（比如Nginx和Redis都需要安装C++环境，如果拉取镜像的时候都拉取了一个，这部分相同的C++环境就是冗余的数据了，更深入些，每个镜像依赖的最基础的Linux环境也会成为冗余数据的一部分)，所以Docker采用了镜像分层的技术，也就是将最基础的Linux环境做为Base镜像，后面最终我们所使用的镜像（Nginx、Redis等等）都是在这个Base镜像的基础上，堆上一层层其它的镜像构成的，如果不同的镜像有利用到相同的部分，则不会重复拉取，而是直接复用。</p><h3 id="Volume-数据卷："><a href="#Volume-数据卷：" class="headerlink" title="Volume 数据卷："></a>Volume 数据卷：</h3><p>使容器与宿主机建立映射关系，把容器里的数据映射到宿主机上，在创建容器的时候可以指定数据卷，如果不指定，则数据还是只保存在容器中。</p><h3 id="Registry"><a href="#Registry" class="headerlink" title="Registry:"></a>Registry:</h3><p><a href="hub.docker.com">官方镜像仓库</a> 需要联网，而且上传后别人也能看到</p><p>所以docker 提供了 registry 镜像，可供我们在局域网内搭建仓库，也可以设置身份认证等等</p><h2 id="💘Docker-常用命令："><a href="#💘Docker-常用命令：" class="headerlink" title="💘Docker 常用命令："></a>💘Docker 常用命令：</h2><h3 id="镜像相关命令："><a href="#镜像相关命令：" class="headerlink" title="镜像相关命令："></a>镜像相关命令：</h3><h4 id="1-查看镜像："><a href="#1-查看镜像：" class="headerlink" title="1.查看镜像："></a>1.查看镜像：</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">docker images<br><br></code></pre></td></tr></table></figure><ul><li><code>Repository</code>:仓库名称</li></ul><h4 id="2-搜索镜像："><a href="#2-搜索镜像：" class="headerlink" title="2.搜索镜像："></a>2.搜索镜像：</h4><p>如果需要从网络中查找需要的镜像，可以通过以下命令查看是否存在</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">docker search 镜像名<br></code></pre></td></tr></table></figure><h4 id="3-拉取镜像："><a href="#3-拉取镜像：" class="headerlink" title="3.拉取镜像："></a>3.拉取镜像：</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http">docker pull 镜像名<br><br>也可以指定标签：docker pull redis:5 (例子)<br></code></pre></td></tr></table></figure><h4 id="4-删除镜像："><a href="#4-删除镜像：" class="headerlink" title="4.删除镜像："></a>4.删除镜像：</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">docker rmi 镜像名<br>也可以指定标签：docker rmi redis:5 (例子)<br></code></pre></td></tr></table></figure><h3 id="容器命令："><a href="#容器命令：" class="headerlink" title="容器命令："></a>容器命令：</h3><h4 id="1-查看命令："><a href="#1-查看命令：" class="headerlink" title="1.查看命令："></a>1.查看命令：</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http">docker ps  查看运行的容器<br>docker ps -a 查看所有的容器<br>docker ps -l 查看最后创建的容器<br>docker ps -l -n 最后几个容器<br>docker ps -f status:exited  过滤查询<br>不知道怎么操作就可以加 --help来获得帮助<br></code></pre></td></tr></table></figure><h4 id="2-创建与启动："><a href="#2-创建与启动：" class="headerlink" title="2.创建与启动："></a>2.创建与启动：</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs http">docker run 镜像名  创建容器<br>参数：<br>--name: 指定创建的容器名<br>-p:指定端口  （宿主机端口：容器端口）<br>-P：自动指定<br>-i: 运行容器<br>-t:表示容器启动后会进入其命令行界面<br>-v:可以指定目录映射关系，可以用多个-v 映射多个目录<br>-it：启动并进入，有些容器创建后不会进入，就可以这样启动后并进入<br></code></pre></td></tr></table></figure><h4 id="3-守护进程进入"><a href="#3-守护进程进入" class="headerlink" title="3.守护进程进入"></a>3.守护进程进入</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">docker run -di 镜像名<br>docker exec -it [自己取的镜像名，容器ID]  进入容器<br></code></pre></td></tr></table></figure><h4 id="4-停止启动容器"><a href="#4-停止启动容器" class="headerlink" title="4.停止启动容器"></a>4.停止启动容器</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">docker stop 容器名<br>docker start 容器名<br></code></pre></td></tr></table></figure><h4 id="5-文件拷贝："><a href="#5-文件拷贝：" class="headerlink" title="5.文件拷贝："></a>5.文件拷贝：</h4><p>可以把宿主机的拷贝到容器，也可以把容器的拷贝到宿主机</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">docker cp 需要拷贝的文件或目录 容器名称:容器目录<br>docker cp 容器名称:容器目录或文件 拷贝到宿的主机的位置<br></code></pre></td></tr></table></figure><h4 id="6-目录挂载："><a href="#6-目录挂载：" class="headerlink" title="6.目录挂载："></a>6.目录挂载：</h4><p>如果不挂载，当容器被删除后，数据也就被删除了，挂载后，宿主机的数据则还在</p><ol><li><p>指定目录挂载：<code>docker run -di -v 宿主机位置:容器目录 镜像名称</code>，docker会自动创建相应的容器目录，如果没在创建容器时挂载，后面想挂载可以通过修改配置文件来实现。</p><p><code>docker inspect 容器名 </code>可以查看所有的详细信息。</p></li><li><p>匿名挂载：<code>docker run -di -v 容器目录 镜像名称</code>,匿名挂载我们不用指定宿主机的位置，统一会被放到 <code>/var/lib/docker/volumes</code> 中，它会自动生成一个随机名称的目录，如果匿名挂载过多时，可以通过<code>docker inspect 容器名</code>来查看被挂载时随机生成的名字。</p></li><li><p>具名挂载：<code>docker run -di -v 宿主机中的目录名字:容器目录 镜像名称</code>,和上面一样会被放到<code>/var/lib/docker/volumes</code>中，不过这次可以指定名字</p></li><li><p>设置权限（只读&#x2F;读写，有时我们不希望容器在内部操作，就只允许宿主机操作，就可以挂只读），<code>docker run -di -v 容器目录:ro/rw 镜像名称</code> 只读&#x2F;读写</p></li><li><p>继承：<code>--volumes-from 被继承的容器名:ro/rw</code>，可以继承之前容器挂载的目录</p></li><li><p>查看容器ip地址：<code>docker inspect 容器名称</code></p></li><li><p>删除容器：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">docker rm 容器名称|容器ID<br>docker rm 容器名称|容器ID 容器名称|容器ID 容器名称|容器ID<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>打怪升级</category>
      
      <category>搞定docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The First Blog</title>
    <link href="/2022/06/28/The-First-Blog/"/>
    <url>/2022/06/28/The-First-Blog/</url>
    
    <content type="html"><![CDATA[<h1 id="😍全军出击🎉"><a href="#😍全军出击🎉" class="headerlink" title="😍全军出击🎉"></a>😍全军出击🎉</h1><h2 id="革命尚未成功，还需继续努力🎖"><a href="#革命尚未成功，还需继续努力🎖" class="headerlink" title="革命尚未成功，还需继续努力🎖"></a>革命尚未成功，还需继续努力🎖</h2>]]></content>
    
    
    <categories>
      
      <category>陈词滥调</category>
      
      <category>第一篇博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FirstBlog</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
