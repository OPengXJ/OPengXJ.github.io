

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/3dd.png">
  <link rel="icon" href="/img/3dd.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="PEngxJ">
  <meta name="keywords" content="">
  
    <meta name="description" content="redis并没有直接使用这些数据结构来实现键值对数据库， 而是基于之前的数据结构创建了一个对象系统，让redis的键值对的底层数据结构更加灵活，公用对象节约内存，引用计数技术让控制更加便利。">
<meta property="og:type" content="article">
<meta property="og:title" content="🧀Redis对象----五大对象">
<meta property="og:url" content="https://opengxj.github.io/2022/10/15/Redis%E5%AF%B9%E8%B1%A1----%E4%BA%94%E5%A4%A7%E5%AF%B9%E8%B1%A1/index.html">
<meta property="og:site_name" content="PEngxJ的小破站">
<meta property="og:description" content="redis并没有直接使用这些数据结构来实现键值对数据库， 而是基于之前的数据结构创建了一个对象系统，让redis的键值对的底层数据结构更加灵活，公用对象节约内存，引用计数技术让控制更加便利。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008vxvgGgy1h760eufruvj30jy09lzl8.jpg">
<meta property="article:published_time" content="2022-10-15T07:29:33.000Z">
<meta property="article:modified_time" content="2022-10-17T07:18:17.628Z">
<meta property="article:author" content="PEngxJ">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/008vxvgGgy1h760eufruvj30jy09lzl8.jpg">
  
  
  
  <title>🧀Redis对象----五大对象 - PEngxJ的小破站</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"opengxj.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>PEngxJ的小破站</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://tva1.sinaimg.cn/large/008vxvgGgy1h760eufruvj30jy09lzl8.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="🧀Redis对象----五大对象"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-10-15 15:29" pubdate>
          2022年10月15日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          10k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          85 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">🧀Redis对象----五大对象</h1>
            
            
              <div class="markdown-body">
                
                <p>redis并没有直接使用这些数据结构来实现键值对数据库， 而是基于之前的数据结构创建了一个对象系统，让redis的键值对的底层数据结构更加灵活，公用对象节约内存，引用计数技术让控制更加便利。</p>
<span id="more"></span>

<h1 id="🧀Redis对象—-五大对象"><a href="#🧀Redis对象—-五大对象" class="headerlink" title="🧀Redis对象—-五大对象"></a>🧀Redis对象—-五大对象</h1><p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h76wu0ljr8j30vq0hsjt5.jpg" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>Redis 并没有直接使用这些数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个<mark>对象系统</mark>， 这个系统包含<strong>字符串对象</strong>、<strong>列表对象</strong>、<strong>哈希对象</strong>、<strong>集合对象</strong>和<strong>有序集合对象</strong>这五种类型的对象， 每种对象都用到了至少一种我们前面所介绍的数据结构。</p>
<p>通过这五种不同类型的对象， Redis 可以在执行命令之前， 根据对象的类型来判断一个对象是否可以执行给定的命令。 使用对象的另一个好处是， 我们可以<strong>针对不同的使用场景， 为对象设置多种不同的数据结构实现</strong>， 从而优化对象在不同场景下的使用效率。</p>
<p>除此之外， Redis 的对象系统还实现了基于<strong>引用计数</strong>技术的内存回收机制： 当程序不再使用某个对象的时候， 这个对象所占用的内存就会被自动释放； 另外， Redis 还通过引用计数技术实现了对象共享机制， 这一机制可以在适当的条件下， 通过让多个数据库键共享同一个对象来节约内存。</p>
<p>最后， Redis 的对象带有访问时间记录信息， 该信息可以用于计算数据库键的空转时长， 在服务器启用了 <code>maxmemory</code> 功能的情况下， 空转时长较大的那些键可能会优先被服务器删除</p>
</blockquote>
<p>在开始讲各个对象前，我们先来了解下各个对象的共同部分，即对象的存在形式。</p>
<h2 id="对象的类型与编码"><a href="#对象的类型与编码" class="headerlink" title="对象的类型与编码"></a>对象的类型与编码</h2><p>Redis 使用对象来表示数据库中的键和值， 每次当我们在 Redis 的数据库中新创建一个键值对时， 我们至少会创建两个对象， 一个对象用作键值对的键（键对象）， 另一个对象用作键值对的值（值对象）。那么对象的存在形式是什么呢？</p>
<p>在Redis 中的每个对象都由一个 <mark><code>redisObject</code></mark> 结构表示， 该结构中和保存数据有关的三个属性分别是 <code>type</code> 属性、 <code>encoding</code> 属性和 <code>ptr</code> 属性，还有几个属性后面再讲。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">redisObject</span> &#123;<br>    <span class="hljs-comment">// 类型</span><br>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 编码</span><br>    <span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 指向底层实现数据结构的指针</span><br>    <span class="hljs-type">void</span> *ptr;<br>    <span class="hljs-comment">// ...未完待续</span><br>&#125; robj;<br></code></pre></td></tr></table></figure>

<h3 id="类型（type）："><a href="#类型（type）：" class="headerlink" title="类型（type）："></a>类型（type）：</h3><p>该值就是redis用于区分不同对象的一个属性，很容易理解，它可以为以下的几个值之一</p>
<table>
<thead>
<tr>
<th align="left">类型常量</th>
<th align="left">对象的名称</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>REDIS_STRING</code></td>
<td align="left">字符串对象</td>
</tr>
<tr>
<td align="left"><code>REDIS_LIST</code></td>
<td align="left">列表对象</td>
</tr>
<tr>
<td align="left"><code>REDIS_HASH</code></td>
<td align="left">哈希对象</td>
</tr>
<tr>
<td align="left"><code>REDIS_SET</code></td>
<td align="left">集合对象</td>
</tr>
<tr>
<td align="left"><code>REDIS_ZSET</code></td>
<td align="left">有序集合对象</td>
</tr>
</tbody></table>
<p>上面的这句话《它可以为以下的几个值之一》，键对象表示与他无关，其实在redis中键一直是字符串对象，（这也是我们在往数据库里添加键值对时，不管加不加双引号都可以的原因），值对象才可以拥有以上的所有类型，因此：</p>
<ul>
<li>当我们称呼一个数据库键为“字符串键”时， 我们指的是“这个数据库键<strong>所对应的值</strong>为字符串对象”；</li>
<li>当我们称呼一个键为“列表键”时， 我们指的是“这个数据库键<strong>所对应的值</strong>为列表对象”，</li>
</ul>
<p>诸如此类。</p>
<p>所以我们通过<code>TYPE</code>命令查看的都是键值对的值的对象类型。</p>
<h3 id="编码和底层实现："><a href="#编码和底层实现：" class="headerlink" title="编码和底层实现："></a>编码和底层实现：</h3><p>对象的 <code>ptr</code> 指针指向对象的底层实现数据结构， 而这些数据结构由对象的 <code>encoding</code> 属性决定。</p>
<p><code>encoding</code> 属性记录了对象所使用的编码， 也即是说这个对象使用了什么数据结构作为对象的底层实现， 这个属性的值可以是下表列出的常量的其中一个。</p>
<table>
<thead>
<tr>
<th align="left">编码常量</th>
<th align="left">编码所对应的底层数据结构</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>REDIS_ENCODING_INT</code></td>
<td align="left"><code>long</code> 类型的整数</td>
</tr>
<tr>
<td align="left"><code>REDIS_ENCODING_EMBSTR</code></td>
<td align="left"><code>embstr</code> 编码的简单动态字符串</td>
</tr>
<tr>
<td align="left"><code>REDIS_ENCODING_RAW</code></td>
<td align="left">简单动态字符串</td>
</tr>
<tr>
<td align="left"><code>REDIS_ENCODING_HT</code></td>
<td align="left">字典</td>
</tr>
<tr>
<td align="left"><code>REDIS_ENCODING_LINKEDLIST</code></td>
<td align="left">双端链表</td>
</tr>
<tr>
<td align="left"><code>REDIS_ENCODING_ZIPLIST</code></td>
<td align="left">压缩列表</td>
</tr>
<tr>
<td align="left"><code>REDIS_ENCODING_INTSET</code></td>
<td align="left">整数集合</td>
</tr>
<tr>
<td align="left"><code>REDIS_ENCODING_SKIPLIST</code></td>
<td align="left">跳跃表和字典（较特别）</td>
</tr>
</tbody></table>
<p>下表是对象类型与相应的编码常量，可以大概浏览一下，知道一个对象由一个以上的底层数据结构实现就行。后面我们会对每个对象进行细讲</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">编码</th>
<th align="left">对象</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>REDIS_STRING</code></td>
<td align="left"><code>REDIS_ENCODING_INT</code></td>
<td align="left">使用整数值实现的字符串对象。</td>
</tr>
<tr>
<td align="left"><code>REDIS_STRING</code></td>
<td align="left"><code>REDIS_ENCODING_EMBSTR</code></td>
<td align="left">使用 <code>embstr</code> 编码的简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td align="left"><code>REDIS_STRING</code></td>
<td align="left"><code>REDIS_ENCODING_RAW</code></td>
<td align="left">使用简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td align="left"><code>REDIS_LIST</code></td>
<td align="left"><code>REDIS_ENCODING_QUICKLIST</code></td>
<td align="left">使用快速列表实现的列表对象。</td>
</tr>
<tr>
<td align="left"><code>REDIS_HASH</code></td>
<td align="left"><code>REDIS_ENCODING_ZIPLIST</code></td>
<td align="left">使用压缩列表实现的哈希对象。</td>
</tr>
<tr>
<td align="left"><code>REDIS_HASH</code></td>
<td align="left"><code>REDIS_ENCODING_HT</code></td>
<td align="left">使用字典实现的哈希对象。</td>
</tr>
<tr>
<td align="left"><code>REDIS_SET</code></td>
<td align="left"><code>REDIS_ENCODING_INTSET</code></td>
<td align="left">使用整数集合实现的集合对象。</td>
</tr>
<tr>
<td align="left"><code>REDIS_SET</code></td>
<td align="left"><code>REDIS_ENCODING_HT</code></td>
<td align="left">使用字典实现的集合对象。</td>
</tr>
<tr>
<td align="left"><code>REDIS_ZSET</code></td>
<td align="left"><code>REDIS_ENCODING_ZIPLIST</code></td>
<td align="left">使用压缩列表实现的有序集合对象。</td>
</tr>
<tr>
<td align="left"><code>REDIS_ZSET</code></td>
<td align="left"><code>REDIS_ENCODING_SKIPLIST</code></td>
<td align="left">使用跳跃表和字典实现的有序集合对象。</td>
</tr>
</tbody></table>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h3><p>字符串对象的编码可以是 <code>int</code> 、 <code>raw</code> 或者 <code>embstr</code> 。</p>
<ol>
<li><p>如果一个字符串对象保存的是整数值， 并且这个整数值可以用 <code>long</code> 类型来表示， 那么字符串对象会将整数值保存在字符串对象结构的 <code>ptr</code>属性里面（将 <code>void*</code> 转换成 <code>long</code> ）， 并将字符串对象的编码设置为 <code>int</code> 。</p>
</li>
<li><p>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度大于 <code>39</code> 字节， 那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值， 并将对象的编码设置为 <code>raw</code> 。</p>
</li>
<li><p>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度小于等于 <code>39</code> 字节， 那么字符串对象将使用 <code>embstr</code> 编码的方式来保存这个字符串值。</p>
<p><code>embstr</code> 编码是专门用于保存短字符串的一种优化编码方式， 这种编码和 <code>raw</code> 编码一样， 都使用 <code>redisObject</code> 结构和 <code>sdshdr</code> 结构来表示字符串对象， 但 <code>raw</code> 编码会调用两次内存分配函数来分别创建 <code>redisObject</code> 结构和 <code>sdshdr</code> 结构， 而 <code>embstr</code> 编码则通过调用一次内存分配函数来分配一块连续的空间， 空间中依次包含 <code>redisObject</code> 和 <code>sdshdr</code> 两个结构， 如下图所示。</p>
</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h761ri37w9j30mw04caa6.jpg" srcset="/img/loading.gif" lazyload></p>
<p><code>embstr</code> 编码的字符串对象在执行命令时， 产生的效果和 <code>raw</code> 编码的字符串对象执行命令时产生的效果是相同的， 但使用 <code>embstr</code> 编码的字符串对象来保存短字符串值有以下好处：</p>
<ol>
<li><code>embstr</code> 编码将创建字符串对象所需的内存分配次数从 <code>raw</code> 编码的两次降低为一次。</li>
<li>释放 <code>embstr</code> 编码的字符串对象只需要调用一次内存释放函数， 而释放 <code>raw</code> 编码的字符串对象需要调用两次内存释放函数。</li>
<li>因为 <code>embstr</code> 编码的字符串对象的所有数据都保存在一块连续的内存里面， 所以这种编码的字符串对象比起 <code>raw</code> 编码的字符串对象能够更好地利用缓存带来的优势。</li>
<li>可以用 <code>long double</code> 类型表示的浮点数在 Redis 中也是作为字符串值来保存的： 如果我们要保存一个浮点数到字符串对象里面， 那么程序会先将这个浮点数转换成字符串值， 然后再保存起转换所得的字符串值。然后要使用该值进行数值运算操作时，又会将它专为浮点类型，处理完后又转为字符串类型存入数据库中</li>
</ol>
<p>存储的值类型与编码类型可以总结如下表：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">编码</th>
</tr>
</thead>
<tbody><tr>
<td align="left">可以用 <code>long</code> 类型保存的整数。</td>
<td align="left"><code>int</code></td>
</tr>
<tr>
<td align="left">可以用 <code>long double</code> 类型保存的浮点数。</td>
<td align="left"><code>embstr</code> 或者 <code>raw</code></td>
</tr>
<tr>
<td align="left">字符串值， 或者因为长度太大而没办法用 <code>long</code> 类型表示的整数， 又或者因为长度太大而没办法用 <code>long double</code> 类型表示的浮点数。</td>
<td align="left"><code>embstr</code> 或者 <code>raw</code></td>
</tr>
</tbody></table>
<h3 id="编码转换："><a href="#编码转换：" class="headerlink" title="编码转换："></a>编码转换：</h3><p><strong><code>int</code> 编码的字符串对象和 <code>embstr</code> 编码的字符串对象在条件满足的情况下， 会被转换为 <code>raw</code> 编码的字符串对象。</strong></p>
<p>对于 <code>int</code> 编码的字符串对象来说， 如果我们向对象执行了一些命令， 使得这个对象保存的不再是整数值， 而是一个字符串值， 那么字符串对象的编码将从 <code>int</code> 变为 <code>raw</code> 。如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">redis&gt; </span><span class="language-bash">SET number 10086</span><br>OK<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">redis&gt; </span><span class="language-bash">OBJECT ENCODING number</span><br>&quot;int&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">redis&gt; </span><span class="language-bash">APPEND number <span class="hljs-string">&quot; is a good number!&quot;</span></span><br>(integer) 23<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">redis&gt; </span><span class="language-bash">GET number</span><br>&quot;10086 is a good number!&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">redis&gt; </span><span class="language-bash">OBJECT ENCODING number</span><br>&quot;raw&quot;<br></code></pre></td></tr></table></figure>

<p>另外， 因为 Redis 没有为 <code>embstr</code> 编码的字符串对象编写任何相应的修改程序，所以 <code>embstr</code> 编码的字符串对象在执行任何修改命令时， 程序会先将对象的编码从 <code>embstr</code> 转换成 <code>raw</code> ， 然后再执行修改命令； 因为这个原因， <code>embstr</code> 编码的字符串对象在执行修改命令之后， 总会变成一个 <code>raw</code>编码的字符串对象。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">redis&gt; </span><span class="language-bash">SET msg <span class="hljs-string">&quot;hello world&quot;</span></span><br>OK<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">redis&gt; </span><span class="language-bash">OBJECT ENCODING msg</span><br>&quot;embstr&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">redis&gt; </span><span class="language-bash">APPEND msg <span class="hljs-string">&quot; again!&quot;</span></span><br>(integer) 18<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">redis&gt; </span><span class="language-bash">OBJECT ENCODING msg</span><br>&quot;raw&quot;<br></code></pre></td></tr></table></figure>

<h2 id="LIst"><a href="#LIst" class="headerlink" title="LIst"></a>LIst</h2><h3 id="encoding-1"><a href="#encoding-1" class="headerlink" title="encoding"></a>encoding</h3><p>列表对象的编码之前可以是 <code>ziplist</code> 或者 <code>linkedlist</code> 。现在改了，全部都用<code>quicklist</code>。</p>
<p>所以列表对象就没有像上面的String对象有选择相应的encoing和转换的烦恼。我们改为介绍下<strong>快速列表</strong>。</p>
<h3 id="快速列表："><a href="#快速列表：" class="headerlink" title="快速列表："></a>快速列表：</h3><p><strong>为什么要专门设计一个 quicklist 来重新定义呢？</strong></p>
<p>redis的注释解释到：</p>
<blockquote>
<p>quicklist.c - A doubly linked list of ziplists (一个ziplist的双向链表)</p>
</blockquote>
<p>我们再看看它的结构：</p>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGgy1h762yvua7oj30ok0gh0tz.jpg" srcset="/img/loading.gif" lazyload></p>
<p>现在明白了吧，redis并没有放弃<code>ziplist</code> 和 <code>linkedlist</code>，<code>quicklist</code>其实就是一个以 <code>ziplist</code>为节点（quicklistNode中存放指向 ziplist 的指针）的<code>linkedlist</code>。</p>
<p>现在我们能回答我们最初的问题了，quicklist 的结构为什么这样设计呢？答案是<code>quicklist</code> 平衡了 <code>ziplist</code> 和<code>linkedlist</code>的优缺点：</p>
<ul>
<li><p>双向链表方便在于在表的两端进行 push 和 pop 操作，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片，不利于内存管理。</p>
</li>
<li><p>ziplist 由于是一整块连续内存，所以存储效率很高。但是，它不利于修改操作，每次数据变动都会引发一次内存的 realloc。特别是当 ziplist 长度很长的时候，一次 realloc 可能会导致大批量的数据拷贝，进一步降低性能。</p>
</li>
</ul>
<p>那么现在的问题是<code>quicklistNode</code>中的<code>ziplist</code>该多大比较合适呢？毕竟太小就变回<code>quicklist</code>，太大对每个节点中<code>ziplist</code>的操作又要降低性能，所以这个长度肯定是一个平衡值，它是 redis 提供的一个选项配置，默认是 -2，来看下官方说明：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-5: max size: 64 Kb  -- not recommended <span class="hljs-keyword">for</span> normal workloads</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-4: max size: 32 Kb  -- not recommended</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-3: max size: 16 Kb  -- probably not recommended</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-2: max size: 8 Kb   -- good</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-1: max size: 4 Kb   -- good</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Positive numbers mean store up to _exactly_ that number of elements</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">per list node.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">but <span class="hljs-keyword">if</span> your use <span class="hljs-keyword">case</span> is unique, adjust the settings as necessary.</span><br>list-max-ziplist-size -2<br></code></pre></td></tr></table></figure>

<p>即一般整个节点为8kb大小</p>
<h4 id="源码字段解释："><a href="#源码字段解释：" class="headerlink" title="源码字段解释："></a>源码字段解释：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">quicklistNode</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">quicklistNode</span> *prev; <span class="hljs-comment">//上一个node节点</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">quicklistNode</span> *next; <span class="hljs-comment">//下一个node</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *zl;            <span class="hljs-comment">//保存的数据 压缩前ziplist 压缩后压缩的数据</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sz;             <span class="hljs-comment">/* ziplist size in bytes */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count : <span class="hljs-number">16</span>;     <span class="hljs-comment">/* count of items in ziplist */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> encoding : <span class="hljs-number">2</span>;   <span class="hljs-comment">/* RAW==1 or LZF==2 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> container : <span class="hljs-number">2</span>;  <span class="hljs-comment">/* NONE==1 or ZIPLIST==2 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> recompress : <span class="hljs-number">1</span>; <span class="hljs-comment">/* was this node previous compressed? */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> attempted_compress : <span class="hljs-number">1</span>; <span class="hljs-comment">/* node can&#x27;t compress; too small */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> extra : <span class="hljs-number">10</span>; <span class="hljs-comment">/* more bits to steal for future usage */</span><br>&#125; quicklistNode;<br></code></pre></td></tr></table></figure>

<ul>
<li>prev: 指向链表前一个节点的指针。</li>
<li>next: 指向链表后一个节点的指针。</li>
<li>zl: 数据指针。如果当前节点的数据没有压缩，那么它指向一个ziplist结构；否则，它指向一个quicklistLZF结构。</li>
<li>sz: 表示zl指向的ziplist的总大小（包括<code>zlbytes</code>, <code>zltail</code>, <code>zllen</code>, <code>zlend</code>和各个数据项）。需要注意的是：如果ziplist被压缩了，那么这个sz的值仍然是压缩前的ziplist大小。</li>
<li>count: 表示ziplist里面包含的数据项个数。这个字段只有16bit。</li>
<li>encoding: 表示ziplist是否压缩了（以及用了哪个压缩算法）。目前只有两种取值：2表示被压缩了（而且用的是LZF压缩算法），1表示没有压缩。</li>
<li>container: 是一个预留字段。本来设计是用来表明一个quicklist节点下面是直接存数据，还是使用ziplist存数据，或者用其它的结构来存数据（用作一个数据容器，所以叫container）。但是，在目前的实现中，这个值是一个固定的值2，表示使用ziplist作为数据容器。</li>
<li>recompress: 当我们使用类似lindex这样的命令查看了某一项本来压缩的数据时，需要把数据暂时解压，这时就设置recompress&#x3D;1做一个标记，等有机会再把数据重新压缩。</li>
<li>attempted_compress: 这个值只对Redis的自动化测试程序有用。我们不用管它。</li>
<li>extra: 其它扩展字段。目前Redis的实现里也没用上。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">quicklistLZF</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sz; <span class="hljs-comment">/* LZF size in bytes*/</span><br>    <span class="hljs-type">char</span> compressed[];<br>&#125; quicklistLZF;<br></code></pre></td></tr></table></figure>

<ul>
<li>sz: 表示压缩后的ziplist大小。</li>
<li>compressed: 是个柔性数组（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Flexible_array_member">flexible array member</a>），存放压缩后的ziplist字节数组。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">quicklist</span> &#123;<br>    quicklistNode *head;<br>    quicklistNode *tail;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> count;        <span class="hljs-comment">/* total count of all entries in all ziplists */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len;          <span class="hljs-comment">/* number of quicklistNodes */</span><br>    <span class="hljs-type">int</span> fill : QL_FILL_BITS;              <span class="hljs-comment">/* fill factor for individual nodes */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> compress : QL_COMP_BITS; <span class="hljs-comment">/* depth of end nodes not to compress;0=off */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bookmark_count: QL_BM_BITS;<br>    quicklistBookmark bookmarks[];<br>&#125; quicklist;<br></code></pre></td></tr></table></figure>

<ul>
<li>head: 指向头节点（左侧第一个节点）的指针。</li>
<li>tail: 指向尾节点（右侧第一个节点）的指针。</li>
<li>count: 所有ziplist数据项的个数总和。</li>
<li>len: quicklist节点的个数。</li>
<li>fill: 16bit，ziplist大小设置，存放<code>list-max-ziplist-size</code>参数的值。</li>
<li>compress: 16bit，节点压缩深度设置，存放<code>list-compress-depth</code>参数的值。</li>
</ul>
<h4 id="压缩机制："><a href="#压缩机制：" class="headerlink" title="压缩机制："></a>压缩机制：</h4><p>在上面的源码字段解释部分，我们提到了<code>quicklistLZF</code>，可能你有疑惑，这是什么东西？什么时候会去压缩？其实是 redis 为 quicklist 提供了一套压缩机制。</p>
<p>当 quicklist 很长的时候，最容易被访问的很可能是两端的数据，中间的数据被访问的频率比较低（访问起来性能也很低）。如果应用场景符合这个特点，redis 还提供了一个选项，能够把中间的数据节点进行压缩，从而进一步节省内存空间。Redis的配置参数 <code>list-compress-depth</code> 就是用来完成这个设置的。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xl">列表也可以被压缩。<br># 压缩深度指的是列表两侧开始不需要 ziplist 的节点的深度（下面会解释）。<br>#	为了执行快速的 push/pop 操作，列表的头和尾通常不压缩。<br># 设置如下:<br># <span class="hljs-number">0</span>: 禁用压缩机制<br># <span class="hljs-number">1</span>: 压缩深度 <span class="hljs-number">1</span> 表示压缩除了头和尾之外的所有内部节点。例如结构：<br>#    [<span class="hljs-function"><span class="hljs-title">head</span>]-&gt;</span><span class="hljs-function"><span class="hljs-title">node</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">node</span>-&gt;</span>...-&gt;<span class="hljs-function"><span class="hljs-title">node</span>-&gt;</span>[tail]<br>#    因为[head], [tail]永远不会被压缩，它们直接的 node 都后被压缩。<br># <span class="hljs-number">2</span>: [<span class="hljs-function"><span class="hljs-title">head</span>]-&gt;</span>[<span class="hljs-function"><span class="hljs-title">next</span>]-&gt;</span><span class="hljs-function"><span class="hljs-title">node</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">node</span>-&gt;</span>...-&gt;<span class="hljs-function"><span class="hljs-title">node</span>-&gt;</span>[<span class="hljs-function"><span class="hljs-title">prev</span>]-&gt;</span>[tail]<br>#    <span class="hljs-number">2</span> 表示不压缩 <span class="hljs-function"><span class="hljs-title">head</span>，head-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>，tail-&gt;</span>prev 和 tail, 它们之前的 node 都压缩。<br># <span class="hljs-number">3</span>: [<span class="hljs-function"><span class="hljs-title">head</span>]-&gt;</span>[<span class="hljs-function"><span class="hljs-title">next</span>]-&gt;</span>[<span class="hljs-function"><span class="hljs-title">next</span>]-&gt;</span><span class="hljs-function"><span class="hljs-title">node</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">node</span>-&gt;</span>...-&gt;<span class="hljs-function"><span class="hljs-title">node</span>-&gt;</span>[<span class="hljs-function"><span class="hljs-title">prev</span>]-&gt;</span>[<span class="hljs-function"><span class="hljs-title">prev</span>]-&gt;</span>[tail]<br># 以此类推...<br>list-compress-depth <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>这个参数默认是 0 也就是不压缩，Redis对于 quicklist 内部节点的压缩算法，采用的 LZF —— 一种无损压缩算法，有兴趣的可以看下 <a href="https://link.juejin.cn/?target=https://zh.wikipedia.org/wiki/LZFSE">zh.wikipedia.org&#x2F;wiki&#x2F;LZFSE</a>。</p>
<h4 id="常见操作解析："><a href="#常见操作解析：" class="headerlink" title="常见操作解析："></a>常见操作解析：</h4><p><strong>头插和尾插</strong></p>
<p>总结为先判断了是否能直接在当前头|尾节点能插入，如果能就直接插入到对应的ziplist里，否则就需要新建一个新节点再操作了。</p>
<p><strong>特定位置插入</strong></p>
<ul>
<li>如果当前被插入节点不满，直接插入。</li>
<li>如果当前被插入节点是满的，要插入的位置是当前节点的尾部，且后一个节点有空间，那就插到后一个节点的头部。</li>
<li>如果当前被插入节点是满的，要插入的位置是当前节点的头部，且前一个节点有空间，那就插到前一个节点的尾部。  </li>
<li>如果当前被插入节点是满的，前后节点也都是满的，要插入的位置是当前节点的头部或者尾部，那就创建一个新的节点插进去。  </li>
<li>否则，当前节点是满的，且要插入的位置在当前节点的中间位置，我们需要把当前节点分裂成两个新节点，然后再插入。</li>
</ul>
<p>相关源码分析可以看这<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1777876">Redis源码剖析之快速列表(quicklist)</a></p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><h3 id="encoding-2"><a href="#encoding-2" class="headerlink" title="encoding"></a>encoding</h3><p>哈希对象的编码可以是 <code>ziplist</code> 或者 <code>hashtable</code> 。</p>
<ol>
<li><p><code>ziplist</code> 编码的哈希对象使用压缩列表作为底层实现， 每当有新的键值对要加入到哈希对象时， 程序会先将保存了键的压缩列表节点推入到压缩列表表尾， 然后再将保存了值的压缩列表节点推入到压缩列表表尾， 因此保存了同一键值对的两个节点总是紧挨在一起， 保存键的节点在前， 保存值的节点在后。</p>
</li>
<li><p><code>hashtable</code> 编码的哈希对象使用字典作为底层实现， 哈希对象中的每个键值对都使用一个字典键值对来保存。</p>
</li>
</ol>
<h3 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h3><p>当哈希对象可以同时满足以下两个条件时， 哈希对象使用 <code>ziplist</code> 编码：</p>
<ol>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于 <code>64</code> 字节；</li>
<li>哈希对象保存的键值对数量小于 <code>512</code> 个；</li>
</ol>
<p>不能满足这两个条件的哈希对象需要使用 <code>hashtable</code> 编码。</p>
<p>对于使用 <code>ziplist</code> 编码的列表对象来说， 当使用 <code>ziplist</code> 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在压缩列表里的所有键值对都会被转移并保存到字典里面， 对象的编码也会从 <code>ziplist</code> 变为 <code>hashtable</code> 。</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="encoding-3"><a href="#encoding-3" class="headerlink" title="encoding"></a>encoding</h3><p>集合对象的编码可以是 <code>intset</code> 或者 <code>hashtable</code> 。</p>
<ol>
<li><p><code>intset</code> 编码的集合对象使用整数集合作为底层实现， 集合对象包含的所有元素都被保存在整数集合的contents数组里面。</p>
</li>
<li><p>另一方面， <code>hashtable</code> 编码的集合对象使用字典作为底层实现， 字典的每个键都是一个字符串对象， 每个字符串对象包含了一个集合元素， 而字典的值则全部被设置为 <code>NULL</code> 。</p>
</li>
</ol>
<h3 id="编码转换-1"><a href="#编码转换-1" class="headerlink" title="编码转换"></a>编码转换</h3><p>当集合对象可以同时满足以下两个条件时， 对象使用 <code>intset</code> 编码：</p>
<ol>
<li>集合对象保存的所有元素都是整数值；</li>
<li>集合对象保存的元素数量不超过 <code>512</code> 个；（可通过set-max-intset-entries修改）</li>
</ol>
<p>不能满足这两个条件的集合对象需要使用 <code>hashtable</code> 编码。</p>
<p>对于使用 <code>intset</code> 编码的集合对象来说， 当使用 <code>intset</code> 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在整数集合中的所有元素都会被转移并保存到字典里面， 并且对象的编码也会从 <code>intset</code> 变为 <code>hashtable</code> 。</p>
<h2 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h2><h3 id="encoding-4"><a href="#encoding-4" class="headerlink" title="encoding"></a>encoding</h3><p>有序集合的编码可以是 <code>ziplist</code> 或者 <code>skiplist</code> </p>
<ol>
<li><p><code>ziplist</code> 编码的有序集合对象使用压缩列表作为底层实现， 每个集合元素使用两个紧挨在一起的压缩列表节点来保存， 第一个节点保存元素的成员（member）， 而第二个元素则保存元素的分值（score）。</p>
<p>压缩列表内的集合元素按分值从小到大进行排序， 分值较小的元素被放置在靠近表头的方向， 而分值较大的元素则被放置在靠近表尾的方向。（对于被Zset用来做底层实现的ziplist的特性吧）</p>
</li>
<li><p><strong><code>skiplist</code> 编码的有序集合对象使用 <code>zset</code> 结构作为底层实现， 一个 <code>zset</code> 结构同时包含一个字典和一个跳跃表：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zset</span> &#123;<br>    zskiplist *zsl;<br>    dict *dict;<br>&#125; zset;<br></code></pre></td></tr></table></figure>

<p><code>zset</code> 结构中的 <code>zsl</code> 跳跃表按分值从小到大保存了所有集合元素， 每个跳跃表节点都保存了一个集合元素： 跳跃表节点的 <code>object</code> 属性保存了元素的成员， 而跳跃表节点的 <code>score</code> 属性则保存了元素的分值。 通过这个跳跃表， 程序可以对有序集合进行范围型操作， 比如 ZRANK、 ZRANGE 等命令就是基于跳跃表 API 来实现的。</p>
<p>除此之外， <code>zset</code> 结构中的 <code>dict</code> 字典为有序集合创建了一个从成员到分值的映射， 字典中的每个键值对都保存了一个集合元素： <strong>字典的键保存了元素的成员， 而字典的值则保存了元素的分值</strong>。 通过这个字典， 程序可以用 O(1) 复杂度查找给定成员的分值， ZSCORE 命令就是根据这一特性实现的， 而很多其他有序集合命令都在实现的内部用到了这一特性。</p>
</li>
</ol>
<p>有序集合每个元素的成员都是一个字符串对象， 而每个元素的分值都是一个 <code>double</code> 类型的浮点数。 值得一提的是， 虽然 <code>zset</code> 结构同时使用跳跃表和字典来保存有序集合元素， <strong>但这两种数据结构都会通过指针来共享相同元素的成员和分值</strong>， 所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值， 也不会因此而浪费额外的内存。</p>
<h3 id="编码转换：-1"><a href="#编码转换：-1" class="headerlink" title="编码转换："></a>编码转换：</h3><p>当有序集合对象可以同时满足以下两个条件时， 对象使用 <code>ziplist</code> 编码：</p>
<ol>
<li>有序集合保存的元素数量小于 <code>128</code> 个；</li>
<li>有序集合保存的所有元素成员的长度都小于 <code>64</code> 字节；</li>
</ol>
<p>不能满足以上两个条件的有序集合对象将使用 <code>skiplist</code> 编码。</p>
<p>对于使用 <code>ziplist</code> 编码的有序集合对象来说， 当使用 <code>ziplist</code> 编码所需的两个条件中的任意一个不能被满足时， 程序就会执行编码转换操作， 将原本储存在压缩列表里面的所有集合元素转移到 <code>zset</code> 结构里面， 并将对象的编码从 <code>ziplist</code> 改为 <code>skiplist</code> 。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7/" class="category-chain-item">打怪升级</a>
  
  
    <span>></span>
    
  <a href="/categories/%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7/redis/" class="category-chain-item">redis</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/redis/">#redis</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>🧀Redis对象----五大对象</div>
      <div>https://opengxj.github.io/2022/10/15/Redis对象----五大对象/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>PEngxJ</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年10月15日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/10/16/Mysql--%E8%AE%B0%E5%BD%95%E7%9A%84%E8%A1%8C%E6%A0%BC%E5%BC%8F/" title="🍞Mysql--记录的行格式">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">🍞Mysql--记录的行格式</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/10/15/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84----%E8%B7%B3%E8%B7%83%E8%A1%A8%E3%80%81%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E3%80%81%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/" title="🥞Redis数据结构----跳跃表、整数集合、压缩列表">
                        <span class="hidden-mobile">🥞Redis数据结构----跳跃表、整数集合、压缩列表</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Mamba</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>KOBE</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
